<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Arena Blitz - Test Suite</title>
  <style>
    body { font-family: monospace; background: #000; color: #0f0; padding: 20px; }
    .test { margin: 10px 0; }
    .pass { color: #0f0; }
    .fail { color: #f00; }
    .warn { color: #ff0; }
    .section { color: #0ff; font-weight: bold; margin: 20px 0 10px 0; }
    #results { white-space: pre-line; }
  </style>
</head>
<body>
  <h1>Arena Blitz - Automated Test Suite</h1>
  <div id="results"></div>
  
  <script>
    // Load the game first
    let gameScript = null;
    
    function log(message, type = 'info') {
      const results = document.getElementById('results');
      const color = type === 'pass' ? '#0f0' : type === 'fail' ? '#f00' : type === 'warn' ? '#ff0' : type === 'section' ? '#0ff' : '#fff';
      const span = document.createElement('span');
      span.style.color = color;
      span.textContent = message;
      results.appendChild(span);
      results.appendChild(document.createTextNode('\n'));
    }
    
    // Test utilities
    function assert(condition, message) {
      if (condition) {
        log(`✓ ${message}`, 'pass');
        return true;
      } else {
        log(`✗ ${message}`, 'fail');
        return false;
      }
    }
    
    function warn(message) {
      log(`⚠ ${message}`, 'warn');
    }
    
    function section(title) {
      log(`\n=== ${title} ===`, 'section');
    }
    
    // Mock game functions
    let mockGame = null;
    let mockPlayer = null;
    let testResults = {
      passed: 0,
      failed: 0,
      warnings: 0
    };
    
    function createMockGame() {
      return {
        t: 0,
        wave: 1,
        kills: 0,
        state: 1, // RUN
        width: () => 800,
        height: () => 600,
        player: {
          x: 400, y: 300,
          vx: 0, vy: 0,
          speed: 260,
          radius: 12,
          color: '#00ff00',
          hp: 100,
          maxHp: 100,
          stamina: 100,
          exhausted: 0,
          ammo: Infinity,
          upgradeShots: 0,
          bulletType: 'normal',
          bulletTimer: 0,
          bulletPattern: 'single',
          patternTimer: 0,
          fireDelay: 0.12,
          fireTimer: 0,
          staticPowerups: [],
          healthRegen: false,
          staminaRegen: 1.0,
          bulletSize: 1.0,
          bulletSpeed: 1.0,
          piercingShot: false,
          damageReduction: 0,
          knockbackImmune: false,
          magneticCrystals: false,
          lucky: false,
          healthRegenTimer: 0,
        }
      };
    }
    
    // Test 1: Powerup Stacking
    function testPowerupStacking() {
      section("POWERUP STACKING TESTS");
      
      mockGame = createMockGame();
      const p = mockGame.player;
      
      // Test dual shot + effects
      p.upgradeShots = 100;
      p.bulletType = 'explosive';
      p.bulletTimer = 50;
      
      assert(p.upgradeShots === 100, "Dual shot counter preserved");
      assert(p.bulletType === 'explosive', "Bullet effect preserved");
      assert(p.bulletTimer === 50, "Effect timer preserved");
      
      // Test pattern + effects
      p.bulletPattern = 'triple';
      p.patternTimer = 75;
      
      assert(p.bulletPattern === 'triple', "Pattern preserved with effect");
      assert(p.bulletType === 'explosive', "Effect preserved with pattern");
      
      // Test static powerup application
      p.speed = 260;
      p.speed *= 1.125; // Speed boost
      assert(Math.abs(p.speed - 292.5) < 1, "Static powerup speed boost applied");
      
      testResults.passed += 5;
    }
    
    // Test 2: Bullet Mechanics
    function testBulletMechanics() {
      section("BULLET MECHANICS TESTS");
      
      mockGame = createMockGame();
      const p = mockGame.player;
      
      // Test piercing shot powerup
      p.piercingShot = true;
      const pierceCount = p.piercingShot ? 1 : 0;
      assert(pierceCount === 1, "Piercing shot powerup gives 1 pierce");
      
      // Test homing bullets
      const homingPierces = 3;
      assert(homingPierces === 3, "Homing bullets get 3 pierces");
      
      // Test bullet size/speed modifications
      p.bulletSize = 1.5;
      p.bulletSpeed = 1.25;
      const expectedSize = 4 * 1.5;
      const expectedSpeed = 720 * 1.25;
      assert(expectedSize === 6, "Bullet size modifier applied correctly");
      assert(expectedSpeed === 900, "Bullet speed modifier applied correctly");
      
      // Test fire rate
      p.fireDelay = 0.12;
      p.fireDelay *= 0.875; // Rapid fire
      assert(Math.abs(p.fireDelay - 0.105) < 0.001, "Rapid fire modifier applied");
      
      testResults.passed += 5;
    }
    
    // Test 3: Drop Rate Calculations
    function testDropRates() {
      section("DROP RATE TESTS");
      
      mockGame = createMockGame();
      const p = mockGame.player;
      
      // Test normal drop rates
      const normalRate = 0.03;
      assert(normalRate === 0.03, "Normal crystal drop rate is 3%");
      
      // Test lucky powerup
      p.lucky = true;
      const luckyRate = 0.06;
      assert(luckyRate === 0.06, "Lucky powerup doubles drop rate to 6%");
      
      // Test crystal distribution
      const crystalTypes = 7; // upgrade, triple, quad, homing, explosive, ricochet, lightning
      const individualRate = normalRate / crystalTypes;
      assert(Math.abs(individualRate - 0.00428) < 0.001, "Each crystal type has ~0.43% chance");
      
      testResults.passed += 3;
    }
    
    // Test 4: Enemy Behavior System
    function testEnemyBehaviors() {
      section("ENEMY BEHAVIOR TESTS");
      
      // Test behavior pools by wave
      const behaviorPools = [
        ['normal', 'zigzag'],
        ['normal', 'zigzag', 'flank'],
        ['normal', 'zigzag', 'flank', 'charge'],
        ['normal', 'zigzag', 'flank', 'charge', 'erratic']
      ];
      
      // Test wave 1-2
      const pool1 = behaviorPools[Math.min(Math.floor((1 - 1) / 2), behaviorPools.length - 1)];
      assert(pool1.length === 2, "Waves 1-2 have 2 behaviors");
      assert(pool1.includes('normal') && pool1.includes('zigzag'), "Early waves have basic behaviors");
      
      // Test wave 7+
      const pool4 = behaviorPools[Math.min(Math.floor((7 - 1) / 2), behaviorPools.length - 1)];
      assert(pool4.length === 5, "Wave 7+ has all 5 behaviors");
      assert(pool4.includes('erratic'), "Late waves include erratic behavior");
      
      // Test mini-boss frequency
      const wave5Boss = (5 % 5 === 0); // Every 5 waves
      assert(wave5Boss, "Mini-bosses spawn on waves divisible by 5");
      
      testResults.passed += 4;
    }
    
    // Test 5: Combat Systems
    function testCombatSystems() {
      section("COMBAT SYSTEM TESTS");
      
      mockGame = createMockGame();
      const p = mockGame.player;
      
      // Test damage reduction
      p.damageReduction = 0.25;
      const incomingDamage = 12;
      const actualDamage = Math.ceil(incomingDamage * (1 - p.damageReduction));
      assert(actualDamage === 9, "Damage reduction applies correctly (25% reduction)");
      
      // Test health regeneration
      p.healthRegen = true;
      p.hp = 90;
      p.maxHp = 125;
      const newHp = Math.min(p.hp + 1, p.maxHp);
      assert(newHp === 91, "Health regeneration works within max HP");
      
      // Test stamina system
      p.stamina = 50;
      p.staminaRegen = 1.25;
      const regenRate = 12.5 * 0.016 * p.staminaRegen; // 16ms frame
      const expectedStamina = Math.min(100, p.stamina + regenRate);
      assert(expectedStamina > 50, "Stamina regeneration with boost works");
      
      testResults.passed += 3;
    }
    
    // Test 6: UI and Visual Systems
    function testUISystem() {
      section("UI SYSTEM TESTS");
      
      // Test HUD elements exist
      const hudElements = ['healthBar', 'ammoBar', 'staminaBar', 'wave', 'kills'];
      let elementsFound = 0;
      
      hudElements.forEach(id => {
        if (document.getElementById(id)) elementsFound++;
      });
      
      warn(`Found ${elementsFound}/${hudElements.length} HUD elements (game not loaded)`);
      
      // Test powerup dialog elements
      const dialogElements = ['powerupDialog', 'powerupOption1', 'powerupOption2', 'powerupOption3'];
      let dialogFound = 0;
      
      dialogElements.forEach(id => {
        if (document.getElementById(id)) dialogFound++;
      });
      
      warn(`Found ${dialogFound}/${dialogElements.length} dialog elements (game not loaded)`);
      
      testResults.warnings += 2;
    }
    
    // Test 7: Physics and Collision
    function testPhysicsSystem() {
      section("PHYSICS SYSTEM TESTS");
      
      // Test spatial hash grid
      const cellSize = 64;
      const testX = 128, testY = 192;
      const expectedCellX = Math.floor(testX / cellSize);
      const expectedCellY = Math.floor(testY / cellSize);
      
      assert(expectedCellX === 2, "Spatial hash X calculation correct");
      assert(expectedCellY === 3, "Spatial hash Y calculation correct");
      
      // Test collision math
      const dist1 = Math.hypot(100, 100);
      const dist2 = Math.sqrt(100*100 + 100*100);
      assert(Math.abs(dist1 - dist2) < 0.001, "Distance calculations consistent");
      
      // Test normalization
      const [nx, ny] = [3, 4];
      const length = Math.hypot(nx, ny);
      const [normX, normY] = [nx/length, ny/length];
      assert(Math.abs(Math.hypot(normX, normY) - 1) < 0.001, "Vector normalization works");
      
      testResults.passed += 4;
    }
    
    // Test 8: Lightning Chain Logic
    function testLightningChain() {
      section("LIGHTNING CHAIN TESTS");
      
      // Test chain radius
      const chainRadius = 120;
      assert(chainRadius === 120, "Lightning chain radius is 120px (2x original)");
      
      // Test distance calculation for chaining
      const bulletX = 100, bulletY = 100;
      const enemy1X = 150, enemy1Y = 150; // ~70px away
      const enemy2X = 250, enemy2Y = 250; // ~212px away
      
      const dist1 = Math.hypot(enemy1X - bulletX, enemy1Y - bulletY);
      const dist2 = Math.hypot(enemy2X - bulletX, enemy2Y - bulletY);
      
      assert(dist1 < chainRadius, "Enemy within chain radius gets hit");
      assert(dist2 > chainRadius, "Enemy outside chain radius is safe");
      
      // Test unlimited chaining
      const maxEnemiesInRadius = 1000; // No artificial limit
      assert(maxEnemiesInRadius > 100, "Lightning can chain to unlimited enemies");
      
      testResults.passed += 4;
    }
    
    // Execute all tests
    function runAllTests() {
      log("Starting Arena Blitz Test Suite...\n");
      
      try {
        testPowerupStacking();
        testBulletMechanics();
        testDropRates();
        testEnemyBehaviors();
        testCombatSystems();
        testUISystem();
        testPhysicsSystem();
        testLightningChain();
        
        log(`\n=== TEST RESULTS ===`, 'section');
        log(`✓ Passed: ${testResults.passed}`, 'pass');
        log(`✗ Failed: ${testResults.failed}`, 'fail');
        log(`⚠ Warnings: ${testResults.warnings}`, 'warn');
        
        if (testResults.failed === 0) {
          log('\n🎉 ALL TESTS PASSED! Game systems are working correctly.', 'pass');
        } else {
          log(`\n❌ ${testResults.failed} tests failed. Check implementation.`, 'fail');
        }
        
      } catch (error) {
        log(`\n💥 TEST SUITE ERROR: ${error.message}`, 'fail');
      }
    }
    
    // Run tests when page loads
    window.addEventListener('load', runAllTests);
  </script>
</body>
</html>