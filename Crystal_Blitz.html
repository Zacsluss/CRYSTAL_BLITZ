<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Crystal Blitz â€” Arena Shooter</title>
  <style>
    :root {
      --bg: #0b0d10;
      --fg: #e3e7ef;
      --muted: #99a2b2;
      --accent: #5af2c7;
      --danger: #ff5b6e;
      --warning: #ffd166;
      --panel: #12161d;
      --panel2: #0f1319;
      --shadow: rgba(0,0,0,0.35);
      --health-gradient: linear-gradient(90deg, #ff6b6b, #ffa5a5);
      --stamina-gradient: linear-gradient(90deg, #ffd166, #ffeb99);
    }
    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--fg);
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Noto Sans", "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    #hud {
      position: fixed;
      top: 20px;
      left: 20px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      padding: 20px 24px;
      border-radius: 10px;
      box-shadow: 0 6px 14px var(--shadow);
      font-size: 28px;
      user-select: none;
      pointer-events: none;
      min-width: 440px;
      opacity: 0.5;
      z-index: 200;
    }
    #hud .row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
      white-space: nowrap;
    }
    #hud .bar {
      --w: 320px;
      position: relative;
      width: var(--w);
      height: 16px;
      background: #1a1f29;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid #1f2430;
    }
    #hud .bar > i {
      position: absolute;
      left: 0; top: 0; bottom: 0;
      background: linear-gradient(90deg, var(--accent), #34d1ff);
      box-shadow: inset 0 0 6px rgba(0,0,0,0.25);
    }
    #hud .bar.health > i { 
      background: var(--health-gradient); 
      box-shadow: 0 0 8px rgba(255, 107, 107, 0.6), inset 0 0 6px rgba(0,0,0,0.25);
    }
    #hud .bar.stamina > i { 
      background: var(--stamina-gradient); 
      box-shadow: 0 0 8px rgba(255, 209, 102, 0.6), inset 0 0 6px rgba(0,0,0,0.25);
    }
    #hud .muted { color: var(--muted); }
    #help {
      position: fixed;
      right: 12px;
      top: 12px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      padding: 10px 12px;
      border-radius: 10px;
      box-shadow: 0 6px 14px var(--shadow);
      user-select: none;
      font-size: 14px;
      max-width: 360px;
    }
    #help kbd {
      background: #1a1f29;
      border: 1px solid #293140;
      border-bottom-width: 2px;
      padding: 2px 6px;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
    }
    #crystalLegend {
      position: fixed;
      right: 12px;
      bottom: 12px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      padding: 10px 12px;
      border-radius: 10px;
      box-shadow: 0 6px 14px var(--shadow);
      user-select: none;
      font-size: 14px;
      max-width: 280px;
      display: none;
    }
    #crystalLegend h3 {
      margin: 0 0 8px 0;
      color: var(--accent);
      font-size: 16px;
    }
    .crystal-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
    }
    .crystal-color {
      width: 16px;
      height: 16px;
      border-radius: 2px;
      border: 1px solid rgba(255,255,255,0.3);
      flex-shrink: 0;
    }
    .crystal-name {
      color: var(--fg);
      font-weight: 500;
      min-width: 80px;
    }
    .crystal-desc {
      color: var(--muted);
      font-size: 12px;
      flex-grow: 1;
    }
    #banner {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: radial-gradient(1200px 700px at 40% 35%, rgba(90,242,199,0.08), transparent),
                  linear-gradient(180deg, var(--panel), var(--panel2));
      padding: 24px 28px;
      border-radius: 14px;
      box-shadow: 0 12px 40px var(--shadow);
      text-align: center;
      max-width: 700px;
      line-height: 1.5;
      opacity: 0;
      animation: menuFadeIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }
    #banner h1 {
      margin: 0 0 10px 0; 
      font-size: 28px; 
      letter-spacing: 0.3px;
      opacity: 0;
      transform: translateY(-20px);
      animation: titleSlideIn 0.6s ease-out 0.3s forwards;
    }
    #banner .sub { 
      color: var(--muted); 
      margin-bottom: 16px;
      opacity: 0;
      transform: translateY(-15px);
      animation: subtitleSlideIn 0.5s ease-out 0.5s forwards;
    }
    #banner button {
      background: var(--accent);
      color: #002e24;
      border: none;
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 8px 16px rgba(90,242,199,0.25);
      opacity: 0;
      transform: translateY(20px) scale(0.9);
      animation: buttonSlideIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.7s forwards;
      transition: all 0.3s ease;
    }
    #banner button:hover { 
      filter: brightness(1.05);
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 12px 24px rgba(90,242,199,0.4);
    }
    #banner button:active {
      transform: translateY(0px) scale(0.98);
    }
    .controls-panel {
      margin: 16px 0;
      padding: 16px;
      background: linear-gradient(135deg, rgba(26, 31, 41, 0.9), rgba(18, 22, 29, 0.8));
      border-radius: 10px;
      border: 1px solid rgba(90, 242, 199, 0.2);
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      opacity: 0;
      transform: translateY(30px);
      animation: controlsSlideIn 0.6s ease-out 0.9s forwards;
    }
    .controls-panel .controls-title {
      margin-bottom: 12px;
      color: var(--accent);
      font-size: 16px;
      text-align: center;
    }
    .controls-panel .control-row {
      display: flex;
      align-items: center;
      margin: 8px 0;
      padding: 6px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .controls-panel .control-row:last-child {
      border-bottom: none;
    }
    .controls-panel .control-keys {
      display: inline-flex;
      gap: 4px;
      min-width: 120px;
    }
    .controls-panel .control-desc {
      color: var(--fg);
      font-weight: 500;
    }
    .controls-panel kbd {
      background: linear-gradient(135deg, #2a3441, #1f2733);
      border: 1px solid rgba(90, 242, 199, 0.3);
      border-bottom: 2px solid rgba(90, 242, 199, 0.4);
      padding: 4px 8px;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
      font-weight: 600;
      color: var(--accent);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    .controls-panel .mobile-note {
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 12px;
      text-align: center;
      color: var(--muted);
    }
    .stat-value {
      margin-left: 4px;
    }
    #gameOver {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      display: none;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      padding: 20px 24px;
      border-radius: 12px;
      box-shadow: 0 12px 40px var(--shadow);
      text-align: center;
      line-height: 1.4;
      opacity: 0;
    }
    #gameOver h2 { margin: 0 0 8px 0; }
    #gameOver button {
      margin-top: 10px;
      background: var(--accent);
      color: #002e24;
      border: none;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    #gameOver button:hover {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 6px 16px rgba(90,242,199,0.4);
    }
    #gameOver button:active {
      transform: translateY(0px) scale(0.98);
    }
    #fps {
      position: fixed;
      bottom: 10px; right: 12px;
      font-size: 12px;
      color: var(--muted);
      background: #0f1319aa;
      padding: 4px 8px;
      border-radius: 6px;
      user-select: none;
    }
    #powerupNotification {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(180deg, rgba(18, 22, 29, 0.7), rgba(15, 19, 25, 0.7));
      border: 2px solid rgba(90, 242, 199, 0.7);
      padding: 24px 40px;
      border-radius: 12px;
      box-shadow: 0 8px 24px var(--shadow);
      font-size: 36px;
      font-weight: 700;
      text-align: center;
      color: var(--accent);
      text-shadow: 0 0 8px rgba(90,242,199,0.6);
      letter-spacing: 1px;
      display: none;
      z-index: 1000;
      animation: powerupPulse 3s ease-out forwards;
    }
    #waveAnnouncement {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: linear-gradient(135deg, rgba(18, 22, 29, 0.95), rgba(15, 19, 25, 0.95));
      border: 3px solid var(--accent);
      padding: 40px 60px;
      border-radius: 16px;
      box-shadow: 0 16px 48px rgba(0,0,0,0.8), 0 0 32px rgba(90,242,199,0.3);
      text-align: center;
      color: var(--accent);
      display: none;
      z-index: 1001;
      opacity: 0;
      backdrop-filter: blur(4px);
    }
    #waveAnnouncement .wave-number {
      font-size: 72px;
      font-weight: 900;
      text-shadow: 0 0 16px rgba(90,242,199,0.8);
      margin-bottom: 16px;
      letter-spacing: 2px;
    }
    #waveAnnouncement .wave-subtitle {
      font-size: 24px;
      font-weight: 600;
      color: var(--muted);
      text-shadow: 0 0 8px rgba(90,242,199,0.4);
      margin-top: 8px;
    }
    #waveAnnouncement.boss-wave {
      border-color: #ff4444;
      box-shadow: 0 16px 48px rgba(0,0,0,0.8), 0 0 32px rgba(255,68,68,0.4);
    }
    #waveAnnouncement.boss-wave .wave-number {
      color: #ff4444;
      text-shadow: 0 0 16px rgba(255,68,68,0.8);
    }
    #powerupDialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border: 3px solid var(--accent);
      padding: 24px 28px;
      border-radius: 16px;
      box-shadow: 0 16px 48px var(--shadow);
      display: none;
      z-index: 2000;
      max-width: 600px;
      text-align: center;
      opacity: 0;
    }
    #powerupDialog h2 {
      margin: 0 0 16px 0;
      color: var(--accent);
      font-size: 24px;
      text-shadow: 0 0 8px rgba(90,242,199,0.6);
    }
    .powerup-options {
      display: flex;
      gap: 16px;
      justify-content: center;
      margin-top: 20px;
    }
    .powerup-option {
      background: linear-gradient(180deg, #1a1f29, #0f1319);
      border: 2px solid #293140;
      border-radius: 12px;
      padding: 16px 12px;
      cursor: pointer;
      min-width: 160px;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      opacity: 0;
      transform: translateY(20px) scale(0.9);
    }
    .powerup-option.animate-in {
      opacity: 1;
      transform: translateY(0px) scale(1);
    }
    .powerup-option:hover {
      border-color: var(--accent);
      box-shadow: 0 8px 24px rgba(90,242,199,0.4);
      transform: translateY(-4px) scale(1.05);
    }
    .powerup-option:active {
      transform: translateY(-2px) scale(0.98);
    }
    .powerup-option.selected {
      animation: powerupSelected 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
      border-color: #FFD700;
      box-shadow: 0 8px 32px rgba(255, 215, 0, 0.6);
    }
    .powerup-option h3 {
      margin: 0 0 8px 0;
      color: var(--accent);
      font-size: 16px;
    }
    .powerup-option p {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.3;
    }
    @keyframes powerupPulse {
      0% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.5) rotate(-3deg); 
        filter: blur(6px);
      }
      8% { 
        opacity: 0.9; 
        transform: translateX(-50%) scale(1.2) rotate(1deg); 
        filter: blur(1px);
      }
      15% { 
        opacity: 1; 
        transform: translateX(-50%) scale(0.95) rotate(-0.5deg); 
        filter: blur(0px);
      }
      25% { 
        transform: translateX(-50%) scale(1.05) rotate(0deg); 
      }
      35% { 
        transform: translateX(-50%) scale(1) rotate(0deg); 
      }
      90% { 
        opacity: 1; 
        transform: translateX(-50%) scale(1) rotate(0deg); 
      }
      100% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.8) rotate(1deg); 
        filter: blur(3px);
      }
    }
    canvas { display: block; }
    .edge-warning {
      position: fixed;
      background: rgba(255, 91, 110, 0.5);
      pointer-events: none;
      z-index: 100;
      animation: edgePulse 0.5s ease-in-out infinite alternate;
    }
    .edge-warning.top { top: 0; left: 0; right: 0; height: 16px; }
    .edge-warning.bottom { bottom: 0; left: 0; right: 0; height: 16px; }
    .edge-warning.left { left: 0; top: 0; bottom: 0; width: 16px; }
    .edge-warning.right { right: 0; top: 0; bottom: 0; width: 16px; }
    @keyframes edgePulse {
      0% { opacity: 0.5; }
      100% { opacity: 0.5; }
    }
    
    /* Main Menu Animations */
    @keyframes menuFadeIn {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.8) rotate(-1deg); 
        filter: blur(8px); 
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1) rotate(0deg); 
        filter: blur(0px); 
      }
    }
    @keyframes titleSlideIn {
      0% { 
        opacity: 0; 
        transform: translateY(-20px); 
        filter: blur(4px); 
      }
      100% { 
        opacity: 1; 
        transform: translateY(0px); 
        filter: blur(0px); 
      }
    }
    @keyframes subtitleSlideIn {
      0% { 
        opacity: 0; 
        transform: translateY(-15px); 
        filter: blur(2px); 
      }
      100% { 
        opacity: 1; 
        transform: translateY(0px); 
        filter: blur(0px); 
      }
    }
    @keyframes buttonSlideIn {
      0% { 
        opacity: 0; 
        transform: translateY(20px) scale(0.9); 
        filter: blur(2px); 
      }
      100% { 
        opacity: 1; 
        transform: translateY(0px) scale(1); 
        filter: blur(0px); 
      }
    }
    @keyframes controlsSlideIn {
      0% { 
        opacity: 0; 
        transform: translateY(30px); 
        filter: blur(2px); 
      }
      100% { 
        opacity: 1; 
        transform: translateY(0px); 
        filter: blur(0px); 
      }
    }
    
    /* Pause Menu Animations */
    @keyframes pauseSlideIn {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.9); 
        filter: blur(6px); 
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
    }
    @keyframes pauseSlideOut {
      0% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(1.1); 
        filter: blur(4px); 
      }
    }
    
    /* Game Over Animations */
    @keyframes gameOverDramaticEntry {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.5) rotate(-5deg); 
        filter: blur(10px); 
      }
      50% { 
        opacity: 0.8; 
        transform: translate(-50%, -50%) scale(1.1) rotate(2deg); 
        filter: blur(2px); 
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1) rotate(0deg); 
        filter: blur(0px); 
      }
    }
    @keyframes gameOverSlideOut {
      0% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.8); 
        filter: blur(6px); 
      }
    }
    
    /* Game Start Transition */
    @keyframes gameStartFlash {
      0% { 
        background: radial-gradient(circle, rgba(90,242,199,0.3) 0%, transparent 50%);
        opacity: 1;
      }
      50% { 
        background: radial-gradient(circle, rgba(90,242,199,0.6) 0%, rgba(90,242,199,0.2) 30%, transparent 80%);
        opacity: 1;
      }
      100% { 
        background: radial-gradient(circle, transparent 0%, transparent 100%);
        opacity: 0;
      }
    }
    .game-start-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 999;
      opacity: 0;
    }
    
    /* Powerup Selection Animations */
    @keyframes powerupSelected {
      0% { 
        transform: translateY(-4px) scale(1.05);
      }
      20% { 
        transform: translateY(-12px) scale(1.15) rotate(2deg);
        filter: brightness(1.3);
      }
      50% { 
        transform: translateY(-8px) scale(1.2) rotate(-1deg);
        filter: brightness(1.5);
      }
      80% { 
        transform: translateY(-4px) scale(1.1) rotate(0deg);
        filter: brightness(1.2);
      }
      100% { 
        transform: translateY(-4px) scale(1.05);
        filter: brightness(1);
      }
    }
    
    @keyframes powerupDialogEntry {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.8); 
        filter: blur(6px); 
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
    }
    @keyframes powerupDialogExit {
      0% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(1.1); 
        filter: blur(4px); 
      }
    }
    
    /* Wave Card Animations */
    @keyframes waveCardEntry {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.3) rotate(-10deg);
        filter: blur(8px);
      }
      10% { 
        opacity: 0.7; 
        transform: translate(-50%, -50%) scale(1.3) rotate(3deg);
        filter: blur(2px);
      }
      25% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(0.9) rotate(-1deg);
        filter: blur(0px);
      }
      40% { 
        transform: translate(-50%, -50%) scale(1.1) rotate(0deg);
      }
      60% { 
        transform: translate(-50%, -50%) scale(0.95) rotate(0deg);
      }
      100% { 
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
      }
    }
    
    @keyframes waveCardExit {
      0% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1);
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(1.2);
        filter: blur(4px);
      }
    }
    
    /* Enhanced Wave Announcements */
    @keyframes waveDramaticEntry {
      0% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.3) rotateY(90deg); 
        filter: blur(10px);
      }
      30% { 
        opacity: 0.8; 
        transform: translateX(-50%) scale(1.3) rotateY(-10deg); 
        filter: blur(2px);
      }
      60% { 
        opacity: 1; 
        transform: translateX(-50%) scale(0.9) rotateY(5deg); 
        filter: blur(0px);
      }
      80% { 
        transform: translateX(-50%) scale(1.1) rotateY(-2deg); 
      }
      90% { 
        transform: translateX(-50%) scale(1) rotateY(0deg); 
      }
      95% { 
        opacity: 1; 
        transform: translateX(-50%) scale(1) rotateY(0deg); 
      }
      100% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.7) rotateY(-5deg); 
        filter: blur(4px);
      }
    }
    
    @keyframes bossWaveEntry {
      0% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.2); 
        filter: blur(15px) hue-rotate(0deg);
        background: linear-gradient(180deg, rgba(255, 0, 0, 0.9), rgba(139, 0, 0, 0.8));
      }
      15% { 
        opacity: 0.9; 
        transform: translateX(-50%) scale(1.5); 
        filter: blur(3px) hue-rotate(180deg);
      }
      30% { 
        opacity: 1; 
        transform: translateX(-50%) scale(0.8); 
        filter: blur(0px) hue-rotate(360deg);
      }
      50% { 
        transform: translateX(-50%) scale(1.2); 
      }
      70% { 
        transform: translateX(-50%) scale(1); 
      }
      90% { 
        opacity: 1; 
        transform: translateX(-50%) scale(1); 
      }
      100% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.5); 
        filter: blur(8px);
      }
    }

    /* Flashy Game Title Animations */
    .game-title {
      font-size: 48px !important;
      font-weight: 900;
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3);
      background-size: 400% 400%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(255, 107, 107, 0.5), 0 0 60px rgba(78, 205, 196, 0.3);
      animation: rainbowShift 3s ease-in-out infinite, titlePulse 2s ease-in-out infinite alternate;
      letter-spacing: 2px;
      margin-bottom: 8px !important;
    }

    @keyframes rainbowShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    @keyframes titlePulse {
      0% { 
        transform: translateY(-20px) scale(1);
        filter: drop-shadow(0 0 20px rgba(255, 107, 107, 0.6));
      }
      100% { 
        transform: translateY(-20px) scale(1.05);
        filter: drop-shadow(0 0 40px rgba(78, 205, 196, 0.8));
      }
    }

    .game-subtitle {
      font-size: 16px;
      color: #5af2c7;
      font-weight: 600;
      text-shadow: 0 0 10px rgba(90, 242, 199, 0.5);
      animation: subtitleGlow 2.5s ease-in-out infinite alternate;
      letter-spacing: 1px;
    }

    @keyframes subtitleGlow {
      0% { 
        opacity: 0.8;
        text-shadow: 0 0 10px rgba(90, 242, 199, 0.5);
      }
      100% { 
        opacity: 1;
        text-shadow: 0 0 20px rgba(90, 242, 199, 0.8), 0 0 30px rgba(90, 242, 199, 0.4);
      }
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="game-start-overlay" id="gameStartOverlay"></div>
  <div id="hud">
    <div class="row">Health
      <span class="bar health"><i id="healthBar" style="width:100%"></i></span>
      <span id="hpTxt">100</span>
    </div>
    <div class="row">Stamina
      <span class="bar stamina"><i id="staminaBar" style="width:100%"></i></span>
      <span id="staminaTxt">100</span>
    </div>
    <div class="row">Wave <span id="wave" class="stat-value">1</span> â€¢ Kills <span id="kills" class="stat-value">0</span></div>
  </div>
  <div id="banner">
    <h1 class="game-title">âš¡ CRYSTAL BLITZ âš¡</h1>
    <div class="game-subtitle">ðŸŒŠ SURVIVE THE ENDLESS WAVES ðŸŒŠ</div>
    <div class="controls-panel">
      <div class="controls-title"><strong>Controls</strong></div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd>
        </div>
        <div class="control-desc">Move around the arena</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>Mouse</kbd>
        </div>
        <div class="control-desc">Aim and shoot</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>Shift</kbd>
        </div>
        <div class="control-desc">Dash through enemies</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>Space</kbd>
        </div>
        <div class="control-desc">Emergency leap</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>P</kbd>
        </div>
        <div class="control-desc">Pause game</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>L</kbd>
        </div>
        <div class="control-desc">Crystal legend</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>F11</kbd>
        </div>
        <div class="control-desc">Toggle fullscreen</div>
      </div>
      <div class="mobile-note">Mobile: Touch left side to move, right side to aim/shoot</div>
    </div>
    <button id="startBtn">Start</button>
  </div>
  <div id="gameOver">
    <h2>Game Over</h2>
    <div>Wave <span id="goWave">1</span> â€¢ Kills <span id="goKills">0</span></div>
    <button id="restartBtn">Restart</button>
  </div>
  <div id="fps">FPS: â€”</div>
  <div id="powerupNotification"></div>
  <div id="waveAnnouncement">
    <div class="wave-number"></div>
    <div class="wave-subtitle"></div>
  </div>
  <div class="edge-warning top" id="edgeTop" style="display:none"></div>
  <div class="edge-warning bottom" id="edgeBottom" style="display:none"></div>
  <div class="edge-warning left" id="edgeLeft" style="display:none"></div>
  <div class="edge-warning right" id="edgeRight" style="display:none"></div>
  <div id="powerupDialog">
    <h2>Choose Your Upgrade</h2>
    <div class="powerup-options">
      <div class="powerup-option" id="powerupOption1">
        <h3 id="powerupTitle1">Title</h3>
        <p id="powerupDesc1">Description</p>
      </div>
      <div class="powerup-option" id="powerupOption2">
        <h3 id="powerupTitle2">Title</h3>
        <p id="powerupDesc2">Description</p>
      </div>
      <div class="powerup-option" id="powerupOption3">
        <h3 id="powerupTitle3">Title</h3>
        <p id="powerupDesc3">Description</p>
      </div>
    </div>
  </div>
  <div id="crystalLegend">
    <h3>Crystal Types</h3>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #00BFFF;"></div>
      <div class="crystal-name">Dual Shot</div>
      <div class="crystal-desc">Front & back bullets</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #32CD32;"></div>
      <div class="crystal-name">Triple Shot</div>
      <div class="crystal-desc">3-way spread</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #FF1493;"></div>
      <div class="crystal-name">Quad Shot</div>
      <div class="crystal-desc">4-way spread</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #FFD700;"></div>
      <div class="crystal-name">Homing</div>
      <div class="crystal-desc">Tracks enemies</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #FF4500;"></div>
      <div class="crystal-name">Explosive</div>
      <div class="crystal-desc">Area damage</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #FF69B4;"></div>
      <div class="crystal-name">Ricochet</div>
      <div class="crystal-desc">Bounces off walls</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #000080;"></div>
      <div class="crystal-name">Lightning</div>
      <div class="crystal-desc">Chains to enemies</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #00CED1;"></div>
      <div class="crystal-name">Freeze Shot</div>
      <div class="crystal-desc">Slows enemies</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #8b4513;"></div>
      <div class="crystal-name">Shotgun</div>
      <div class="crystal-desc">Spreads on hit</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #ffa500;"></div>
      <div class="crystal-name">Cluster</div>
      <div class="crystal-desc">Splits into fragments</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #dc143c;"></div>
      <div class="crystal-name">Seeking</div>
      <div class="crystal-desc">Curves to enemies</div>
    </div>
  </div>

  <script>
  'use strict';

  // ===== Canvas & Resize =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  
  // Offscreen canvas for static background grid (draw once, reuse forever)
  let bgCanvas = null;
  let bgCtx = null;
  let bgNeedsRedraw = true;
  
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    bgNeedsRedraw = true; // Redraw background on resize
  }
  window.addEventListener('resize', resize);
  resize();

  // ===== UI Elements =====
  // Helper function to get elements by ID
  const getElement = (id) => document.getElementById(id);

  // Single elements
  const startBtn = getElement('startBtn');
  const banner = getElement('banner');
  const hudHpBar = getElement('healthBar');
  const hudStaminaBar = getElement('staminaBar');
  const hpTxt = getElement('hpTxt');
  const staminaTxt = getElement('staminaTxt');
  const waveTxt = getElement('wave');
  const killsTxt = getElement('kills');
  const fpsTxt = getElement('fps');
  const gameOverPanel = getElement('gameOver');
  const goWave = getElement('goWave');
  const goKills = getElement('goKills');
  const gameStartOverlay = getElement('gameStartOverlay');
  const restartBtn = getElement('restartBtn');
  const powerupNotification = getElement('powerupNotification');
  const waveAnnouncement = getElement('waveAnnouncement');
  const powerupDialog = getElement('powerupDialog');
  const crystalLegend = getElement('crystalLegend');

  // Grouped elements (powerup options, titles, descriptions)
  const powerupOptions = [1, 2, 3].map(i => getElement(`powerupOption${i}`));
  const powerupTitles = [1, 2, 3].map(i => getElement(`powerupTitle${i}`));
  const powerupDescs = [1, 2, 3].map(i => getElement(`powerupDesc${i}`));
  const edgeWarnings = {
    top: getElement('edgeTop'),
    bottom: getElement('edgeBottom'),
    left: getElement('edgeLeft'),
    right: getElement('edgeRight')
  };

  // ===== Math Utils =====
  const TAU = Math.PI * 2;
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  function len2(x,y){ return x*x + y*y; }
  // Reusable vector objects to eliminate array allocations
  const vecPool = {
    temp1: {x: 0, y: 0},
    temp2: {x: 0, y: 0},
    temp3: {x: 0, y: 0},
    temp4: {x: 0, y: 0}
  };

  // Fast length calculation without fastLength()
  function fastLength(x, y) {
    return Math.sqrt(x * x + y * y) || 1;
  }

  // Old norm function - kept for compatibility where destructuring is needed
  function norm(x,y) {
    const L = fastLength(x,y); return [x/L, y/L];
  }

  // New optimized version that reuses objects (no allocations)
  function normInPlace(x, y, out) {
    const L = fastLength(x, y);
    out.x = x / L;
    out.y = y / L;
    return out;
  }
  function randRange(a,b){ return a + Math.random()*(b-a); }
  function sign(v){ return v < 0 ? -1 : 1; }

  // ===== Input =====
  const keys = new Set();
  let mouseX = 0, mouseY = 0, mouseDown = false;
  
  // Mobile touch support
  let touchMove = {x: 0, y: 0, active: false};
  let touchShoot = {x: 0, y: 0, active: false};
  window.addEventListener('keydown', e => {
    if (e.code === 'KeyP'){ togglePause(); return; }
    if (e.code === 'KeyL'){ 
      crystalLegend.style.display = crystalLegend.style.display === 'block' ? 'none' : 'block';
      return;
    }
    if (e.code === 'F11'){ 
      e.preventDefault();
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
      return; 
    }
    keys.add(e.code);
  });
  window.addEventListener('keyup', e => keys.delete(e.code));
  canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
  canvas.addEventListener('mousedown', () => { mouseDown = true; initAudio(); });
  window.addEventListener('mouseup', () => mouseDown = false);
  canvas.addEventListener('contextmenu', e => e.preventDefault());
  
  // Touch controls for mobile
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    initAudio();
    const touch = e.touches[0];
    if (touch.clientX < canvas.width / 2) {
      // Left side - movement
      touchMove.active = true;
      touchMove.x = touch.clientX;
      touchMove.y = touch.clientY;
    } else {
      // Right side - shooting/aiming
      touchShoot.active = true;
      touchShoot.x = touch.clientX;
      touchShoot.y = touch.clientY;
      mouseX = touch.clientX;
      mouseY = touch.clientY;
      mouseDown = true;
    }
  });
  
  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const touch = e.touches[0];
    if (touchMove.active && touch.clientX < canvas.width / 2) {
      touchMove.x = touch.clientX;
      touchMove.y = touch.clientY;
    } else if (touchShoot.active && touch.clientX >= canvas.width / 2) {
      touchShoot.x = touch.clientX;
      touchShoot.y = touch.clientY;
      mouseX = touch.clientX;
      mouseY = touch.clientY;
    }
  });
  
  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    touchMove.active = false;
    touchShoot.active = false;
    mouseDown = false;
  });

  // ===== Security & Utility Functions =====
  function sanitizeText(text) {
    if (typeof text !== 'string') return '';
    return text.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;');
  }

  function safeParseInt(value, defaultValue = 0) {
    const parsed = parseInt(value, 10);
    return isNaN(parsed) ? defaultValue : parsed;
  }

  function safeParseFloat(value, defaultValue = 0.0) {
    const parsed = parseFloat(value);
    return isNaN(parsed) ? defaultValue : parsed;
  }

  // ===== Performance Optimizations =====
  
  // Optimized trigonometric cache with numeric keys
  const sinCache = new Map();
  const cosCache = new Map();
  const TRIG_CACHE_SIZE = 1000;
  
  function fastSin(angle) {
    // Use numeric keys instead of string templates
    const key = Math.round(angle * 1000);
    if (!sinCache.has(key)) {
      if (sinCache.size > TRIG_CACHE_SIZE) {
        sinCache.clear(); // Clear cache when it gets too large
      }
      sinCache.set(key, Math.sin(key / 1000));
    }
    return sinCache.get(key);
  }
  
  function fastCos(angle) {
    const key = Math.round(angle * 1000);
    if (!cosCache.has(key)) {
      if (cosCache.size > TRIG_CACHE_SIZE) {
        cosCache.clear();
      }
      cosCache.set(key, Math.cos(key / 1000));
    }
    return cosCache.get(key);
  }
  
  // Fast distance comparison using squared distance
  function fastDistanceCheck(x1, y1, x2, y2, maxDist) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const distSq = dx * dx + dy * dy;
    return distSq <= maxDist * maxDist;
  }
  
  // Batch DOM updates to reduce reflows
  let domUpdateQueue = [];
  let domUpdateScheduled = false;
  
  function queueDOMUpdate(fn) {
    domUpdateQueue.push(fn);
    if (!domUpdateScheduled) {
      domUpdateScheduled = true;
      requestAnimationFrame(() => {
        for (const update of domUpdateQueue) {
          update();
        }
        domUpdateQueue = [];
        domUpdateScheduled = false;
      });
    }
  }
  
  // Rendering optimizations
  let lastFillStyle = '';
  let lastStrokeStyle = '';
  let lastGlobalAlpha = 1;
  let lastLineWidth = 1;
  
  function setFillStyle(style) {
    if (lastFillStyle !== style) {
      ctx.fillStyle = style;
      lastFillStyle = style;
    }
  }
  
  function setStrokeStyle(style) {
    if (lastStrokeStyle !== style) {
      ctx.strokeStyle = style;
      lastStrokeStyle = style;
    }
  }
  
  function setGlobalAlpha(alpha) {
    if (lastGlobalAlpha !== alpha) {
      ctx.globalAlpha = alpha;
      lastGlobalAlpha = alpha;
    }
  }
  
  function setLineWidth(width) {
    if (lastLineWidth !== width) {
      ctx.lineWidth = width;
      lastLineWidth = width;
    }
  }
  
  function resetRenderState() {
    lastFillStyle = '';
    lastStrokeStyle = '';
    lastGlobalAlpha = 1;
    lastLineWidth = 1;
  }
  
  // Performance monitoring and adaptive quality
  let frameTimeHistory = [];
  let performanceLevel = 1.0; // 1.0 = full quality, 0.5 = reduced quality
  
  function updatePerformanceLevel(frameTime) {
    frameTimeHistory.push(frameTime);
    if (frameTimeHistory.length > 10) {
      frameTimeHistory.shift();
      const avgFrameTime = frameTimeHistory.reduce((a, b) => a + b) / frameTimeHistory.length;
      const targetFrameTime = 16.67; // 60 FPS
      
      if (avgFrameTime > targetFrameTime * 1.5) {
        performanceLevel = Math.max(0.3, performanceLevel - 0.1);
      } else if (avgFrameTime < targetFrameTime * 1.1) {
        performanceLevel = Math.min(1.0, performanceLevel + 0.05);
      }
    }
  }
  
  function shouldSpawnParticle() {
    return Math.random() < performanceLevel;
  }
  
  // Helper to avoid duplicate game over code
  function triggerGameOver(g) {
    g.state = STATE.OVER;
    goWave.textContent = g.wave.toString();
    goKills.textContent = g.kills.toString();
    gameOverPanel.style.display = 'block';
    gameOverPanel.style.animation = 'gameOverDramaticEntry 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
  }
  
  // Generate upgrades display for pause menu
  function createUpgradesDisplay() {
    if (!game || !game.player) return '';
    
    const upgrades = [];
    const player = game.player;
    
    // Check static powerup upgrades
    for (const [upgradeId, count] of player.upgradeCounts) {
      const powerup = staticPowerups.find(p => p.id === upgradeId);
      if (powerup && count > 0) {
        const stackText = count > 1 ? ` (Ã—${count})` : '';
        upgrades.push(`${powerup.name}${stackText}`);
      }
    }
    
    // Check temporary effects
    if (player.activeEffects && player.activeEffects.size > 0) {
      for (const [effect, shots] of player.activeEffects) {
        if (shots > 0) {
          const effectName = effect.charAt(0).toUpperCase() + effect.slice(1);
          upgrades.push(`${effectName} (${shots} shots)`);
        }
      }
    }
    
    // Check pattern multipliers  
    if (player.patternMultipliers && player.patternMultipliers.size > 0) {
      for (const [pattern, shots] of player.patternMultipliers) {
        if (shots > 0) {
          const patternName = pattern.charAt(0).toUpperCase() + pattern.slice(1);
          upgrades.push(`${patternName} Pattern (${shots} shots)`);
        }
      }
    }
    
    // Check legacy upgrades
    if (player.upgradeShots > 0) {
      upgrades.push(`Dual Shot (${player.upgradeShots} shots)`);
    }
    
    return upgrades.length > 0 ? upgrades : ['No upgrades acquired'];
  }

  // ===== Audio (procedural, no assets) =====
  let audioCtx = null;
  function initAudio(){
    try {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // resume on iOS Safari
        audioCtx.resume && audioCtx.resume();
      }
    } catch (audioError) {
      console.error('Audio initialization failed:', audioError);
      // Game can continue without audio
    }
  }
  function beep(freq=440, duration=0.05, type='square', gain=0.02){
    if (!audioCtx) return;
    try {
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      g.gain.value = gain;
      osc.connect(g).connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      osc.start(now);
      osc.stop(now + duration);
    } catch (beepError) {
      console.error('Audio beep error:', beepError);
      // Silently fail for audio errors
    }
  }
  function shootSound(){ beep(680, 0.04, 'square', 0.1); }
  function hitSound(){ beep(220, 0.07, 'sawtooth', 0.15); }
  function criticalHitSound(){ beep(400, 0.05, 'triangle', 0.18); }
  function staminaDepletedSound(){ 
    beep(300, 0.06, 'triangle', 0.12); 
    setTimeout(() => beep(280, 0.06, 'triangle', 0.10), 100); // Second pulse after 100ms
  }
  function hurtSound(){ beep(120, 0.1, 'sine', 0.2); }
  function waveSound(){ beep(440, 0.12, 'triangle', 0.1); }
  function enemyDeathSound(enemy) {
    // Different death sounds based on enemy type and size
    const baseFreq = enemy.r > 20 ? 60 :   // Super bosses - very deep
                     enemy.r > 16 ? 90 :   // Large enemies (tanks, bosses) - deep
                     enemy.r < 12 ? 200 :  // Small enemies (fast, zerglings) - high  
                     160;                  // Normal enemies - medium
    
    const variation = (Math.random() - 0.5) * 30; // Â±15 Hz variation for more character
    const freq = baseFreq + variation;
    const duration = enemy.r > 16 ? 0.18 : enemy.r < 12 ? 0.06 : 0.1; // Size-based duration
    const volume = Math.min(0.15, 0.08 + enemy.r * 0.003); // Volume scales with size
    
    beep(freq, duration, 'sawtooth', volume);
  }

  // ===== Static Powerups =====
  const staticPowerups = [
    {id: 'speedBoost', name: 'Speed Boost', desc: '+12.5% movement speed', apply: (p) => p.speed *= 1.125},
    {id: 'healthRegen', name: 'Health Regen', desc: '+0.5 HP/sec regeneration', apply: (p) => p.healthRegenRate = (p.healthRegenRate || 0) + 0.5},
    {id: 'maxHealth', name: 'Max Health', desc: '+30 maximum health', apply: (p) => { p.maxHp += 30; p.hp = Math.min(p.hp + 30, p.maxHp); }},
    {id: 'staminaBoost', name: 'Stamina Boost', desc: '+25% stamina regeneration', apply: (p) => p.staminaRegen *= 1.25},
    {id: 'rapidFire', name: 'Rapid Fire', desc: '12.5% faster shooting', apply: (p) => p.fireDelay *= 0.875},
    {id: 'bulletSize', name: 'Bullet Size', desc: '25% larger bullets', apply: (p) => p.bulletSize = 1.25},
    {id: 'bulletSpeed', name: 'Bullet Speed', desc: '25% faster bullets', apply: (p) => p.bulletSpeed = 1.25},
    {id: 'piercingShot', name: 'Piercing Shot', desc: '+1 bullet piercing', apply: (p) => p.piercingCount = (p.piercingCount || 0) + 1},
    {id: 'shield', name: 'Shield', desc: '+25% damage reduction', apply: (p) => p.damageReduction = Math.min(0.9, p.damageReduction + 0.25)},
    {id: 'knockbackImmune', name: 'Knockback Resistance', desc: '+50% knockback reduction', apply: (p) => p.knockbackResistance = (p.knockbackResistance || 0) + 0.5},
    {id: 'magneticCrystals', name: 'Magnetic Crystals', desc: '+80px attraction range', apply: (p) => p.magneticRange = (p.magneticRange || 0) + 80},
    {id: 'lucky', name: 'Lucky', desc: '+20% crystal drop rate', apply: (p) => p.luckyBonus = (p.luckyBonus || 0) + 0.20},
    {id: 'dashCooldown', name: 'Dash Cooldown', desc: '-15% dash cooldown', apply: (p) => p.dashCooldownReduction = (p.dashCooldownReduction || 0) + 0.15},
    {id: 'criticalChance', name: 'Critical Strike', desc: '+10% critical hit chance', apply: (p) => p.criticalChance = Math.min(0.5, (p.criticalChance || 0) + 0.1)},
    {id: 'vampire', name: 'Vampire', desc: '+0.5 HP per enemy killed', apply: (p) => p.vampiricHealing = (p.vampiricHealing || 0) + 0.5},
    {id: 'adrenaline', name: 'Adrenaline', desc: '+20% speed for 3s after damage', apply: (p) => p.adrenalineBoost = true},
    {id: 'efficient', name: 'Efficient', desc: '+5% chance shots don\'t consume ammo', apply: (p) => p.ammoEfficiency = Math.min(0.50, (p.ammoEfficiency || 0) + 0.05)}
  ];

  // ===== Powerup Notification =====
  function showPowerupNotification(powerupName) {
    powerupNotification.textContent = powerupName.toUpperCase();
    powerupNotification.style.display = 'block';
    powerupNotification.style.animation = 'none';
    
    // Choose animation based on content type
    let animationName = 'powerupPulse';
    let duration = 3000;
    
    if (powerupName.includes('BOSS')) {
      animationName = 'bossWaveEntry';
      duration = 4000;
    } else if (powerupName.includes('WAVE')) {
      animationName = 'waveDramaticEntry';
      duration = 3500;
    }
    
    // Force reflow to restart animation
    powerupNotification.offsetHeight;
    powerupNotification.style.animation = `${animationName} ${duration/1000}s cubic-bezier(0.34, 1.56, 0.64, 1) forwards`;
    
    // Hide after animation completes
    setTimeout(() => {
      powerupNotification.style.display = 'none';
    }, duration);
  }

  // ===== Wave Announcement =====
  let waveAnnouncementTimeouts = [];
  
  function showWaveAnnouncement(waveNumber, isBossWave = false) {
    console.log(`showWaveAnnouncement called: Wave ${waveNumber}, Boss: ${isBossWave}, Existing timeouts: ${waveAnnouncementTimeouts.length}`);
    // Clear any existing timeouts to prevent overlapping animations
    waveAnnouncementTimeouts.forEach(timeout => clearTimeout(timeout));
    waveAnnouncementTimeouts = [];
    
    const waveNumberEl = waveAnnouncement.querySelector('.wave-number');
    const subtitleEl = waveAnnouncement.querySelector('.wave-subtitle');
    
    waveNumberEl.textContent = `WAVE ${waveNumber}`;
    subtitleEl.textContent = isBossWave ? 'SUPER BOSS INCOMING!' : 'GET READY';
    
    // Apply boss wave styling
    if (isBossWave) {
      waveAnnouncement.classList.add('boss-wave');
    } else {
      waveAnnouncement.classList.remove('boss-wave');
    }
    
    // Reset any existing animation and show with dramatic entry animation
    waveAnnouncement.style.animation = 'none';
    waveAnnouncement.style.display = 'block';
    // Force reflow before applying new animation
    waveAnnouncement.offsetHeight;
    waveAnnouncement.style.animation = 'waveCardEntry 1.2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
    
    // Hide after showing
    const hideTimeout = setTimeout(() => {
      waveAnnouncement.style.animation = 'waveCardExit 0.4s ease-out forwards';
      const removeTimeout = setTimeout(() => {
        waveAnnouncement.style.display = 'none';
      }, 400);
      waveAnnouncementTimeouts.push(removeTimeout);
    }, 2500);
    waveAnnouncementTimeouts.push(hideTimeout);
  }

  // ===== Powerup Selection =====
  function showPowerupDialog() {
    // Pause game for powerup selection (different from manual pause)
    if (game && game.state === STATE.RUN) {
      game.state = STATE.POWERUP;
    }
    
    // Immediately hide all potential overlapping UI elements to prevent flash
    waveAnnouncementTimeouts.forEach(timeout => clearTimeout(timeout));
    waveAnnouncementTimeouts = [];
    waveAnnouncement.style.animation = 'none';
    waveAnnouncement.style.display = 'none';
    
    // Also ensure game start overlay is hidden
    gameStartOverlay.style.animation = 'none';
    gameStartOverlay.style.opacity = '0';
    
    // Hide powerup notification if it's showing
    powerupNotification.style.animation = 'none';
    powerupNotification.style.display = 'none';
    
    // Filter out maxed upgrades
    const p = game.player;
    const availablePowerups = staticPowerups.filter(powerup => {
      // Shield maxed at 90%
      if (powerup.id === 'shield' && (p.damageReduction || 0) >= 0.9) {
        return false;
      }
      // Knockback resistance maxed at 100%
      if (powerup.id === 'knockbackImmune' && (p.knockbackResistance || 0) >= 1.0) {
        return false;
      }
      // Critical chance maxed at 50%
      if (powerup.id === 'criticalChance' && (p.criticalChance || 0) >= 0.5) {
        return false;
      }
      // Ammo efficiency maxed at 50% (15 stacks of 5% - reasonable cap)
      if (powerup.id === 'efficient' && (p.ammoEfficiency || 0) >= 0.50) {
        return false;
      }
      return true;
    });
    
    // Select 3 unique random powerups (no duplicates in same selection)
    const selected = [];
    const availableIndices = [...Array(availablePowerups.length).keys()]; // [0,1,2,3,4,...]
    
    while (selected.length < 3 && availableIndices.length > 0) {
      const randomIndex = Math.floor(Math.random() * availableIndices.length);
      const powerupIndex = availableIndices.splice(randomIndex, 1)[0];
      selected.push(availablePowerups[powerupIndex]);
    }
    
    // Populate dialog
    // Update powerup options using arrays
    selected.forEach((powerup, i) => {
      powerupTitles[i].textContent = powerup?.name || 'None';
      powerupDescs[i].textContent = powerup?.desc || 'No more powerups';
    });
    
    // Small delay to ensure all other UI is hidden before showing dialog
    setTimeout(() => {
      powerupDialog.style.display = 'block';
      powerupDialog.style.animation = 'powerupDialogEntry 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
      
      // Animate in powerup options with staggered delays
      const powerupOptions = powerupDialog.querySelectorAll('.powerup-option');
      powerupOptions.forEach((option, index) => {
        option.classList.remove('animate-in');
        setTimeout(() => {
          option.classList.add('animate-in');
        }, 200 + index * 100);
      });
    }, 50); // 50ms delay to ensure UI cleanup
    
    // Add click handlers
    const handleChoice = (choice) => {
      const powerup = selected[choice];
      if (powerup) {
        // Add selection animation to clicked option
        const selectedOption = powerupOptions[choice];
        selectedOption.classList.add('selected');
        
        // Apply powerup (stackable)
        powerup.apply(game.player);
        
        // Track upgrade count for pause menu display
        const currentCount = game.player.upgradeCounts.get(powerup.id) || 0;
        game.player.upgradeCounts.set(powerup.id, currentCount + 1);
        
        // Delay dialog close to show selection animation
        setTimeout(() => {
          // Hide dialog with animation and resume game
          powerupDialog.style.animation = 'powerupDialogExit 0.3s ease-out forwards';
          setTimeout(() => {
            powerupDialog.style.display = 'none';
            selectedOption.classList.remove('selected');
            if (game && game.state === STATE.POWERUP) {
              game.state = STATE.RUN;
            }
            // Show notification after dialog is fully closed
            showPowerupNotification(powerup.name);
          }, 300);
        }, 200);
      }
    };
    
    // Set up click handlers using array
    powerupOptions.forEach((option, i) => {
      option.onclick = () => handleChoice(i);
    });
  }

  // ===== Random Seeded? (not needed here) =====

  // ===== Game State =====
  const STATE = { MENU:0, RUN:1, PAUSE:2, OVER:3, POWERUP:4 };
  let game = null;
  function newGame(){
    return {
      state: STATE.MENU,
      width: () => canvas.width,
      height: () => canvas.height,
      t: 0,
      wave: 1,
      kills: 0,
      player: makePlayer(canvas.width/2, canvas.height/2),
      spawnTimer: 0,
      waveActive: false, // Wave in progress
      waveEnemiesSpawned: 0, // Enemies spawned this wave
      waveEnemiesTarget: 15, // Total enemies for current wave
      waveBossesSpawned: 0, // Bosses spawned this wave
      waveBossesTarget: 0, // Target bosses for this wave
      maxEnemies: 30, // Base cap, dynamically scaled
      grid: makeSpatialHash(64),
      difficulty: 1,
      paused: false,
      fpsSamples: [],
      fpsSum: 0, // Running sum for efficient FPS calculation
      invulTime: 0,
      damageFlash: 0, // Red vignette flash timer
    };
  }

  // ===== Spatial Hash (for enemy lookup) =====
  function makeSpatialHash(cell){
    return {
      cell: cell,
      map: new Map(),
      key(ix,iy){ return (ix << 16) | (iy & 0xFFFF); }, // Numeric key instead of string
      reset(){ this.map.clear(); },
      insert(e){
        const ix = (e.x / this.cell) | 0;
        const iy = (e.y / this.cell) | 0;
        const k = this.key(ix,iy);
        let arr = this.map.get(k);
        if (!arr){ arr = []; this.map.set(k, arr); }
        arr.push(e);
        e._cellX = ix; e._cellY = iy;
      },
      near(x,y){
        const ix = (x / this.cell) | 0;
        const iy = (y / this.cell) | 0;
        const out = [];
        for (let dx = -1; dx <= 1; dx++){
          for (let dy = -1; dy <= 1; dy++){
            const k = this.key(ix+dx, iy+dy);
            const arr = this.map.get(k);
            if (arr) out.push(...arr);
          }
        }
        return out;
      }
    };
  }

  // ===== Object Pools =====
  function makePool(createFn, initial=0){
    const items = [];
    for (let i=0;i<initial;i++) items.push(createFn());
    return {
      items,
      spawn(initFn){
        for (let i=0;i<items.length;i++){
          const it = items[i];
          if (!it.alive){
            initFn(it); it.alive = true; return it;
          }
        }
        const it = createFn();
        initFn(it); it.alive = true;
        items.push(it);
        return it;
      }
    };
  }

  // ===== Entities =====
  function makePlayer(x,y){
    return {
      x, y,
      vx:0, vy:0,
      speed: 260,
      radius: 12,
      color: '#00ff00',
      hp: 100,
      maxHp: 100,
      stamina: 100,
      exhausted: 0, // Exhaustion cooldown timer
      ammo: Infinity,
      upgradeShots: 0, // V-formation upgrade shots remaining
      bulletType: 'normal', // Legacy - kept for compatibility 
      bulletTimer: 0, // Legacy - kept for compatibility
      bulletPattern: 'single', // Legacy - kept for compatibility
      patternTimer: 0, // Legacy - kept for compatibility
      // New modular effects system
      activeEffects: new Map(), // Map of effect type -> remaining shots
      // New multiplicative pattern system
      patternMultipliers: new Map(), // Map of pattern type -> remaining shots
      fireDelay: 0.12,
      fireTimer: 0,
      dashCd: 0, dashReady: true,
      // Emergency leap system
      leapCd: 0, leapReady: true,
      leapDistance: 120, // Distance of leap
      leapSpeed: 1200, // Speed during leap
      // Static powerups
      staticPowerups: [],
      // Upgrade tracking for pause menu display
      upgradeCounts: new Map(),
      healthRegen: false,
      staminaRegen: 1.0,
      bulletSize: 1.0,
      bulletSpeed: 1.0,
      piercingShot: false,
      damageReduction: 0,
      knockbackImmune: false,
      magneticCrystals: false,
      lucky: false,
      healthRegenTimer: 0,
    };
  }

  const bullets = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, r:4, life:0, maxLife: 1.0, 
    type:'normal', pierces:0, bounces:0, homingTarget:null, 
    hitEnemies: new Set(),
    effectSet: new Set() // O(1) effect lookups instead of O(n) array.includes()
  }));

  const enemies = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, r:14, hp:2, speed: 90, touchDmg: 12, color:'#ff5b6e',
    deathTimer: 0, dying: false, originalColor: '#ff5b6e'
  }));

  const particles = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, life:0, maxLife:0.3, size:2, color:'#ffffff'
  }));

  const pickups = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, type:'upgrade', bounceTimer:0, collected:false
  }));

  const bloodStains = makePool(() => ({
    alive:false, x:0, y:0, life:0, maxLife:15.0, size:2, alpha:1.0, vx:0, vy:0, settled:false
  }));

  const enemyBullets = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, r:3, life:0, maxLife:3.0
  }));

  const mines = makePool(() => ({
    alive:false, x:0, y:0, r:8, fuseTime:0, maxFuseTime:30.0, isArmed:false,
    triggerRadius:35, explosionRadius:70, explosionDamage:20, flashTimer:0, 
    isTriggered:false, owner:null
  }));

  // Bullet powerup types
  const bulletPowerups = [
    {type: 'upgrade', color: '#00BFFF', shots: 50, name: 'Dual Shot'},
    {type: 'triple', color: '#32CD32', shots: 50, name: 'Triple Shot'},
    {type: 'quad', color: '#FF1493', shots: 50, name: 'Quad Shot'},
    {type: 'homing', color: '#FFD700', shots: 25, name: 'Homing'},
    {type: 'explosive', color: '#FF4500', shots: 50, name: 'Explosive'},
    {type: 'ricochet', color: '#FF69B4', shots: 50, name: 'Ricochet'},
    {type: 'lightning', color: '#000080', shots: 50, name: 'Lightning'},
    {type: 'freeze', color: '#00CED1', shots: 50, name: 'Freeze Shot'},
    {type: 'shotgun', color: '#8B4513', shots: 50, name: 'Shrapnel'},
    {type: 'cluster', color: '#FFA500', shots: 50, name: 'Cluster'},
    {type: 'seeking', color: '#DC143C', shots: 50, name: 'Seeking'}
  ];

  // Create O(1) lookup map to replace O(n) Array.find() calls
  const bulletPowerupMap = new Map();
  for (const powerup of bulletPowerups) {
    bulletPowerupMap.set(powerup.type, powerup);
  }

  // Pre-compute filtered arrays to eliminate O(n) filter operations
  const nonHomingPowerups = bulletPowerups.filter(bp => bp.type !== 'homing');
  const nonHomingLength = nonHomingPowerups.length;

  // Enemy types for variety
  const enemyTypes = [
    {r:14, hp:1, speed:90, dmg:9, color:'#ff4444', name:'normal'}, // red
    {r:10, hp:1, speed:140, dmg:9, color:'#ffaa00', name:'fast'}, // orange
    {r:18, hp:3, speed:60, dmg:12, color:'#ff6600', name:'tank'}, // dark orange
    {r:12, hp:2, speed:200, dmg:9, color:'#cccc00', name:'zergling'}, // dark yellow rushers
  ];

  // Behavior pools - unlock new behaviors every 2 waves (earlier unlocks for fun)
  const behaviorPools = [
    // Waves 1-2: Basic behaviors with suicide crawlers
    ['normal', 'zigzag', 'zerglingRush', 'suicide'],
    // Waves 3-4: Add flanking and charging early
    ['normal', 'zigzag', 'flank', 'charge', 'zerglingRush', 'suicide', 'slowpush', 'splitter', 'minelayer'],
    // Waves 5-6: Add erratic behavior earlier
    ['normal', 'zigzag', 'flank', 'charge', 'erratic', 'zerglingRush', 'suicide', 'slowpush', 'spiralshooter', 'splitter', 'minelayer'],
    // Waves 7+: All behaviors (no more zerglings)
    ['normal', 'zigzag', 'flank', 'charge', 'erratic', 'suicide', 'slowpush', 'spiralshooter', 'splitter', 'minelayer']
  ];

  function spawnEnemy(g){
    const w = g.width(), h = g.height();
    const margin = 20;
    // spawn at edges
    const side = (Math.random() * 4) | 0; // Faster than Math.floor
    let x=0,y=0;
    if (side===0){ x=randRange(margin, w-margin); y=-margin; }
    else if (side===1){ x=randRange(margin, w-margin); y=h+margin; }
    else if (side===2){ x=-margin; y=randRange(margin, h-margin); }
    else { x=w+margin; y=randRange(margin, h-margin); }
    enemies.spawn(e => {
      e.x = x; e.y = y;
      e.vx = 0; e.vy = 0;
      
      // Select enemy type based on wave with zergling replacement logic
      let type;
      if (g.wave <= 12 && Math.random() < 0.4) {
        // 40% chance for zerglings in waves 1-12
        type = enemyTypes.find(t => t.name === 'zergling');
      } else {
        // Normal enemy type selection (excluding zerglings for waves 13+)
        const baseTypes = g.wave <= 12 ? 
          enemyTypes.filter(t => t.name !== 'zergling') : // Exclude zerglings from normal pool in waves 1-12
          enemyTypes.filter(t => t.name !== 'zergling');  // No zerglings after wave 12
        const availableTypes = Math.min(baseTypes.length, 1 + Math.floor(g.wave/3));
        type = baseTypes[(Math.random() * availableTypes) | 0];
      }
      
      // Apply type stats with difficulty scaling
      const diff = 1 + g.wave * 0.12;
      e.r = type.r;
      e.hp = Math.ceil(type.hp * diff);
      e.speed = type.speed * diff * (0.85 + Math.random() * 0.3); // Â±15% speed variance
      e.touchDmg = Math.ceil(type.dmg * diff);
      // Add slight color variation within red-orange-yellow spectrum
      const colorVariations = {
        '#ff4444': ['#ff3333', '#ff5555', '#ff4444', '#ff6666'],
        '#ffaa00': ['#ff9900', '#ffbb00', '#ffaa00', '#ffcc00'],
        '#ff6600': ['#ff5500', '#ff7700', '#ff6600', '#ff8800'],
        '#cccc00': ['#cccc00', '#dddd00', '#bbbb00', '#aaaa00'] // dark yellow variations
      };
      const baseColor = type.color;
      const variations = colorVariations[baseColor] || [baseColor];
      e.color = variations[(Math.random() * variations.length) | 0]; // Faster than Math.floor
      e.originalColor = e.color;
      e.deathTimer = 0;
      e.dying = false;
      
      // Initialize shooter properties
      e.isShooter = false;
      e.shootTimer = 0;
      
      // Boss spawning logic - limited per wave
      if (g.wave % 10 === 0 && g.waveBossesSpawned < g.waveBossesTarget) {
        // Super boss spawn (limited quantity per wave)
        e.r *= 4; e.hp *= 4; e.touchDmg *= 2;
        e.color = '#800080'; e.originalColor = '#800080'; e.behavior = 'superboss';
        e.phaseTimer = 0; // Timer for behavior changes
        e.currentPhase = 0; // Current movement phase
        g.waveBossesSpawned++;
      } else if (g.wave % 5 === 0 && g.wave % 10 !== 0 && Math.random() < 0.1) {
        // Mini-boss every 5 waves (10% chance)
        e.r *= 1.5; e.hp *= 2.5; e.touchDmg *= 1.5;
        e.color = '#cc0000'; e.originalColor = '#cc0000'; e.behavior = 'boss';
      } else {
        // Check if this is a slow enemy (90 speed or less) that becomes a shooter (20% chance)
        if (type.speed <= 90 && Math.random() < 0.20) {
          e.isShooter = true;
          e.shootTimer = Math.random() * 2.0; // Random initial delay
          
          // Determine shooter pattern based on wave and chance
          const rand = Math.random();
          if (g.wave >= 3 && rand < 0.3) {
            e.shootPattern = 'spread';
            e.color = '#bb3300'; e.originalColor = '#bb3300'; // Red-orange for spread
          } else if (g.wave >= 5 && rand < 0.6) {
            e.shootPattern = 'burst';
            e.burstCount = 0; // Track bursts in sequence
            e.color = '#990000'; e.originalColor = '#990000'; // Dark red for burst
          } else {
            e.shootPattern = 'single';
            e.color = '#aa4400'; e.originalColor = '#aa4400'; // Brown for single
          }
        }
        
        // Select behavior from available pool based on current wave
        const poolIndex = Math.min(Math.floor((g.wave - 1) / 2), behaviorPools.length - 1);
        const availableBehaviors = behaviorPools[poolIndex];
        e.behavior = availableBehaviors[(Math.random() * availableBehaviors.length) | 0];
      }
      
      // Set special colors and stats for specific behaviors
      if (e.behavior === 'suicide') {
        e.color = '#8844ff'; // Purple for suicide crawlers
        e.originalColor = '#8844ff';
        // Speed cap for suicide crawlers to prevent crazy speeds
        e.speed = Math.min(e.speed, 180 + g.wave * 10); // Wave 6 = 240 max
      } else if (e.behavior === 'slowpush') {
        // Make them extra tanky and slow
        e.hp = Math.ceil(e.hp * 1.8); // 80% more HP
        e.speed *= 0.7; // 30% slower
        e.touchDmg = Math.ceil(e.touchDmg * 1.3); // 30% more damage
        e.color = '#666666'; // Dark gray for tanks
        e.originalColor = '#666666';
        e.knockbackStrength = 250; // Knockback force
        
        // Shield system
        const baseShieldHP = 15;
        const diff = 1 + g.wave * 0.12; // Same scaling as enemy HP
        e.shieldHP = Math.ceil(baseShieldHP * diff);
        e.maxShieldHP = e.shieldHP;
        e.hasShield = true;
        
        // Shield direction tracking (90% speed for counterplay)
        e.shieldDirection = { x: 1, y: 0 }; // Initial direction
      } else if (e.behavior === 'spiralshooter') {
        // Make them distinctive and slower
        e.speed *= 0.8; // 20% slower for spiral shooters
        e.color = '#ff8800'; // Bright orange for spiral shooters
        e.originalColor = '#ff8800';
      } else if (e.behavior === 'charge') {
        // Speed cap for dash zombies to prevent crazy dash speeds
        e.speed = Math.min(e.speed, 150 + g.wave * 8); // Wave 5 = 190 max
        e.color = '#ffcc00'; // Yellow for charge enemies
        e.originalColor = '#ffcc00';
      } else if (e.behavior === 'splitter') {
        // Make them slightly tankier and distinctive
        e.hp = Math.ceil(e.hp * 1.3); // 30% more HP
        e.r = Math.ceil(e.r * 1.1); // 10% bigger
        e.color = '#cc44cc'; // Purple-magenta for splitters
        e.originalColor = '#cc44cc';
      } else if (e.behavior === 'minelayer') {
        // Make them slower and distinctive
        e.speed *= 0.8; // 20% slower (plus 30% in behavior = 44% total reduction)
        e.color = '#996633'; // Brown for mine layers
        e.originalColor = '#996633';
      }
      
      e.alive = true;
    });
  }

  // Calculate bullet count and directions from active pattern multipliers
  // Handle enemy death and crystal drops consistently
  function handleEnemyDeath(enemy, game) {
    if (enemy.hp <= 0 && !enemy.dying) {
      // Start death animation instead of immediate removal
      enemy.dying = true;
      enemy.deathTimer = 0.2; // 0.2 second death animation
      
      // Enemy death sound based on type/size
      enemyDeathSound(enemy);
      
      // Large blood burst on death
      spawnBlood(enemy.x, enemy.y, 0, 0, 'death');
      
      // Suicide crawler explosion - bigger and more dramatic
      if (enemy.behavior === 'suicide') {
        // Extra explosion sound
        beep(80, 0.2, 'sawtooth', 0.15); // Deep explosion boom
        
        // Large explosion particles
        const explosionParticles = 25;
        for (let i = 0; i < explosionParticles; i++) {
          particles.spawn(p => {
            const angle = (i / explosionParticles) * TAU + Math.random() * 0.4;
            const speed = randRange(200, 450); // Faster particles
            p.x = enemy.x; p.y = enemy.y;
            p.vx = fastCos(angle) * speed;
            p.vy = fastSin(angle) * speed;
            p.life = 0; p.maxLife = randRange(0.6, 1.2); // Longer lasting
            p.size = randRange(4, 9); // Bigger particles
            p.color = '#ff4400'; // Orange explosion color
            p.hasGravity = false;
            p.alive = true;
          });
        }
        
        // Damage player if close enough (explosion radius)
        const explosionRadius = 45;
        const distToPlayer = fastLength(enemy.x - game.player.x, enemy.y - game.player.y);
        if (distToPlayer <= explosionRadius) {
          game.player.hp -= 15; // Explosion damage
          beep(500, 0.1, 'square', 0.1); // Player hurt sound
          
          // Add screen shake effect (if available)
          if (game.screenShake !== undefined) {
            game.screenShake = Math.max(game.screenShake || 0, 0.3);
          }
        }
      }
      
      // Splitter zombie - spawns 2-3 smaller enemies on death
      if (enemy.behavior === 'splitter') {
        const childCount = 2 + Math.floor(Math.random() * 2); // 2-3 children
        const spreadAngle = TAU; // Full circle spread
        
        for (let i = 0; i < childCount; i++) {
          const angle = (i / childCount) * spreadAngle + Math.random() * 0.5; // Even spread with variance
          const distance = randRange(20, 40); // Spawn distance from parent
          
          // Spawn child enemy using existing spawn system
          enemies.spawn(child => {
            child.x = enemy.x + fastCos(angle) * distance;
            child.y = enemy.y + fastSin(angle) * distance;
            child.vx = fastCos(angle) * randRange(50, 100); // Initial velocity away from parent
            child.vy = fastSin(angle) * randRange(50, 100);
            
            // Child stats - smaller and weaker than parent
            child.r = Math.max(6, enemy.r * 0.6); // 60% size, minimum 6 radius
            child.hp = Math.max(1, Math.floor(enemy.hp * 0.4)); // 40% HP, minimum 1
            child.speed = enemy.speed * 1.2; // 20% faster
            child.touchDmg = Math.max(1, Math.floor(enemy.touchDmg * 0.7)); // 70% damage
            child.color = '#ff66ff'; // Pink for child splitters
            child.originalColor = '#ff66ff';
            child.behavior = 'normal'; // Children use normal behavior
            child.deathTimer = 0;
            child.dying = false;
            child.alive = true;
            
            // Clamp to screen bounds
            child.x = clamp(child.x, child.r, game.width() - child.r);
            child.y = clamp(child.y, child.r, game.height() - child.r);
          });
        }
        
        beep(250, 0.08, 'sawtooth', 0.10); // Splitting sound
      }
      
      // Enemy pop/burst effect - satisfying explosion
      const popParticles = enemy.behavior === 'suicide' ? 20 : 15; // More particles for suicide
      for (let i = 0; i < popParticles; i++) {
        particles.spawn(p => {
          const angle = (i / popParticles) * TAU + Math.random() * 0.3; // Even spread with variance
          const speed = randRange(150, 300);
          p.x = enemy.x; p.y = enemy.y;
          p.vx = fastCos(angle) * speed;
          p.vy = fastSin(angle) * speed;
          p.life = 0; p.maxLife = randRange(0.4, 0.8);
          p.size = randRange(3, 6);
          p.color = enemy.originalColor; // Match enemy color
          p.hasGravity = false; // Pure radial burst
          p.alive = true;
        });
      }
      
      // Create realistic blood spray stains
      const numStains = randRange(15, 25);
      for (let i = 0; i < numStains; i++) {
        bloodStains.spawn(stain => {
          // Spray pattern - blood lands in burst around death point
          const angle = Math.random() * TAU;
          const distance = randRange(5, 35);
          stain.x = enemy.x + Math.cos(angle) * distance;
          stain.y = enemy.y + Math.sin(angle) * distance;
          
          // Initial movement (blood droplets still traveling)
          stain.vx = Math.cos(angle) * randRange(20, 80);
          stain.vy = Math.sin(angle) * randRange(20, 80);
          
          stain.life = 0;
          stain.maxLife = 15.0;
          stain.size = randRange(1, 4); // Smaller individual droplets
          stain.alpha = 1.0;
          stain.settled = false;
          stain.alive = true;
        });
      }
      
      // Crystal drop logic - bosses get special treatment
      const p = game.player;
      if (enemy.behavior === 'boss' || enemy.behavior === 'superboss') {
        // Bosses: 15% chance to drop homing crystal
        if (Math.random() < 0.15) {
          spawnBossPickup(enemy.x, enemy.y);
        }
      } else {
        // Regular enemies: 3% chance to drop any crystal (+20% per lucky upgrade)
        const baseRate = 0.03;
        const luckyMultiplier = 1 + (p.luckyBonus || 0);
        const dropRate = baseRate * luckyMultiplier;
        const roll = Math.random();
        if (roll < dropRate) {
          spawnBulletPickup(enemy.x, enemy.y);
        }
      }
      
      game.kills++;
      
      // Vampiric healing
      const player = game.player;
      if (player && player.vampiricHealing) {
        player.hp = Math.min(player.maxHp, player.hp + player.vampiricHealing);
      }
      
      // Check if wave is complete (half of enemies killed)
      const aliveEnemies = enemies.items.filter(e => e.alive && !e.dying).length;
      const enemiesKilledThisWave = game.waveEnemiesSpawned - aliveEnemies;
      if (game.waveActive && enemiesKilledThisWave >= Math.floor(game.waveEnemiesTarget * 0.5)) {
        // Wave complete! Start next wave after brief delay
        game.waveActive = false;
        setTimeout(() => {
          game.wave++;
          game.waveEnemiesSpawned = 0;
          game.waveBossesSpawned = 0;
          // Proper enemy scaling: Wave 1=15, Wave 10=30, Wave 50=60, Wave 100=90
          // Using a square root-based scaling for gradual increase
          if (game.wave <= 50) {
            // From wave 1-50: 15 to 60 enemies
            // Formula: 15 + 45 * sqrt((wave-1)/49)
            const progress = (game.wave - 1) / 49; // 0 to 1
            game.waveEnemiesTarget = Math.floor(15 + 45 * Math.sqrt(progress));
          } else {
            // From wave 51-100: 60 to 90 enemies
            // Formula: 60 + 30 * ((wave-50)/50)
            const progress = Math.min(1, (game.wave - 50) / 50); // 0 to 1, capped
            game.waveEnemiesTarget = Math.floor(60 + 30 * progress);
          }
          // Set boss target for this wave
          if (game.wave % 10 === 0) {
            game.waveBossesTarget = Math.floor(game.wave / 10); // 1 boss on round 10, 2 on round 20, etc.
          } else {
            game.waveBossesTarget = 0;
          }
          waveSound();
          if (game.wave % 10 === 0) {
            showWaveAnnouncement(game.wave, true);
          } else {
            showWaveAnnouncement(game.wave, false);
          }
          game.waveActive = true;
          
          // Spawn all enemies within 2-4 seconds
          const spawnDuration = 2000 + Math.random() * 2000; // 2-4 seconds
          const spawnInterval = spawnDuration / game.waveEnemiesTarget;
          
          for (let i = 0; i < game.waveEnemiesTarget; i++) {
            setTimeout(() => {
              if (game.waveActive) {
                spawnEnemy(game);
                game.waveEnemiesSpawned++;
              }
            }, i * spawnInterval);
          }
        }, 3000); // 3 second breathing room between waves (allows previous wave card to fully disappear)
      }
      
      // Powerup selection - accelerating progression: 10, 25, 50, 100, then formula-based
      if (!game.level) game.level = 0;
      if (!game.nextLevelup) game.nextLevelup = 10; // First level at 10 kills
      
      if (game.kills >= game.nextLevelup) {
        showPowerupDialog();
        game.level++;
        
        // Calculate kills needed for next level
        let killsForNextLevel;
        if (game.level === 1) {
          killsForNextLevel = 25; // Level 2 needs 25 more
        } else if (game.level === 2) {
          killsForNextLevel = 50; // Level 3 needs 50 more
        } else if (game.level === 3) {
          killsForNextLevel = 100; // Level 4 needs 100 more
        } else {
          // Level 5+: 50 + 50 Ã— (level - 4)
          // Level 5 = 50 + 50Ã—1 = 100, Level 6 = 50 + 50Ã—2 = 150, etc.
          killsForNextLevel = 50 + 50 * (game.level - 3);
        }
        
        game.nextLevelup += killsForNextLevel;
      }
    }
  }

  // Calculate bullet count and directions from active pattern multipliers
  function calculateBulletPattern(player) {
    let totalBullets = 1; // Base single bullet
    
    // Apply all pattern multipliers
    for (const [pattern, shots] of player.patternMultipliers) {
      if (shots > 0) {
        if (pattern === 'triple') totalBullets *= 3;
        else if (pattern === 'quad') totalBullets *= 4;
      }
    }
    
    // Cap at 16 bullets maximum
    totalBullets = Math.min(totalBullets, 16);
    
    // Get mouse direction as the center of the pattern
    const [baseDx, baseDy] = norm(mouseX - player.x, mouseY - player.y);
    const baseAngle = Math.atan2(baseDy, baseDx);
    
    // Calculate evenly spaced angles CENTERED on mouse direction
    const directions = [];
    if (totalBullets === 1) {
      // Single bullet - use mouse direction exactly
      directions.push({dx: baseDx, dy: baseDy});
    } else {
      // Multiple bullets - one ALWAYS points to mouse, others evenly spaced around it
      const angleStep = TAU / totalBullets;
      
      for (let i = 0; i < totalBullets; i++) {
        const angle = baseAngle + (angleStep * i);
        const dx = fastCos(angle);
        const dy = fastSin(angle);
        directions.push({dx, dy});
      }
      
      // First bullet always goes exactly toward mouse
      directions[0] = {dx: baseDx, dy: baseDy};
    }
    
    return {totalBullets, directions};
  }

  function spawnBullet(x,y,dirX,dirY,effects=[]){
    const baseSpeed = 720;
    const player = game?.player;
    const speed = baseSpeed * (player?.bulletSpeed || 1.0);
    const size = 4 * (player?.bulletSize || 1.0);
    
    // Critical hit calculation
    const critChance = player?.criticalChance || 0;
    const isCritical = Math.random() < critChance;
    
    bullets.spawn(b => {
      b.x = x; b.y = y;
      b.vx = dirX * speed;
      b.vy = dirY * speed;
      b.r = size;
      b.life = 0;
      
      // Convert effects array to Set for O(1) lookups (vs O(n) includes())
      b.effectSet.clear();
      for (let i = 0, len = effects.length; i < len; i++) {
        b.effectSet.add(effects[i]); // Faster loop without for-of iterator
      }
      
      b.maxLife = b.effectSet.has('ricochet') ? 4.0 : 2.0;
      b.type = effects.length > 0 ? effects[0] : 'normal'; // Legacy compatibility
      b.effects = effects; // Direct reference instead of spread operator (no new array)
      b.pierces = (player?.piercingCount || 0);
      b.bounces = b.effectSet.has('ricochet') ? 3 : 0;
      b.homingTarget = null;
      b.hitEnemies.clear(); // Reset hit enemies for this bullet
      b.critical = isCritical;
      b.alive = true;
    });
  }


  function spawnEnemyBullet(x, y, targetX, targetY, angleOffset = 0, speedMult = 1.0) {
    const baseAngle = Math.atan2(targetY - y, targetX - x) + angleOffset;
    const dx = fastCos(baseAngle), dy = fastSin(baseAngle);
    const speed = Math.min(350, 200 + game.wave) * speedMult; // 200 base + 1 per wave, capped at 350
    
    enemyBullets.spawn(b => {
      b.x = x;
      b.y = y;
      b.vx = dx * speed;
      b.vy = dy * speed;
      b.r = 3;
      b.life = 0;
      b.maxLife = 3.0;
      b.alive = true;
    });
  }

  // Enhanced shooter patterns
  function spawnEnemyBurstFire(x, y, targetX, targetY, burstCount = 3) {
    for (let i = 0; i < burstCount; i++) {
      spawnEnemyBullet(x, y, targetX, targetY);
    }
  }

  function spawnEnemySpreadShot(x, y, targetX, targetY, bulletCount = 3, spreadAngle = Math.PI/4) {
    const halfSpread = spreadAngle / 2;
    for (let i = 0; i < bulletCount; i++) {
      const angleOffset = bulletCount === 1 ? 0 : 
        -halfSpread + (i / (bulletCount - 1)) * spreadAngle;
      spawnEnemyBullet(x, y, targetX, targetY, angleOffset);
    }
  }

  function spawnBulletPickup(x, y){
    pickups.spawn(p => {
      p.x = x; p.y = y;
      p.vx = (Math.random() - 0.5) * 100;
      p.vy = -Math.random() * 150 - 50;
      // Weighted crystal selection - homing is 0.5% chance
      let selectedPowerup;
      if (Math.random() < 0.005) { // 0.5% chance for homing
        selectedPowerup = bulletPowerupMap.get('homing');
      } else {
        // Choose from pre-computed non-homing crystals (avoid O(n) filter)
        selectedPowerup = nonHomingPowerups[(Math.random() * nonHomingLength) | 0];
      }
      p.type = selectedPowerup.type;
      p.bounceTimer = 0;
      p.collected = false;
      p.alive = true;
    });
  }

  function spawnBossPickup(x, y){
    pickups.spawn(p => {
      p.x = x; p.y = y;
      p.vx = (Math.random() - 0.5) * 100;
      p.vy = -Math.random() * 150 - 50;
      // Boss always drops homing crystal
      const homingPowerup = bulletPowerupMap.get('homing');
      p.type = homingPowerup.type;
      p.bounceTimer = 0;
      p.collected = false;
      p.alive = true;
    });
  }

  function spawnBurst(x,y, n=10, color='#ffffff'){
    const adaptiveN = (n * performanceLevel) | 0; // Bit operation faster than Math.floor
    for (let i=0;i<adaptiveN;i++){
      if (shouldSpawnParticle()) {
        particles.spawn(p => {
          const a = Math.random()*TAU;
          const s = 40 + Math.random() * 120; // Inline randRange for speed
          p.x = x; p.y = y;
          p.vx = fastCos(a)*s;
          p.vy = fastSin(a)*s;
          p.life = 0; 
          // Longer lifespan for explosions (optimized color check)
          const isExplosion = color === '#ff8000' || color === '#ff4000' || color === '#ffff00';
          p.maxLife = isExplosion ? 
                      0.8 + Math.random() * 0.4 : 0.2 + Math.random() * 0.3;
          p.size = isExplosion ? 
                   2 + Math.random() * 4 : 1.5 + Math.random() * 2;
          p.color = color;
          p.hasGravity = false;
          p.alive = true;
        });
      }
    }
  }

  function spawnBlood(x, y, dirX=0, dirY=0, type='impact'){
    const bloodColors = ['#ff0000', '#cc0000', '#800000', '#990000'];
    
    if (type === 'impact') {
      // Small blood spray from bullet impact
      for (let i=0; i<8; i++){
        particles.spawn(p => {
          const spread = 0.6;
          const baseAngle = dirX !== 0 || dirY !== 0 ? Math.atan2(dirY, dirX) : Math.random() * TAU;
          const angle = baseAngle + (Math.random()-0.5)*spread;
          const speed = 80 + Math.random() * 100; // Inline for speed
          p.x = x; p.y = y;
          p.vx = fastCos(angle) * speed;
          p.vy = fastSin(angle) * speed;
          p.life = 0; p.maxLife = 0.3 + Math.random() * 0.5; // Inline randRange
          p.size = 1 + Math.random() * 2; // Inline randRange
          p.color = bloodColors[(Math.random() * bloodColors.length) | 0];
          p.hasGravity = true;
          p.alive = true;
        });
      }
    } else if (type === 'death') {
      // Large blood burst when enemy dies
      for (let i=0; i<20; i++){
        particles.spawn(p => {
          const angle = Math.random() * TAU;
          const speed = 60 + Math.random() * 190; // Inline randRange
          p.x = x; p.y = y;
          p.vx = fastCos(angle) * speed;
          p.vy = fastSin(angle) * speed;
          p.life = 0; p.maxLife = 0.8 + Math.random() * 0.7; // Inline randRange
          p.size = 2 + Math.random() * 4; // Inline randRange
          p.color = bloodColors[(Math.random() * bloodColors.length) | 0];
          p.hasGravity = true;
          p.alive = true;
        });
      }
    } else if (type === 'player') {
      // Player damage - red particles flying outward
      for (let i=0; i<15; i++){
        particles.spawn(p => {
          const angle = Math.random() * TAU;
          const speed = 100 + Math.random() * 100; // Inline randRange
          p.x = x; p.y = y;
          p.vx = fastCos(angle) * speed;
          p.vy = fastSin(angle) * speed;
          p.life = 0; p.maxLife = 0.4 + Math.random() * 0.3; // Inline randRange
          p.size = 2 + Math.random() * 2; // Inline randRange
          p.color = '#ff0000';
          p.hasGravity = true;
          p.alive = true;
        });
      }
    }
  }

  // ===== Update & Draw =====
  function update(g, dt){
    g.t += dt;
    if (g.invulTime > 0) g.invulTime -= dt;
    if (g.damageFlash > 0) g.damageFlash -= dt;

    // Static powerup effects
    const p = g.player;
    if (p.healthRegenRate > 0) {
      p.healthRegenTimer = (p.healthRegenTimer || 0) - dt;
      if (p.healthRegenTimer <= 0) {
        p.hp = Math.min(p.hp + p.healthRegenRate, p.maxHp);
        p.healthRegenTimer = 1.0; // Check every second
      }
    }

    // Input -> movement (keyboard + touch)
    let ax=0, ay=0;
    if (keys.has('KeyW')) ay -= 1;
    if (keys.has('KeyS')) ay += 1;
    if (keys.has('KeyA')) ax -= 1;
    if (keys.has('KeyD')) ax += 1;
    
    // Touch movement (left side of screen)
    if (touchMove.active) {
      const centerX = canvas.width / 4; // Center of left half
      const centerY = canvas.height / 2;
      const deadZone = 30; // Minimum touch distance to register movement
      const touchDx = touchMove.x - centerX;
      const touchDy = touchMove.y - centerY;
      const touchDist = fastLength(touchDx, touchDy);
      
      if (touchDist > deadZone) {
        ax += touchDx / 100; // Convert to movement direction
        ay += touchDy / 100;
      }
    }
    
    // Exhaustion cooldown
    if (p.exhausted > 0) p.exhausted -= dt;
    
    // Adrenaline timer countdown
    if (p.adrenalineTimer > 0) p.adrenalineTimer -= dt;
    
    // Leap cooldown
    if (p.leapCd > 0) {
      p.leapCd -= dt;
      if (p.leapCd <= 0) p.leapReady = true;
    }
    
    // Emergency leap (Space key)
    if (keys.has('Space') && p.leapReady && (ax || ay)) {
      const [leapX, leapY] = norm(ax, ay);
      p.vx += leapX * p.leapSpeed;
      p.vy += leapY * p.leapSpeed;
      p.leapCd = 3.0; // 3 second cooldown
      p.leapReady = false;
      beep(400, 0.08, 'triangle', 0.03); // Leap sound effect
    }
    
    // Stamina system
    const wantsToSprint = keys.has('ShiftLeft') || keys.has('ShiftRight');
    const canSprint = p.stamina > 0 && p.exhausted <= 0;
    const isSprinting = wantsToSprint && canSprint && (ax || ay);
    
    if (isSprinting) {
      // Drain stamina: 20% per second (100% in 5 seconds)
      const oldStamina = p.stamina;
      p.stamina = Math.max(0, p.stamina - 20 * dt);
      
      // If stamina just hit 0, trigger exhaustion
      if (oldStamina > 0 && p.stamina <= 0) {
        const baseExhaustion = 2.0; // 2 second cooldown
        const reduction = p.dashCooldownReduction || 0;
        p.exhausted = baseExhaustion * (1 - reduction);
        staminaDepletedSound(); // Play unique 2-pulse sound
      }
    } else {
      // Regenerate stamina: 12.5% per second (0% to 100% in 8 seconds) + stamina boost
      p.stamina = Math.min(100, p.stamina + 12.5 * dt * p.staminaRegen);
    }
    
    if (ax || ay){
      const [nx,ny] = norm(ax,ay);
      const waveSpeedBonus = g.wave * 0.2; // +0.2 speed per wave
      const adrenalineBonus = (p.adrenalineTimer > 0) ? 1.2 : 1.0; // +20% speed during adrenaline
      const baseSpeed = (p.speed + waveSpeedBonus) * adrenalineBonus;
      const speed = isSprinting ? baseSpeed*1.6 : baseSpeed;
      p.vx += nx * speed * dt * 4;
      p.vy += ny * speed * dt * 4;
    }
    // friction
    p.vx *= (1 - 6*dt);
    p.vy *= (1 - 6*dt);
    // integrate
    p.x = clamp(p.x + p.vx*dt, p.radius, g.width()-p.radius);
    p.y = clamp(p.y + p.vy*dt, p.radius, g.height()-p.radius);

    // shooting
    if (p.fireTimer > 0) p.fireTimer -= dt;
    if (mouseDown && p.fireTimer <= 0){
      const [dx,dy] = norm(mouseX - p.x, mouseY - p.y);
      
      // Gather all active effects (new modular system)
      const activeEffects = [];
      for (const [effect, shots] of p.activeEffects) {
        if (shots > 0) activeEffects.push(effect);
      }
      
      // Calculate bullet pattern (multiplicative system)
      const {totalBullets, directions} = calculateBulletPattern(p);
      const hasUpgrade = p.upgradeShots > 0;
      
      // New unified shooting system - handle all patterns/upgrades
      if (hasUpgrade && totalBullets === 1) {
        // Special case: Front + Back shot with single bullet
        const {dx, dy} = directions[0]; // Use the single calculated direction
        spawnBullet(p.x + dx*p.radius*1.1, p.y + dy*p.radius*1.1, dx, dy, activeEffects); // Front
        spawnBullet(p.x - dx*p.radius*1.1, p.y - dy*p.radius*1.1, -dx, -dy, activeEffects); // Back
        // Check for ammo efficiency (chance to not consume ammo)
        const efficiencyChance = p.ammoEfficiency || 0;
        if (Math.random() >= efficiencyChance) {
          p.upgradeShots--;
        }
      } else if (hasUpgrade && totalBullets > 1) {
        // V-formation applied to each bullet direction (double the bullets)
        const vAngle = 0.15; // Smaller angle for multi-bullet spread
        const cs1 = Math.cos(vAngle), sn1 = Math.sin(vAngle);
        const cs2 = Math.cos(-vAngle), sn2 = Math.sin(-vAngle);
        
        for (const {dx, dy} of directions) {
          const sx1 = dx*cs1 - dy*sn1, sy1 = dx*sn1 + dy*cs1;
          const sx2 = dx*cs2 - dy*sn2, sy2 = dx*sn2 + dy*cs2;
          spawnBullet(p.x + sx1*p.radius*1.1, p.y + sy1*p.radius*1.1, sx1, sy1, activeEffects);
          spawnBullet(p.x + sx2*p.radius*1.1, p.y + sy2*p.radius*1.1, sx2, sy2, activeEffects);
        }
        // Check for ammo efficiency (chance to not consume ammo)
        const efficiencyChance = p.ammoEfficiency || 0;
        if (Math.random() >= efficiencyChance) {
          p.upgradeShots--;
        }
      } else {
        // Normal pattern shooting - spawn bullet for each direction
        for (const {dx, dy} of directions) {
          if (totalBullets === 1) {
            // Single bullet - add slight spread when sprinting
            const spread = (keys.has('ShiftLeft')||keys.has('ShiftRight')) ? 0.08 : 0.02;
            const s = (Math.random()-0.5)*spread;
            const cs = Math.cos(s), sn = Math.sin(s);
            const sx = dx*cs - dy*sn, sy = dx*sn + dy*cs;
            spawnBullet(p.x + sx*p.radius*1.1, p.y + sy*p.radius*1.1, sx, sy, activeEffects);
          } else {
            // Multiple bullets - no spread, perfect circle
            spawnBullet(p.x + dx*p.radius*1.1, p.y + dy*p.radius*1.1, dx, dy, activeEffects);
          }
        }
      }
      
      // Decrement all active effects and pattern multipliers after shooting
      // Check for ammo efficiency (chance to not consume ammo)
      const efficiencyChance = p.ammoEfficiency || 0;
      if (Math.random() >= efficiencyChance) {
        for (const [effect, shots] of p.activeEffects) {
          if (shots > 0) p.activeEffects.set(effect, shots - 1);
        }
        for (const [pattern, shots] of p.patternMultipliers) {
          if (shots > 0) p.patternMultipliers.set(pattern, shots - 1);
        }
      }
      
      p.fireTimer = p.fireDelay;
      shootSound();
    }

    // Enemy spawning now handled by setTimeout in wave completion logic
    // (All enemies spawn within 2-4 seconds at wave start)

    // Build spatial grid of enemies
    g.grid.reset();
    
    // Check for enemies near screen edges
    let nearTop = false, nearBottom = false, nearLeft = false, nearRight = false;
    const edgeThreshold = 100;
    
    // Cache expensive calculations
    const gameWidth = g.width();
    const gameHeight = g.height();
    const rightEdge = gameWidth - edgeThreshold;
    const bottomEdge = gameHeight - edgeThreshold;
    
    for (const e of enemies.items){
      if (!e.alive) continue;
      
      // Handle death animation
      if (e.dying) {
        e.deathTimer -= dt;
        // Death animation: white flash â†’ red flash â†’ fade
        const progress = 1 - (e.deathTimer / 0.2);
        if (progress < 0.3) {
          e.color = '#ffffff'; // White flash
        } else if (progress < 0.7) {
          e.color = '#ff0000'; // Red flash
        } else {
          e.color = e.originalColor; // Fade back to original
        }
        
        if (e.deathTimer <= 0) {
          e.alive = false; // Actually remove enemy
          continue;
        }
        // Don't do normal movement/behavior during death animation
        g.grid.insert(e);
        continue;
      }
      
      // Update critical hit flash timer
      if (e.critFlashTimer > 0) {
        e.critFlashTimer -= dt;
      }
      
      // Check edge proximity (using cached values)
      if (e.y < edgeThreshold) nearTop = true;
      if (e.y > bottomEdge) nearBottom = true;
      if (e.x < edgeThreshold) nearLeft = true;
      if (e.x > rightEdge) nearRight = true;
      
      // Handle freeze effect
      if (e.frozen > 0) e.frozen -= dt;
      const freezeMultiplier = e.frozen > 0 ? 0.5 : 1.0; // 50% speed when frozen
      
      // Apply behavior-specific movement (replaces old generic movement)
      const dirVec = normInPlace(p.x - e.x, p.y - e.y, vecPool.temp1);
      const dx = dirVec.x, dy = dirVec.y;
      
      // Add human-like walking cadence to all enemies
      if (!e.cadence) e.cadence = Math.random() * TAU; // Random starting phase
      e.cadence += dt * 4; // Walking rhythm frequency
      const walkRhythm = 0.8 + 0.2 * fastSin(e.cadence); // 0.6 to 1.0 speed multiplier
      
      if (e.behavior === 'normal') {
        // Improved gait-like movement toward player
        const gaitPattern = 0.7 + 0.4 * fastSin(e.cadence) + 0.1 * fastSin(e.cadence * 2); // More realistic gait
        const stepSway = fastSin(e.cadence + Math.PI/4) * 8; // Slight left-right sway while walking
        const perpX = -dy; // Perpendicular to movement direction
        const perpY = dx;
        
        e.vx += dx * e.speed * dt * 2.6 * gaitPattern * freezeMultiplier; // Increased 30% from 2.0 to 2.6
        e.vy += dy * e.speed * dt * 2.6 * gaitPattern * freezeMultiplier;
        e.vx += perpX * stepSway * dt * freezeMultiplier; // Add subtle sway
        e.vy += perpY * stepSway * dt * freezeMultiplier;
      } else if (e.behavior === 'zigzag') {
        // Zigzag movement with player attraction and cadence
        e.vx += dx * e.speed * dt * 1.2 * walkRhythm * freezeMultiplier;
        e.vy += dy * e.speed * dt * 1.2 * walkRhythm * freezeMultiplier;
        e.vx += fastSin(g.t * 8 + e.x * 0.01) * 120 * dt * freezeMultiplier;
        e.vy += fastCos(g.t * 6 + e.y * 0.01) * 100 * dt * freezeMultiplier;
      } else if (e.behavior === 'flank') {
        // Try to approach from sides/behind player
        const playerAngle = Math.atan2(p.y - e.y, p.x - e.x);
        const flankAngle = playerAngle + fastSin(g.t * 2 + e.x * 0.005) * Math.PI/3;
        const fx = fastCos(flankAngle);
        const fy = fastSin(flankAngle);
        e.vx += fx * e.speed * dt * 1.3 * walkRhythm * freezeMultiplier;
        e.vy += fy * e.speed * dt * 1.3 * walkRhythm * freezeMultiplier;
        // Still some direct attraction
        e.vx += dx * e.speed * dt * 0.3 * freezeMultiplier;
        e.vy += dy * e.speed * dt * 0.3 * freezeMultiplier;
      } else if (e.behavior === 'charge') {
        // Enhanced dash zombie with telegraph system
        if (!e.dashState) e.dashState = 'prowling';
        if (!e.dashTimer) e.dashTimer = 2 + Math.random() * 3;
        
        e.dashTimer -= dt;
        
        if (e.dashState === 'prowling') {
          // Prowl around player between dashes
          e.vx += dx * e.speed * dt * 1.2 * walkRhythm * freezeMultiplier;
          e.vy += dy * e.speed * dt * 1.2 * walkRhythm * freezeMultiplier;
          
          if (e.dashTimer <= 0) {
            // Start telegraph phase
            e.dashState = 'telegraph';
            e.dashTimer = 1.0; // 1 second telegraph
            e.originalColor = e.color;
            e.dashDirection = { x: dx, y: dy }; // Lock dash direction
            beep(400, 0.1, 'triangle', 0.08); // Telegraph warning sound
          }
        } else if (e.dashState === 'telegraph') {
          // Flash bright white during telegraph and slow down
          e.color = Math.sin(g.t * 12) > 0 ? '#ffffff' : e.originalColor;
          
          // Move very slowly during telegraph
          e.vx += dx * e.speed * dt * 0.2 * freezeMultiplier;
          e.vy += dy * e.speed * dt * 0.2 * freezeMultiplier;
          
          if (e.dashTimer <= 0) {
            // Start dash
            e.dashState = 'dashing';
            e.dashTimer = 0.4; // Short dash duration
            e.color = '#ffff00'; // Bright yellow while dashing
            beep(600, 0.05, 'sawtooth', 0.12); // Dash sound
          }
        } else if (e.dashState === 'dashing') {
          // Fast linear dash in locked direction
          const dashSpeed = e.speed * 3; // Reduced from 6x to 3x speed
          e.vx += e.dashDirection.x * dashSpeed * dt * 8;
          e.vy += e.dashDirection.y * dashSpeed * dt * 8;
          
          if (e.dashTimer <= 0) {
            // Return to prowling
            e.dashState = 'prowling';
            e.dashTimer = 3 + Math.random() * 2; // 3-5 second cooldown
            e.color = e.originalColor; // Restore original color
          }
        }
      } else if (e.behavior === 'erratic') {
        // Chaotic movement with some player attraction and subtle cadence
        const panicRhythm = 0.5 + 0.5 * Math.sin(e.cadence * 2); // Faster, more panicked rhythm
        e.vx += (Math.random() - 0.5) * 300 * dt * panicRhythm;
        e.vy += (Math.random() - 0.5) * 300 * dt * panicRhythm;
        e.vx += dx * e.speed * 1.0 * dt;
        e.vy += dy * e.speed * 1.0 * dt;
      } else if (e.behavior === 'superboss') {
        // Super boss with changing movement phases every 20 seconds
        e.phaseTimer = (e.phaseTimer || 0) + dt;
        if (e.phaseTimer >= 20) {
          e.phaseTimer = 0;
          e.currentPhase = (e.currentPhase + 1) % 4; // Cycle through 4 phases
        }
        
        const phase = e.currentPhase || 0;
        const heavyStep = 0.8 + 0.4 * Math.sin(e.cadence * 0.3); // Powerful rhythm
        
        if (phase === 0) {
          // Phase 0: Relentless pursuit - direct aggressive chase
          e.vx += dx * e.speed * dt * 2.0 * heavyStep;
          e.vy += dy * e.speed * dt * 2.0 * heavyStep;
        } else if (phase === 1) {
          // Phase 1: Circling predator - orbits around player
          const orbitSpeed = 1.8;
          const perpDx = -dy; // Perpendicular to player direction  
          const perpDy = dx;
          e.vx += (dx * 0.8 + perpDx * orbitSpeed) * e.speed * dt * heavyStep;
          e.vy += (dy * 0.8 + perpDy * orbitSpeed) * e.speed * dt * heavyStep;
        } else if (phase === 2) {
          // Phase 2: Erratic berserker - unpredictable bursts
          const chaos = 0.7 + 0.6 * Math.sin(e.cadence * 4); // Chaotic rhythm
          e.vx += ((Math.random() - 0.5) * 400 + dx * 150) * dt * chaos;
          e.vy += ((Math.random() - 0.5) * 400 + dy * 150) * dt * chaos;
        } else {
          // Phase 3: Charging bull - periodic devastating rushes
          if (!e.rushPhase) e.rushPhase = { timer: 0, charging: false };
          e.rushPhase.timer += dt;
          
          if (!e.rushPhase.charging && e.rushPhase.timer >= 2) {
            e.rushPhase.charging = true;
            e.rushPhase.timer = 0;
            e.rushDirection = { x: dx, y: dy }; // Lock rush direction
          }
          
          if (e.rushPhase.charging) {
            if (e.rushPhase.timer < 1.5) {
              // Charging for 1.5 seconds
              const rushPower = 3.0 + Math.sin(e.rushPhase.timer * 8) * 0.5;
              e.vx += e.rushDirection.x * e.speed * dt * rushPower;
              e.vy += e.rushDirection.y * e.speed * dt * rushPower;
            } else {
              // Reset for next cycle
              e.rushPhase.charging = false;
              e.rushPhase.timer = 0;
            }
          } else {
            // Slow stalking between charges
            e.vx += dx * e.speed * dt * 0.3 * heavyStep;
            e.vy += dy * e.speed * dt * 0.3 * heavyStep;
          }
        }
      } else if (e.behavior === 'boss') {
        // Boss moves deliberately with heavy footsteps
        const heavyStep = 0.9 + 0.2 * Math.sin(e.cadence * 0.5); // Still rhythmic but faster
        e.vx += dx * e.speed * dt * 1.2 * heavyStep;
        e.vy += dy * e.speed * dt * 1.2 * heavyStep;
      } else if (e.behavior === 'zerglingRush') {
        // Zergling rush behavior - quick leap attacks like player emergency dash
        if (!e.rushTimer) e.rushTimer = Math.random() * 1.5 + 0.5; // Initial delay
        e.rushTimer -= dt;
        
        if (e.rushTimer <= 0) {
          // Perform rush leap toward player
          const rushSpeed = e.speed * 3; // 3x speed burst
          e.vx += dx * rushSpeed * dt * 8; // Strong impulse
          e.vy += dy * rushSpeed * dt * 8;
          e.rushTimer = 1.5 + Math.random() * 2; // 1.5-3.5 second cooldown
        } else {
          // Normal movement between rushes (slower)
          e.vx += dx * e.speed * dt * 0.8 * walkRhythm;
          e.vy += dy * e.speed * dt * 0.8 * walkRhythm;
        }
      } else if (e.behavior === 'suicide') {
        // Suicide crawler - orbits player then charges periodically
        if (!e.chargeState) e.chargeState = 'orbiting';
        if (!e.chargeTimer) e.chargeTimer = 10 + Math.random() * 10; // 10-20 second orbit time
        if (!e.orbitAngle) e.orbitAngle = Math.random() * TAU; // Random starting orbit position
        if (!e.baseColor) e.baseColor = '#8844ff'; // Purple base color
        
        e.chargeTimer -= dt;
        
        if (e.chargeState === 'orbiting') {
          // Orbit around player at medium distance
          const orbitRadius = 120;
          const orbitSpeed = 1.2; // Orbit speed
          e.orbitAngle += dt * orbitSpeed;
          
          const targetX = p.x + fastCos(e.orbitAngle) * orbitRadius;
          const targetY = p.y + fastSin(e.orbitAngle) * orbitRadius;
          
          const orbitDx = targetX - e.x;
          const orbitDy = targetY - e.y;
          const orbitVec = normInPlace(orbitDx, orbitDy, vecPool.temp3);
          
          // Move toward orbit position with some attraction to player
          e.vx += orbitVec.x * e.speed * dt * 1.5;
          e.vy += orbitVec.y * e.speed * dt * 1.5;
          e.vx += dx * e.speed * dt * 0.2; // Slight player attraction
          e.vy += dy * e.speed * dt * 0.2;
          
          e.color = e.baseColor; // Purple while orbiting
          
          if (e.chargeTimer <= 0) {
            // Start telegraph phase
            e.chargeState = 'telegraph';
            e.chargeTimer = 1.0; // Telegraph for 1 second
          }
        } else if (e.chargeState === 'telegraph') {
          // Flash bright red during telegraph
          e.color = Math.sin(g.t * 15) > 0 ? '#ff0000' : e.baseColor;
          
          // Slow down during telegraph
          e.vx += dx * e.speed * dt * 0.2;
          e.vy += dy * e.speed * dt * 0.2;
          
          if (e.chargeTimer <= 0) {
            // Start charging
            e.chargeState = 'charging';
            e.chargeTimer = 4.0; // Longer charge duration
            e.color = '#ff0000'; // Stay red while charging
            beep(350, 0.12, 'sawtooth', 0.10); // Charge sound
          }
        } else if (e.chargeState === 'charging') {
          // Seeking charge - gentler curve toward player like seeking bullets
          const seekVec = normInPlace(p.x - e.x, p.y - e.y, vecPool.temp2);
          const sx = seekVec.x, sy = seekVec.y;
          
          // Use seeking bullet approach - blend current direction with target direction
          const currentSpeed = fastLength(e.vx, e.vy) || e.speed * 2; // 2x base speed
          const currentVec = currentSpeed > 0 ? normInPlace(e.vx, e.vy, vecPool.temp3) : { x: sx, y: sy };
          const seekingStrength = 0.15; // Gentler than bullet seeking (0.2)
          
          // Gradually curve toward player
          const newDx = currentVec.x + sx * seekingStrength;
          const newDy = currentVec.y + sy * seekingStrength;
          const finalVec = normInPlace(newDx, newDy, vecPool.temp1);
          
          // Apply final velocity at 2x speed
          const targetSpeed = e.speed * 2; // Actual 2x speed
          e.vx = finalVec.x * targetSpeed;
          e.vy = finalVec.y * targetSpeed;
          
          // Check if hit screen boundaries
          const gameWidth = g.width();
          const gameHeight = g.height();
          const hitBoundary = (e.x <= e.r || e.x >= gameWidth - e.r || 
                              e.y <= e.r || e.y >= gameHeight - e.r);
          
          if (e.chargeTimer <= 0 || hitBoundary) {
            // Reset to orbiting instead of exploding
            e.chargeState = 'orbiting';
            e.chargeTimer = 8 + Math.random() * 8; // 8-16 second orbit before next charge
            e.color = e.baseColor; // Back to purple
            e.orbitAngle = Math.atan2(e.y - p.y, e.x - p.x); // Start orbit from current position
          }
        }
      } else if (e.behavior === 'slowpush') {
        // Slow push - deliberate tanky movement toward player
        const pushStep = 0.9 + 0.2 * Math.sin(e.cadence * 0.4); // Heavy, slow rhythm
        e.vx += dx * e.speed * dt * 0.8 * pushStep * freezeMultiplier; // Slow but persistent
        e.vy += dy * e.speed * dt * 0.8 * pushStep * freezeMultiplier;
        
        // Update shield direction at 90% of rotation speed for counterplay
        if (e.hasShield && e.shieldDirection) {
          const shieldRotationSpeed = 0.9; // 90% speed
          const targetDir = { x: dx, y: dy };
          
          // Smoothly interpolate shield direction toward player direction
          e.shieldDirection.x = e.shieldDirection.x * (1 - shieldRotationSpeed * dt) + targetDir.x * shieldRotationSpeed * dt;
          e.shieldDirection.y = e.shieldDirection.y * (1 - shieldRotationSpeed * dt) + targetDir.y * shieldRotationSpeed * dt;
          
          // Normalize shield direction
          const len = Math.sqrt(e.shieldDirection.x * e.shieldDirection.x + e.shieldDirection.y * e.shieldDirection.y);
          if (len > 0) {
            e.shieldDirection.x /= len;
            e.shieldDirection.y /= len;
          }
        }
      } else if (e.behavior === 'spiralshooter') {
        // Spiral shooter - slow movement, rotates aim and shoots in patterns
        e.vx += dx * e.speed * dt * 0.6 * walkRhythm * freezeMultiplier; // Slow movement
        e.vy += dy * e.speed * dt * 0.6 * walkRhythm * freezeMultiplier;
        
        // Initialize spiral shooting properties
        if (!e.spiralAngle) e.spiralAngle = 0;
        if (!e.spiralShootTimer) e.spiralShootTimer = Math.random() * 2;
        
        // Rotate spiral angle continuously
        const rotationSpeed = 3.0; // radians per second
        e.spiralAngle += rotationSpeed * dt;
        
        // Shoot periodically in spiral pattern
        e.spiralShootTimer -= dt;
        if (e.spiralShootTimer <= 0) {
          spawnEnemyBullet(e.x, e.y, 
            e.x + fastCos(e.spiralAngle) * 100, 
            e.y + fastSin(e.spiralAngle) * 100);
          e.spiralShootTimer = 0.6; // Half frequency (was 0.3)
          beep(320, 0.04, 'triangle', 0.04); // High-pitched spiral sound
        }
      } else if (e.behavior === 'splitter') {
        // Splitter zombie - normal movement with slight erratic behavior
        const splitStep = 0.8 + 0.3 * Math.sin(e.cadence * 1.5); // Slightly erratic rhythm
        e.vx += dx * e.speed * dt * 1.0 * splitStep * freezeMultiplier;
        e.vy += dy * e.speed * dt * 1.0 * splitStep * freezeMultiplier;
        // Add slight random movement for unpredictability
        e.vx += (Math.random() - 0.5) * 50 * dt;
        e.vy += (Math.random() - 0.5) * 50 * dt;
      } else if (e.behavior === 'minelayer') {
        // Mine layer - slow movement, drops mines periodically
        e.vx += dx * e.speed * dt * 0.7 * walkRhythm * freezeMultiplier; // 30% slower
        e.vy += dy * e.speed * dt * 0.7 * walkRhythm * freezeMultiplier;
        
        // Initialize mine dropping properties
        if (!e.mineDropTimer) e.mineDropTimer = 1 + Math.random() * 2;
        if (!e.minesDropped) e.minesDropped = 0;
        const maxMines = 8; // Increased limit to 8 mines per enemy
        
        // Drop mines periodically every 6 seconds
        e.mineDropTimer -= dt;
        if (e.mineDropTimer <= 0 && e.minesDropped < maxMines) {
          // Spawn mine at current position
          mines.spawn(mine => {
            mine.x = e.x + (Math.random() - 0.5) * 20; // Slight position variance
            mine.y = e.y + (Math.random() - 0.5) * 20;
            mine.fuseTime = 0;
            mine.maxFuseTime = 30.0; // Long fuse - only triggered by proximity
            mine.isArmed = false; // Not armed immediately
            mine.triggerRadius = 35; // Original radius for triggering
            mine.explosionRadius = 70; // Doubled explosion radius
            mine.explosionDamage = 15 + game.wave * 2; // Scales with wave
            mine.flashTimer = 0;
            mine.isTriggered = false; // New triggered state
            mine.alive = true;
            mine.owner = e; // Track which enemy dropped it
          });
          
          e.minesDropped++;
          e.mineDropTimer = 12.0; // Fixed 12 second interval
          beep(180, 0.08, 'square', 0.06); // Mine drop sound
        }
      }
      
      // Shooter enemy logic with different patterns
      if (e.isShooter) {
        e.shootTimer -= dt;
        if (e.shootTimer <= 0) {
          if (e.shootPattern === 'spread') {
            spawnEnemySpreadShot(e.x, e.y, p.x, p.y, 3, Math.PI/3); // 3 bullets, 60Â° spread
            e.shootTimer = 2.5; // Slightly slower for spread
            beep(280, 0.08, 'sine', 0.10); // Lower, longer sound for spread
          } else if (e.shootPattern === 'burst') {
            spawnEnemyBullet(e.x, e.y, p.x, p.y);
            e.burstCount++;
            
            if (e.burstCount >= 3) {
              e.shootTimer = 3.0; // Long cooldown after burst
              e.burstCount = 0;
              beep(320, 0.05, 'sine', 0.06); // Final burst sound
            } else {
              e.shootTimer = 0.15; // Quick successive shots
              beep(300, 0.04, 'sine', 0.06); // Rapid burst sound
            }
          } else {
            // Single shot (default)
            spawnEnemyBullet(e.x, e.y, p.x, p.y);
            e.shootTimer = 2.0; // Reset timer
            beep(300, 0.06, 'sine', 0.08); // Enemy shooting sound
          }
        }
      }
      
      // damp
      e.vx *= (1 - 3*dt);
      e.vy *= (1 - 3*dt);
      e.x += e.vx*dt;
      e.y += e.vy*dt;
      // clamp bounds
      e.x = clamp(e.x, e.r, g.width()-e.r);
      e.y = clamp(e.y, e.r, g.height()-e.r);
      g.grid.insert(e);
    }
    
    // Update edge warnings
    // Update edge warnings using object
    edgeWarnings.top.style.display = nearTop ? 'block' : 'none';
    edgeWarnings.bottom.style.display = nearBottom ? 'block' : 'none';
    edgeWarnings.left.style.display = nearLeft ? 'block' : 'none';
    edgeWarnings.right.style.display = nearRight ? 'block' : 'none';

    // bullets - cache expensive property access and dimensions
    const bulletSpeedMult = game?.player?.bulletSpeed || 1.0;
    const gameWidthBounds = g.width() + 10;
    const gameHeightBounds = g.height() + 10;
    
    for (const b of bullets.items){
      if (!b.alive) continue;
      
      // Homing bullets
      const effects = b.effects || [];
      if (b.effectSet.has('homing')) {
        // Find new target if current target is dead/dying or we don't have one
        if (!b.homingTarget || !b.homingTarget.alive || b.homingTarget.dying || b.hitEnemies.has(b.homingTarget)) {
          let closest = null, closestDist = Infinity;
          for (const e of enemies.items) {
            if (!e.alive || e.dying || b.hitEnemies.has(e)) continue; // Skip dead/dying/already hit enemies
            const dist = fastLength(e.x - b.x, e.y - b.y);
            if (dist < closestDist) { closest = e; closestDist = dist; }
          }
          b.homingTarget = closest;
        }
      }
      
      if (b.effectSet.has('homing') && b.homingTarget && b.homingTarget.alive && !b.homingTarget.dying) {
        const homingVec = normInPlace(b.homingTarget.x - b.x, b.homingTarget.y - b.y, vecPool.temp2);
        const hx = homingVec.x, hy = homingVec.y;
        
        // Use consistent target speed instead of current speed (cache property access)
        const bulletSpeedMult = game?.player?.bulletSpeed || 1.0;
        const baseSpeed = 720 * bulletSpeedMult;
        const homingStrength = 0.3; // Even stronger homing
        
        b.vx = (b.vx * (1-homingStrength) + hx * baseSpeed * homingStrength);
        b.vy = (b.vy * (1-homingStrength) + hy * baseSpeed * homingStrength);
      }
      
      // Seeking bullets - curve toward nearest enemy without needing a specific target
      if (b.effectSet.has('seeking')) {
        let closest = null, closestDist = Infinity;
        for (const e of enemies.items) {
          if (!e.alive || e.dying) continue;
          const dist = fastLength(e.x - b.x, e.y - b.y);
          if (dist < closestDist && dist < 200) { // Seeking range
            closest = e; closestDist = dist;
          }
        }
        if (closest) {
          const seekVec = normInPlace(closest.x - b.x, closest.y - b.y, vecPool.temp3);
          const sx = seekVec.x, sy = seekVec.y;
          const baseSpeed = 720 * bulletSpeedMult; // Reuse cached value
          const seekingStrength = 0.2; // Lighter curve than homing
          
          // Gradually curve toward target
          const currentSpeed = fastLength(b.vx, b.vy);
          const currentVec = normInPlace(b.vx, b.vy, vecPool.temp4);
          const newDx = currentVec.x + sx * seekingStrength;
          const newDy = currentVec.y + sy * seekingStrength;
          const finalVec = normInPlace(newDx, newDy, vecPool.temp2);
          const finalDx = finalVec.x, finalDy = finalVec.y;
          
          b.vx = finalDx * currentSpeed;
          b.vy = finalDy * currentSpeed;
        }
      }
      
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life += dt;
      
      // Small trail effects for fast bullets
      const speed = fastLength(b.vx, b.vy);
      if (speed > 500 && shouldSpawnParticle() && Math.random() < 0.3) {
        particles.spawn(p => {
          p.x = b.x - b.vx * dt * 0.5; // Slightly behind bullet
          p.y = b.y - b.vy * dt * 0.5;
          p.vx = b.vx * 0.1; p.vy = b.vy * 0.1; // Slow trailing motion
          p.life = 0; p.maxLife = 0.15; // Short lifespan
          p.size = Math.min(2, b.r * 0.3); // Small size
          p.color = b.effects && b.effects.length > 0 ? '#ffff88' : '#ffffff';
        });
      }
      
      // Ricochet bullets (using cached dimensions)
      if (b.effectSet.has('ricochet') && b.bounces > 0) {
        if (b.x <= 0 || b.x >= gameWidth) { b.vx *= -1; b.bounces--; }
        if (b.y <= 0 || b.y >= gameHeight) { b.vy *= -1; b.bounces--; }
        b.x = clamp(b.x, 0, gameWidth);
        b.y = clamp(b.y, 0, gameHeight);
      } else if (b.life > b.maxLife || b.x< -10 || b.y< -10 || b.x>gameWidthBounds || b.y>gameHeightBounds){
        b.alive = false; continue;
      }
      // collide with enemies via spatial hash - piercing bullets track hit enemies
      const nearby = g.grid.near(b.x,b.y);
      for (const e of nearby){
        if (!e.alive || e.dying) continue;
        if (b.hitEnemies.has(e)) continue; // Skip enemies already hit by this bullet
        const rr = (b.r+e.r);
        if (fastDistanceCheck(b.x, b.y, e.x, e.y, rr)){
          // hit
          const damage = b.critical ? 2 : 1; // Critical hits deal double damage
          
          // Shield system - ONLY for slowpush enemies with shields
          let hitsShield = false;
          if (e.behavior === 'slowpush' && e.hasShield && e.shieldHP > 0 && e.shieldDirection) {
            // Calculate bullet direction relative to enemy
            const bulletDir = normInPlace(b.x - e.x, b.y - e.y, vecPool.temp2);
            
            // Check if bullet is coming from shield side (dot product > 0 means same direction)
            const dotProduct = bulletDir.x * e.shieldDirection.x + bulletDir.y * e.shieldDirection.y;
            hitsShield = dotProduct > 0.3; // Shield covers ~120Â° arc in front
          }
          
          if (hitsShield) {
            // Bullet hits shield
            e.shieldHP -= damage;
            if (e.shieldHP <= 0) {
              e.hasShield = false; // Shield broken
              beep(200, 0.06, 'square', 0.08); // Shield break sound
            } else {
              beep(300, 0.03, 'triangle', 0.05); // Shield hit sound
            }
          } else {
            // Bullet hits enemy body directly (from behind/side or no shield)
            e.hp -= damage;
          }
          
          b.hitEnemies.add(e); // Mark this enemy as hit by this bullet
          
          // Critical hit effects
          if (b.critical) {
            criticalHitSound();
            spawnBurst(e.x, e.y, 8, '#ffff00'); // Golden particles
            e.critFlashTimer = 0.1; // Brief flash effect
          }
          
          // Apply all special bullet effects
          const effects = b.effects || [];
          
          if (b.effectSet.has('explosive')) {
            // Explosive bullets damage nearby enemies
            for (const e2 of enemies.items) {
              if (!e2.alive || e2 === e) continue;
              const dist = fastLength(e2.x - b.x, e2.y - b.y);
              if (dist < 60) {
                e2.hp -= 1; // Increased from 40 to 60
                handleEnemyDeath(e2, g); // Handle death and crystal drops
              }
            }
            // Much more obvious explosion effect
            spawnBurst(b.x, b.y, 25, '#ff8000'); // More particles
            spawnBurst(b.x, b.y, 15, '#ff4000'); // Secondary burst
            spawnBurst(b.x, b.y, 10, '#ffff00'); // Yellow core
          }
          
          if (b.effectSet.has('lightning')) {
            // Lightning chains to nearby enemies (limit to prevent infinite chaining)
            let chainCount = 0;
            const maxChains = 3; // Limit chains per bullet
            
            for (const e2 of enemies.items) {
              if (!e2.alive || e2 === e || e2.dying) continue; // Skip dying enemies
              if (chainCount >= maxChains) break; // Limit total chains
              
              const dist = fastLength(e2.x - b.x, e2.y - b.y);
              if (dist < 120) { // Chain range
                e2.hp -= 1; // Chain damage
                chainCount++;
                handleEnemyDeath(e2, g); // Handle death and crystal drops
                
                // More obvious lightning effect
                spawnBurst(e2.x, e2.y, 12, '#ffff00');
                spawnBurst(e2.x, e2.y, 8, '#ffffff'); 
                spawnBurst(e2.x, e2.y, 4, '#00ffff');
                
                // Create lightning bolt line effect
                const steps = 5;
                for (let i = 0; i < steps; i++) {
                  const t = i / (steps - 1);
                  const lx = b.x + (e2.x - b.x) * t;
                  const ly = b.y + (e2.y - b.y) * t;
                  spawnBurst(lx, ly, 2, '#ffffff');
                }
              }
            }
          }
          
          if (b.effectSet.has('freeze')) {
            // Freeze shot slows enemies
            if (!e.frozen) e.frozen = 0;
            e.frozen = Math.max(e.frozen, 2.0); // 2 seconds of slowness
            spawnBurst(e.x, e.y, 8, '#00ffff');
          }
          
          if (b.effectSet.has('cluster')) {
            // Cluster shot - bullets split into smaller bullets on impact
            const fragments = 3;
            for (let i = 0; i < fragments; i++) {
              const angle = (TAU * i) / fragments;
              const dx = Math.cos(angle);
              const dy = Math.sin(angle);
              spawnBullet(b.x, b.y, dx, dy, []);
            }
            spawnBurst(b.x, b.y, 12, '#ffa500');
          }
          
          if (b.effectSet.has('seeking')) {
            // Seeking bullets curve toward enemies (enhanced homing)
            // This is implemented in the bullet update loop above, similar to homing
            // but with different behavior - seeking bullets don't need a specific target
          }
          
          // Handle enemy death and effects
          handleEnemyDeath(e, g);
          
          // Blood spray from bullet impact
          spawnBlood(b.x, b.y, b.vx, b.vy, 'impact');
          hitSound();
          
          // Shotgun effect - spawn additional bullets in spread BEFORE bullet is destroyed
          if (b.effectSet.has('shotgun')) {
            const spreadCount = 4;
            const spreadAngle = 0.5;
            for (let i = 0; i < spreadCount; i++) {
              const angle = (i / (spreadCount - 1) - 0.5) * spreadAngle;
              const cos = Math.cos(angle), sin = Math.sin(angle);
              const newDx = b.vx * cos - b.vy * sin;
              const newDy = b.vx * sin + b.vy * cos;
              const speed = fastLength(newDx, newDy);
              spawnBullet(b.x, b.y, newDx/speed, newDy/speed, []);
            }
          }
          
          // Piercing check - reduce pierces and destroy bullet if none left
          if (b.pierces > 0) {
            b.pierces--;
            // Bullet continues moving and can hit more enemies
          } else {
            // No pierces left, bullet is destroyed
            b.alive = false;
            break;
          }
          
          // Don't break - piercing bullets can hit multiple enemies in one frame
          // but each enemy can only be hit once per bullet (tracked by hitEnemies set)
        }
      }
    }

    // enemy bullets
    for (const eb of enemyBullets.items) {
      if (!eb.alive) continue;
      
      eb.x += eb.vx * dt;
      eb.y += eb.vy * dt;
      eb.life += dt;
      
      // Remove bullets that go off screen or expire
      if (eb.life > eb.maxLife || eb.x < -20 || eb.y < -20 || eb.x > g.width() + 20 || eb.y > g.height() + 20) {
        eb.alive = false;
        continue;
      }
      
      // Collision with player only
      const dist = fastLength(eb.x - p.x, eb.y - p.y);
      if (dist < eb.r + p.radius) {
        eb.alive = false; // Destroy bullet
        
        if (g.invulTime <= 0) {
          // Player takes damage from enemy bullet
          const damage = 8 + ((g.wave / 5) | 0); // +1 damage every 5 waves (bit operation)
          const actualDamage = Math.ceil(damage * (1 - p.damageReduction));
          p.hp -= actualDamage;
          g.invulTime = 0.35;
          g.damageFlash = 0.3;
          hurtSound();
          
          // Knockback effect - push player away from bullet (no array allocation)
          const knockVec = normInPlace(eb.vx, eb.vy, vecPool.temp1);
          p.vx += knockVec.x * 300; // Strong knockback
          p.vy += knockVec.y * 300;
          
          // Player blood effect
          spawnBlood(p.x, p.y, 0, 0, 'player');
          
          if (p.hp <= 0) {
            triggerGameOver(g);
          }
        }
      }
    }

    // enemy -> player collision
    const nearP = g.grid.near(p.x, p.y);
    for (const e of nearP){
      if (!e.alive || e.dying) continue;
      const rr = (p.radius + e.r);
      if (fastDistanceCheck(p.x, p.y, e.x, e.y, rr)){
        if (g.invulTime <= 0){
          const damage = Math.ceil(e.touchDmg * (1 - p.damageReduction));
          p.hp -= damage;
          g.invulTime = 0.35;
          g.damageFlash = 0.3; // Red vignette flash for 0.3 seconds
          hurtSound();
          
          // Suicide crawlers reset to orbiting after hitting player
          if (e.behavior === 'suicide') {
            e.chargeState = 'orbiting';
            e.chargeTimer = 6 + Math.random() * 6; // 6-12 second orbit after hit
            e.color = e.baseColor || '#8844ff'; // Back to purple
            e.orbitAngle = Math.atan2(e.y - p.y, e.x - p.x) + Math.PI; // Orbit away from player initially
          }
          
          // Slow push enemies apply knockback
          if (e.behavior === 'slowpush' && e.knockbackStrength) {
            const knockbackVec = normInPlace(p.x - e.x, p.y - e.y, vecPool.temp1);
            const knockbackForce = e.knockbackStrength;
            
            // Apply impulse knockback to player
            p.vx += knockbackVec.x * knockbackForce * dt;
            p.vy += knockbackVec.y * knockbackForce * dt;
            
            // Visual/audio feedback for knockback
            beep(150, 0.08, 'square', 0.06); // Low thud sound
          }
          
          // Adrenaline boost trigger
          if (p.adrenalineBoost) {
            p.adrenalineTimer = 3.0; // 3 seconds of speed boost
          }
          // Player blood effect
          spawnBlood(p.x, p.y, 0, 0, 'player');
          if (p.hp <= 0){
            // game over
            triggerGameOver(g);
          }
        }
        // Knockback (reduced by resistance)
        const knockbackReduction = Math.min(1.0, p.knockbackResistance || 0);
        const knockbackForce = 200 * (1 - knockbackReduction);
        if (knockbackForce > 0) {
          const [nx,ny] = norm(p.x - e.x, p.y - e.y);
          p.vx += nx * knockbackForce;
          p.vy += ny * knockbackForce;
        }
      }
    }

    // pickups
    for (const pickup of pickups.items){
      if (!pickup.alive) continue;
      
      // Physics - top-down view
      pickup.x += pickup.vx * dt;
      pickup.y += pickup.vy * dt;
      pickup.vy += 200 * dt; // Reduced gravity for top-down
      pickup.bounceTimer += dt;
      
      // Keep crystals on screen - clamp to bounds
      pickup.x = clamp(pickup.x, 10, g.width() - 10);
      pickup.y = clamp(pickup.y, 10, g.height() - 10);
      
      // Ground collision
      if (pickup.y >= g.height() - 20) {
        pickup.y = g.height() - 20;
        pickup.vy = Math.min(pickup.vy, 0); // Stop downward movement
      }
      
      // Add friction to slow horizontal movement
      pickup.vx *= (1 - 3*dt);
      
      // Gentle settle instead of hard ground bounce
      if (pickup.vy > 0 && pickup.bounceTimer > 0.3) {
        pickup.vy *= (1 - 4*dt); // Slow down vertical movement
        if (Math.abs(pickup.vy) < 20) pickup.vy = 0; // Stop when slow enough
      }
      
      // Magnetic crystals effect + player collision (single distance calculation)
      const dist = fastLength(pickup.x - p.x, pickup.y - p.y);
      
      if (p.magneticRange > 0 && dist < p.magneticRange && dist > 20) {
        const magVec = normInPlace(p.x - pickup.x, p.y - pickup.y, vecPool.temp2);
        pickup.vx += magVec.x * 750 * dt;
        pickup.vy += magVec.y * 750 * dt;
      }
      
      // Player collision (reuse distance calculation)
      if (dist < 20) {
        // Create collection particle burst before removing pickup
        const powerup = bulletPowerupMap.get(pickup.type);
        const particleColor = powerup ? powerup.color : '#ffffff';
        for (let i = 0; i < 8; i++) {
          particles.spawn(part => {
            part.x = pickup.x;
            part.y = pickup.y;
            const angle = (i / 8) * TAU;
            const speed = 100 + Math.random() * 100;
            part.vx = Math.cos(angle) * speed;
            part.vy = Math.sin(angle) * speed;
            part.life = 0;
            part.maxLife = 0.5;
            part.size = 2 + Math.random() * 2;
            part.color = particleColor;
          });
        }
        
        pickup.alive = false;
        
        // All crystals now use unified bullet powerup system
        if (powerup) {
          if (powerup.type === 'upgrade') {
            // Dual shot upgrade
            p.upgradeShots += powerup.shots;
            beep(800, 0.1, 'triangle', 0.03);
          } else if (powerup.type === 'triple' || powerup.type === 'quad') {
            // Pattern powerup - add multiplier instead of replacing
            p.patternMultipliers.set(powerup.type, powerup.shots);
            // Legacy support
            p.bulletPattern = powerup.type;
            p.patternTimer = powerup.shots;
            beep(600, 0.15, 'sawtooth', 0.04);
          } else {
            // Effect powerup - add to active effects instead of replacing
            p.activeEffects.set(powerup.type, powerup.shots);
            // Legacy support
            p.bulletType = powerup.type;
            p.bulletTimer = powerup.shots;
            beep(600, 0.15, 'sawtooth', 0.04);
          }
          showPowerupNotification(powerup.name);
        }
      }
    }

    // mines - timed explosives
    for (const mine of mines.items) {
      if (!mine.alive) continue;
      
      // Fuse timer
      mine.fuseTime += dt;
      mine.flashTimer += dt;
      
      // Arm mine after 0.5 seconds (can't be triggered immediately)
      if (!mine.isArmed && mine.fuseTime >= 0.5) {
        mine.isArmed = true;
      }
      
      // Check player proximity for armed mines
      if (mine.isArmed && !mine.isTriggered) {
        const distToPlayer = fastLength(mine.x - p.x, mine.y - p.y);
        
        // Trigger mine if player steps into trigger radius
        if (distToPlayer <= mine.triggerRadius) {
          mine.isTriggered = true;
          mine.fuseTime = 0; // Reset fuse for explosion countdown
          mine.maxFuseTime = 1.5; // 1.5 second explosion delay
          beep(400, 0.1, 'triangle', 0.1); // Trigger warning sound
        }
      }
      
      // Handle triggered mines
      if (mine.isTriggered && mine.fuseTime >= mine.maxFuseTime) {
        // Explode mine
        const explosionDist = fastLength(mine.x - p.x, mine.y - p.y);
        if (explosionDist <= mine.explosionRadius) {
          // Damage player
          p.hp -= mine.explosionDamage;
          beep(100, 0.15, 'sawtooth', 0.2); // Deep explosion
          spawnBlood(p.x, p.y, 0, 0, 'player');
          hurtSound();
        }
        
        // Explosion particles (bigger explosion)
        for (let i = 0; i < 30; i++) {
          particles.spawn(part => {
            const angle = (i / 30) * TAU + Math.random() * 0.3;
            const speed = randRange(150, 350); // Bigger explosion
            part.x = mine.x; part.y = mine.y;
            part.vx = fastCos(angle) * speed;
            part.vy = fastSin(angle) * speed;
            part.life = 0; part.maxLife = randRange(0.6, 1.0); // Longer lasting
            part.size = randRange(3, 7); // Bigger particles
            part.color = '#ff6600'; // Orange explosion
            part.hasGravity = false;
            part.alive = true;
          });
        }
        
        // Reduce mine count for owner
        if (mine.owner) mine.owner.minesDropped--;
        mine.alive = false;
      }
    }

    // blood stains - realistic droplet physics
    for (const stain of bloodStains.items){
      if (!stain.alive) continue;
      
      if (!stain.settled) {
        // Blood droplets still in motion
        stain.x += stain.vx * dt;
        stain.y += stain.vy * dt;
        stain.vx *= (1 - 8*dt); // Strong friction
        stain.vy *= (1 - 8*dt);
        
        // Settle when slow enough
        if (fastLength(stain.vx, stain.vy) < 10) {
          stain.settled = true;
          stain.vx = 0;
          stain.vy = 0;
        }
      }
      
      stain.life += dt;
      // Start fading after 3 seconds, fully gone at 15 seconds
      stain.alpha = stain.life > 3 ? 1.0 - ((stain.life - 3) / 12) : 1.0;
      if (stain.life >= stain.maxLife) stain.alive = false;
    }

    // particles
    for (const p2 of particles.items){
      if (!p2.alive) continue;
      p2.x += p2.vx*dt;
      p2.y += p2.vy*dt;
      // Add gravity to blood particles
      if (p2.hasGravity) {
        p2.vy += 150 * dt; // Gravity effect
      }
      p2.life += dt;
      if (p2.life >= p2.maxLife) p2.alive = false;
    }

    // HUD - batch updates to prevent layout thrashing
    queueDOMUpdate(() => {
      hpTxt.textContent = Math.max(0, Math.floor(p.hp)).toString();
      hudHpBar.style.width = clamp(p.hp/p.maxHp,0,1)*100 + '%';
      staminaTxt.textContent = Math.floor(p.stamina).toString();
      hudStaminaBar.style.width = clamp(p.stamina/100,0,1)*100 + '%';
      waveTxt.textContent = g.wave.toString();
      killsTxt.textContent = g.kills.toString();
    });
    
    // Clean up expired effects and patterns (no display needed)
    for (const [effect, shots] of p.activeEffects) {
      if (shots <= 0) p.activeEffects.delete(effect);
    }
    for (const [pattern, shots] of p.patternMultipliers) {
      if (shots <= 0) p.patternMultipliers.delete(pattern);
    }
  }

  function draw(g, alpha){
    // Reset render state for new frame
    resetRenderState();
    
    // Cache gradients to avoid recreation (gradients are EXPENSIVE to create)
    const gradientCache = new Map();
    
    // clear
    setFillStyle('#0b0d10');
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Draw cached background grid (only when needed)
    if (bgNeedsRedraw) {
      if (!bgCanvas) {
        bgCanvas = document.createElement('canvas');
        bgCtx = bgCanvas.getContext('2d');
      }
      bgCanvas.width = canvas.width;
      bgCanvas.height = canvas.height;
      
      // Draw grid to offscreen canvas
      bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
      bgCtx.globalAlpha = 0.07;
      bgCtx.strokeStyle = '#1a1f29';
      bgCtx.lineWidth = 1;
      const step = 64;
      bgCtx.beginPath();
      for (let x = (canvas.width%step); x < canvas.width; x += step){
        bgCtx.moveTo(x, 0); bgCtx.lineTo(x, canvas.height);
      }
      for (let y = (canvas.height%step); y < canvas.height; y += step){
        bgCtx.moveTo(0, y); bgCtx.lineTo(canvas.width, y);
      }
      bgCtx.stroke();
      bgNeedsRedraw = false;
    }
    // Blit pre-drawn background
    ctx.drawImage(bgCanvas, 0, 0);

    // blood stains - batched rendering to reduce save/restore overhead
    ctx.save();
    
    // Batch settled stains
    setFillStyle('#600000');
    setGlobalAlpha(0.64); // 0.8 * 0.8 average
    ctx.beginPath();
    for (const stain of bloodStains.items){
      if (!stain.alive || !stain.settled) continue;
      ctx.moveTo(stain.x + stain.size * 1.5, stain.y);
      ctx.arc(stain.x, stain.y, stain.size * 1.5, 0, TAU);
    }
    ctx.fill();
    
    // Batch moving droplets  
    setFillStyle('#cc0000');
    setGlobalAlpha(0.72); // 0.9 * 0.8 average
    ctx.beginPath();
    for (const stain of bloodStains.items){
      if (!stain.alive || stain.settled) continue;
      ctx.moveTo(stain.x + stain.size, stain.y);
      ctx.arc(stain.x, stain.y, stain.size, 0, TAU);
    }
    ctx.fill();
    
    ctx.restore();

    // draw player with leap glow
    const p = g.player;
    ctx.save();
    
    // Leap ready glow effect
    if (p.leapReady) {
      const glowIntensity = 0.7 + 0.3 * fastSin(g.t * 6); // Pulsing glow
      const glowRadius = p.radius + 8;
      
      // Outer glow
      const outerGradient = ctx.createRadialGradient(p.x, p.y, p.radius, p.x, p.y, glowRadius);
      outerGradient.addColorStop(0, `rgba(0, 255, 255, ${glowIntensity * 0.3})`);
      outerGradient.addColorStop(0.7, `rgba(0, 255, 255, ${glowIntensity * 0.2})`);
      outerGradient.addColorStop(1, `rgba(0, 255, 255, 0)`);
      ctx.fillStyle = outerGradient;
      ctx.beginPath();
      ctx.arc(p.x, p.y, glowRadius, 0, TAU);
      ctx.fill();
      
      // Inner rim glow
      ctx.strokeStyle = `rgba(0, 255, 255, ${glowIntensity * 0.8})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius + 2, 0, TAU);
      ctx.stroke();
    }
    
    // Player invulnerability flash
    if (g.invulTime > 0){
      ctx.globalAlpha = 0.6 + 0.4*fastSin(g.t*40);
    }
    
    // Main player body
    ctx.fillStyle = '#00ff00';
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, TAU);
    ctx.fill();
    ctx.restore();

    // crosshair
    ctx.save();
    ctx.globalAlpha = 0.5;
    ctx.strokeStyle = '#34d1ff';
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 10, 0, TAU);
    ctx.moveTo(mouseX-14, mouseY); ctx.lineTo(mouseX-4, mouseY);
    ctx.moveTo(mouseX+14, mouseY); ctx.lineTo(mouseX+4, mouseY);
    ctx.moveTo(mouseX, mouseY-14); ctx.lineTo(mouseX, mouseY-4);
    ctx.moveTo(mouseX, mouseY+14); ctx.lineTo(mouseX, mouseY+4);
    ctx.stroke();
    ctx.restore();

    // enemies
    for (const e of enemies.items){
      if (!e.alive) continue;
      
      // Super boss phase-based visual effects
      if (e.behavior === 'superboss') {
        ctx.save();
        
        // Phase-based color modulation
        const phase = e.currentPhase || 0;
        const phaseColors = ['#800080', '#ff0080', '#ff8000', '#8000ff'];
        const pulseIntensity = 0.7 + 0.3 * fastSin(g.t * 6);
        
        // Intimidating aura
        const auraRadius = e.r + 20;
        const auraGradient = ctx.createRadialGradient(e.x, e.y, e.r, e.x, e.y, auraRadius);
        auraGradient.addColorStop(0, `${phaseColors[phase]}80`);
        auraGradient.addColorStop(1, `${phaseColors[phase]}00`);
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(e.x, e.y, auraRadius, 0, TAU);
        ctx.fill();
        
        // Main boss body with phase color
        ctx.fillStyle = phaseColors[phase];
        ctx.globalAlpha = pulseIntensity;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, TAU);
        ctx.fill();
        
        // Phase indicator ring
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r + 8, 0, TAU);
        ctx.stroke();
        
        ctx.restore();
      } else {
        // Normal enemy rendering
        setFillStyle(e.critFlashTimer > 0 ? '#ffff88' : e.color); // Flash yellow on crit
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, TAU);
        ctx.fill();
        
        // Shield rendering - ONLY for slowpush enemies
        if (e.behavior === 'slowpush' && e.hasShield && e.shieldHP > 0) {
          // Use lagged shield direction instead of instant player direction
          const shieldDir = e.shieldDirection || { x: 1, y: 0 };
          const shieldOffset = e.r + 5; // 5 pixels in front of enemy
          const shieldX = e.x + shieldDir.x * shieldOffset;
          const shieldY = e.y + shieldDir.y * shieldOffset;
          
          // Shield dimensions
          const shieldWidth = e.r * 1.2;
          const shieldHeight = e.r * 0.8;
          
          // Shield health-based transparency
          const shieldAlpha = Math.max(0.3, e.shieldHP / e.maxShieldHP);
          
          ctx.save();
          ctx.globalAlpha = shieldAlpha;
          ctx.fillStyle = '#888888'; // Gray shield
          ctx.fillRect(shieldX - shieldWidth/2, shieldY - shieldHeight/2, shieldWidth, shieldHeight);
          
          // Shield border
          ctx.strokeStyle = '#aaaaaa';
          ctx.lineWidth = 1;
          ctx.strokeRect(shieldX - shieldWidth/2, shieldY - shieldHeight/2, shieldWidth, shieldHeight);
          ctx.restore();
        }
      }
    }

    // player bullets - batched rendering
    setFillStyle('#e3e7ef');
    ctx.beginPath();
    for (const b of bullets.items){
      if (!b.alive) continue;
      ctx.moveTo(b.x + b.r, b.y);
      ctx.arc(b.x, b.y, b.r, 0, TAU);
    }
    ctx.fill();

    // enemy bullets - batched rendering
    setFillStyle('#ff4444');
    ctx.beginPath();
    for (const eb of enemyBullets.items){
      if (!eb.alive) continue;
      ctx.moveTo(eb.x + eb.r, eb.y);
      ctx.arc(eb.x, eb.y, eb.r, 0, TAU);
    }
    ctx.fill();

    // pickups
    for (const pickup of pickups.items){
      if (!pickup.alive) continue;
      ctx.save();
      
      // Animated diamond with sparkle effect
      const sparkle = 0.8 + 0.2 * fastSin(g.t * 8 + pickup.bounceTimer * 3);
      ctx.globalAlpha = sparkle;
      
      // Color based on pickup type
      const powerup = bulletPowerupMap.get(pickup.type);
      
      // Special glow effects for homing crystals (gold)
      if (pickup.type === 'homing') {
        // Golden glow aura
        const glowIntensity = 0.6 + 0.4 * fastSin(g.t * 12 + pickup.bounceTimer * 5);
        const glowSize = 16 + 8 * fastSin(g.t * 6);
        
        // Cache expensive gradient creation (numeric key is faster)
        const glowKey = ((glowSize*100)|0) * 10000 + ((glowIntensity*100)|0);
        let outerGlow = gradientCache.get(glowKey);
        if (!outerGlow) {
          outerGlow = ctx.createRadialGradient(0, 0, 8, 0, 0, glowSize);
          const alpha08 = (glowIntensity * 0.8).toFixed(2);
          const alpha04 = (glowIntensity * 0.4).toFixed(2);
          outerGlow.addColorStop(0, 'rgba(255,215,0,' + alpha08 + ')');
          outerGlow.addColorStop(0.5, 'rgba(255,215,0,' + alpha04 + ')');
          outerGlow.addColorStop(1, 'rgba(255,215,0,0)');
          gradientCache.set(glowKey, outerGlow);
        }
        ctx.fillStyle = outerGlow;
        ctx.beginPath();
        ctx.arc(pickup.x, pickup.y, glowSize, 0, TAU);
        ctx.fill();
        
        // Inner bright core
        const coreGlow = ctx.createRadialGradient(pickup.x, pickup.y, 0, pickup.x, pickup.y, 12);
        coreGlow.addColorStop(0, `rgba(255, 255, 255, ${glowIntensity * 0.9})`);
        coreGlow.addColorStop(0.3, `rgba(255, 235, 59, ${glowIntensity * 0.7})`);
        coreGlow.addColorStop(1, `rgba(255, 215, 0, ${glowIntensity * 0.3})`);
        ctx.fillStyle = coreGlow;
        ctx.beginPath();
        ctx.arc(pickup.x, pickup.y, 12, 0, TAU);
        ctx.fill();
      }
      
      ctx.fillStyle = powerup ? powerup.color : '#ffffff';
      ctx.strokeStyle = pickup.type === 'homing' ? '#FFFFFF' : '#ffffff';
      ctx.lineWidth = pickup.type === 'homing' ? 2 : 1;
      
      // Draw diamond shape (larger for homing)
      ctx.beginPath();
      const size = pickup.type === 'homing' ? 10 : 8;
      ctx.moveTo(pickup.x, pickup.y - size);
      ctx.lineTo(pickup.x + size, pickup.y);
      ctx.lineTo(pickup.x, pickup.y + size);
      ctx.lineTo(pickup.x - size, pickup.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      ctx.restore();
    }

    // mines - explosive devices
    for (const mine of mines.items) {
      if (!mine.alive) continue;
      
      // Mine body
      ctx.fillStyle = mine.isArmed ? '#ff4400' : '#994400'; // Orange when armed, dark orange when not
      ctx.beginPath();
      ctx.arc(mine.x, mine.y, mine.r, 0, TAU);
      ctx.fill();
      
      // Show trigger radius for armed mines (static circle)
      if (mine.isArmed && !mine.isTriggered) {
        ctx.strokeStyle = 'rgba(255, 100, 0, 0.3)'; // Faint orange circle
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]); // Small dashed circle
        ctx.beginPath();
        ctx.arc(mine.x, mine.y, mine.triggerRadius, 0, TAU);
        ctx.stroke();
        ctx.setLineDash([]); // Reset line dash
      }
      
      // Flashing effect when triggered and about to explode
      if (mine.isTriggered) {
        const flashRate = Math.min(20, mine.fuseTime * 15); // Accelerating flash
        if (Math.sin(mine.flashTimer * flashRate) > 0) {
          ctx.fillStyle = '#ffff00'; // Bright yellow flash
          ctx.beginPath();
          ctx.arc(mine.x, mine.y, mine.r, 0, TAU);
          ctx.fill();
        }
        
        // Pulsing explosion radius warning circle (doubled size)
        const pulseIntensity = 0.4 + 0.5 * Math.sin(mine.flashTimer * flashRate * 0.8);
        ctx.strokeStyle = `rgba(255, 255, 0, ${pulseIntensity})`;
        ctx.lineWidth = 3;
        ctx.setLineDash([8, 4]); // Bigger dashed circle
        ctx.beginPath();
        ctx.arc(mine.x, mine.y, mine.explosionRadius, 0, TAU);
        ctx.stroke();
        ctx.setLineDash([]); // Reset line dash
      }
      
      // Mine spikes/details
      ctx.strokeStyle = '#663300';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * TAU;
        const spike = mine.r + 2;
        ctx.moveTo(mine.x, mine.y);
        ctx.lineTo(mine.x + fastCos(angle) * spike, mine.y + fastSin(angle) * spike);
      }
      ctx.stroke();
    }

    // particles
    for (const p2 of particles.items){
      if (!p2.alive) continue;
      const a = 1 - p2.life/p2.maxLife;
      ctx.globalAlpha = a*0.9;
      ctx.fillStyle = p2.color;
      ctx.fillRect(p2.x, p2.y, p2.size, p2.size);
      ctx.globalAlpha = 1;
    }

    // Red damage vignette
    if (g.damageFlash > 0) {
      const intensity = g.damageFlash / 0.3; // Fade from 1 to 0
      const gradient = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, 0,
        canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)
      );
      gradient.addColorStop(0, `rgba(255, 0, 0, 0)`);
      gradient.addColorStop(0.7, `rgba(255, 0, 0, ${intensity * 0.1})`);
      gradient.addColorStop(1, `rgba(255, 0, 0, ${intensity * 0.4})`);
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Crystal inventory display under HUD
    const crystalInventoryY = 160; // Start below HUD
    const crystalSize = 40; // 50% of 80 = 40
    const crystalSpacing = 50; // Adjust spacing
    let inventoryIndex = 0;
    
    // Show dual shot if active
    if (g.player.upgradeShots > 0) {
      const x = 24; // Left edge alignment with HUD
      const y = crystalInventoryY + (inventoryIndex * crystalSpacing);
      
      // Don't draw if it would go off screen
      if (y + crystalSize/2 < canvas.height - 20) {
        ctx.save();
        
        // Animated sparkle effect like pickup crystals
        const sparkle = 0.8 + 0.2 * fastSin(g.t * 8 + inventoryIndex * 0.5);
        ctx.globalAlpha = sparkle;
        
        ctx.fillStyle = '#00BFFF'; // Dual shot color
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        
        // Draw diamond shape
        ctx.beginPath();
        ctx.moveTo(x, y - crystalSize/2);
        ctx.lineTo(x + crystalSize/2, y);
        ctx.lineTo(x, y + crystalSize/2);
        ctx.lineTo(x - crystalSize/2, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Draw crystal name
        ctx.fillStyle = '#e3e7ef';
        ctx.font = '12px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('Dual Shot', x + crystalSize/2 + 8, y + 4);
        
        ctx.restore();
        
        inventoryIndex++;
      }
    }
    
    // Show pattern multipliers
    for (const [pattern, shots] of g.player.patternMultipliers) {
      if (shots > 0) {
        const x = 24;
        const y = crystalInventoryY + (inventoryIndex * crystalSpacing);
        
        // Don't draw if it would go off screen
        if (y + crystalSize/2 < canvas.height - 20) {
          ctx.save();
          
          // Animated sparkle effect like pickup crystals
          const sparkle = 0.8 + 0.2 * fastSin(g.t * 8 + inventoryIndex * 0.5);
          ctx.globalAlpha = sparkle;
          
          const powerup = bulletPowerupMap.get(pattern);
          ctx.fillStyle = powerup ? powerup.color : '#ffffff';
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          
          // Draw diamond shape
          ctx.beginPath();
          ctx.moveTo(x, y - crystalSize/2);
          ctx.lineTo(x + crystalSize/2, y);
          ctx.lineTo(x, y + crystalSize/2);
          ctx.lineTo(x - crystalSize/2, y);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          // Draw crystal name
          ctx.fillStyle = '#e3e7ef';
          ctx.font = '12px system-ui';
          ctx.textAlign = 'left';
          const crystalName = powerup ? powerup.name : pattern;
          ctx.fillText(crystalName, x + crystalSize/2 + 8, y + 4);
          
          ctx.restore();
          
          inventoryIndex++;
        }
      }
    }
    
    // Show active effects
    for (const [effect, shots] of g.player.activeEffects) {
      if (shots > 0) {
        const x = 24;
        const y = crystalInventoryY + (inventoryIndex * crystalSpacing);
        
        // Don't draw if it would go off screen
        if (y + crystalSize/2 < canvas.height - 20) {
          ctx.save();
          
          // Animated sparkle effect like pickup crystals
          const sparkle = 0.8 + 0.2 * fastSin(g.t * 8 + inventoryIndex * 0.5);
          ctx.globalAlpha = sparkle;
          
          const powerup = bulletPowerupMap.get(effect);
          
          // Special glow effects for homing crystals in inventory
          if (effect === 'homing') {
            const glowIntensity = 0.5 + 0.3 * fastSin(g.t * 10);
            const glowSize = crystalSize/2 + 12;
            
            // Golden glow aura for inventory homing crystal
            const inventoryGlow = ctx.createRadialGradient(x, y, crystalSize/2, x, y, glowSize);
            inventoryGlow.addColorStop(0, `rgba(255, 215, 0, ${glowIntensity * 0.6})`);
            inventoryGlow.addColorStop(0.7, `rgba(255, 215, 0, ${glowIntensity * 0.3})`);
            inventoryGlow.addColorStop(1, `rgba(255, 215, 0, 0)`);
            ctx.fillStyle = inventoryGlow;
            ctx.beginPath();
            ctx.arc(x, y, glowSize, 0, TAU);
            ctx.fill();
          }
          
          ctx.fillStyle = powerup ? powerup.color : '#ffffff';
          ctx.strokeStyle = effect === 'homing' ? '#FFFF99' : '#ffffff';
          ctx.lineWidth = effect === 'homing' ? 3 : 2;
          
          // Draw diamond shape
          ctx.beginPath();
          ctx.moveTo(x, y - crystalSize/2);
          ctx.lineTo(x + crystalSize/2, y);
          ctx.lineTo(x, y + crystalSize/2);
          ctx.lineTo(x - crystalSize/2, y);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          // Draw crystal name
          ctx.fillStyle = '#e3e7ef';
          ctx.font = '12px system-ui';
          ctx.textAlign = 'left';
          const crystalName = powerup ? powerup.name : effect;
          ctx.fillText(crystalName, x + crystalSize/2 + 8, y + 4);
          
          ctx.restore();
          
          inventoryIndex++;
        }
      }
    }
  }

  // ===== Loop (fixed-timestep with interpolation) =====
  let last = performance.now();
  const dtFixed = 1/60;
  let acc = 0;
  function frame(now){
    try {
      const rawDt = Math.min(0.05, (now - last)*0.001);
      updatePerformanceLevel(rawDt * 1000); // Convert to milliseconds
      last = now;
      if (game && game.state === STATE.RUN){
        acc += rawDt;
        while (acc >= dtFixed){
          try {
            update(game, dtFixed);
          } catch (updateError) {
            console.error('Game update error:', updateError);
            // Pause game on critical error to prevent infinite errors
            if (game) game.state = STATE.PAUSE;
            break;
          }
          acc -= dtFixed;
        }
        const alpha = acc / dtFixed;
        try {
          draw(game, alpha);
        } catch (drawError) {
          console.error('Game draw error:', drawError);
        }
      }

      // FPS
      if (game){
        try {
          const fps = 1/rawDt;
          game.fpsSamples.push(fps);
          game.fpsSum += fps;
          if (game.fpsSamples.length > 20){
            game.fpsSum -= game.fpsSamples.shift(); // Subtract removed value
            const avg = game.fpsSum / game.fpsSamples.length;
            fpsTxt.textContent = 'FPS: ' + Math.round(avg);
          }
        } catch (fpsError) {
          console.error('FPS calculation error:', fpsError);
        }
      }
    } catch (frameError) {
      console.error('Critical frame error:', frameError);
    }

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ===== Pause / Resume =====
  function togglePause(){
    if (!game || (game.state!==STATE.RUN && game.state!==STATE.PAUSE)) return;
    if (game.state === STATE.RUN) {
      game.state = STATE.PAUSE;
      banner.style.display = 'block';
      banner.style.animation = 'pauseSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
      // Clear banner content safely
      while (banner.firstChild) {
        banner.removeChild(banner.firstChild);
      }
      
      // Create pause screen elements with enhanced styling
      
      const controlsDiv = document.createElement('div');
      controlsDiv.className = 'controls-panel';
      
      // Use the same enhanced controls layout as the main menu
      controlsDiv.innerHTML = `
        <div class="controls-title"><strong>Controls</strong></div>
        <div class="control-row">
          <div class="control-keys"><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd></div>
          <div class="control-desc">Move around the arena</div>
        </div>
        <div class="control-row">
          <div class="control-keys"><kbd>Mouse</kbd></div>
          <div class="control-desc">Aim and shoot</div>
        </div>
        <div class="control-row">
          <div class="control-keys"><kbd>Shift</kbd></div>
          <div class="control-desc">Dash through enemies</div>
        </div>
        <div class="control-row">
          <div class="control-keys"><kbd>Space</kbd></div>
          <div class="control-desc">Emergency leap</div>
        </div>
        <div class="control-row">
          <div class="control-keys"><kbd>P</kbd></div>
          <div class="control-desc">Resume game</div>
        </div>
        <div class="control-row">
          <div class="control-keys"><kbd>L</kbd></div>
          <div class="control-desc">Crystal legend</div>
        </div>
        <div class="control-row">
          <div class="control-keys"><kbd>F11</kbd></div>
          <div class="control-desc">Toggle fullscreen</div>
        </div>
        <div class="mobile-note">Mobile: Touch left side to move, right side to aim/shoot</div>
      `;
      
      // Add upgrades section
      const upgradesDiv = document.createElement('div');
      upgradesDiv.style.cssText = 'margin: 16px 0; padding: 12px; background: rgba(26, 31, 41, 0.7); border-radius: 8px; font-size: 13px;';
      
      const upgradesTitle = document.createElement('div');
      upgradesTitle.style.marginBottom = '8px';
      const upgradesStrong = document.createElement('strong');
      upgradesStrong.textContent = 'Active Upgrades';
      upgradesTitle.appendChild(upgradesStrong);
      
      const upgradesList = document.createElement('div');
      upgradesList.style.cssText = 'max-height: 120px; overflow-y: auto; line-height: 1.4;';
      
      const upgrades = createUpgradesDisplay();
      upgrades.forEach(upgrade => {
        const upgradeItem = document.createElement('div');
        upgradeItem.style.cssText = 'margin: 2px 0; color: #5af2c7;';
        upgradeItem.textContent = 'â€¢ ' + upgrade;
        upgradesList.appendChild(upgradeItem);
      });
      
      upgradesDiv.appendChild(upgradesTitle);
      upgradesDiv.appendChild(upgradesList);
      
      const startBtn = document.createElement('button');
      startBtn.id = 'startBtn';
      startBtn.textContent = 'Resume';
      
      banner.appendChild(controlsDiv);
      banner.appendChild(upgradesDiv);
      banner.appendChild(startBtn);
      // Re-attach event listener to the new Resume button
      document.getElementById('startBtn').addEventListener('click', () => { 
        initAudio(); 
        if (game && game.state === STATE.PAUSE) {
          // Resume from pause
          togglePause();
        } else {
          // Start new game
          start(); 
        }
      });
    } else {
      banner.style.animation = 'pauseSlideOut 0.3s ease-out forwards';
      setTimeout(() => {
        banner.style.display = 'none';
      }, 300);
      game.state = STATE.RUN;
      // Restore original banner content safely
      while (banner.firstChild) {
        banner.removeChild(banner.firstChild);
      }
      
      // Create start screen elements with enhanced styling
      
      const controlsDiv = document.createElement('div');
      controlsDiv.className = 'controls-panel';
      
      // Use the same enhanced controls layout as the main menu
      controlsDiv.innerHTML = `
        <div class="controls-title"><strong>Controls</strong></div>
        <div class="control-row">
          <div class="control-keys"><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd></div>
          <div class="control-desc">Move around the arena</div>
        </div>
        <div class="control-row">
          <div class="control-keys"><kbd>Mouse</kbd></div>
          <div class="control-desc">Aim and shoot</div>
        </div>
        <div class="control-row">
          <div class="control-keys"><kbd>Shift</kbd></div>
          <div class="control-desc">Dash through enemies</div>
        </div>
        <div class="control-row">
          <div class="control-keys"><kbd>Space</kbd></div>
          <div class="control-desc">Emergency leap</div>
        </div>
        <div class="control-row">
          <div class="control-keys"><kbd>P</kbd></div>
          <div class="control-desc">Resume game</div>
        </div>
        <div class="control-row">
          <div class="control-keys"><kbd>L</kbd></div>
          <div class="control-desc">Crystal legend</div>
        </div>
        <div class="control-row">
          <div class="control-keys"><kbd>F11</kbd></div>
          <div class="control-desc">Toggle fullscreen</div>
        </div>
        <div class="mobile-note">Mobile: Touch left side to move, right side to aim/shoot</div>
      `;
      
      const startBtn = document.createElement('button');
      startBtn.id = 'startBtn';
      startBtn.textContent = 'Start';
      
      banner.appendChild(controlsDiv);
      banner.appendChild(startBtn);
      // Re-attach event listener to the new Start button
      document.getElementById('startBtn').addEventListener('click', () => { 
        initAudio(); 
        if (game && game.state === STATE.PAUSE) {
          // Resume from pause
          togglePause();
        } else {
          // Start new game
          start(); 
        }
      });
    }
  }

  // ===== Start / Restart =====
  function start(){
    game = newGame();
    // Animate out existing screens
    if (banner.style.display !== 'none') {
      banner.style.animation = 'pauseSlideOut 0.3s ease-out forwards';
      setTimeout(() => { banner.style.display = 'none'; }, 300);
    }
    if (gameOverPanel.style.display !== 'none') {
      gameOverPanel.style.animation = 'gameOverSlideOut 0.4s ease-out forwards';
      setTimeout(() => { gameOverPanel.style.display = 'none'; }, 400);
    } else {
      banner.style.display = 'none';
      gameOverPanel.style.display = 'none';
    }
    game.state = STATE.RUN;
    // Center player
    game.player.x = canvas.width/2;
    game.player.y = canvas.height/2;
    
    // Dramatic game start flash effect
    gameStartOverlay.style.animation = 'gameStartFlash 1.2s ease-out forwards';
    setTimeout(() => {
      gameStartOverlay.style.opacity = '0';
    }, 1200);
    // Clear pools
    for (const it of bullets.items) it.alive = false;
    for (const it of enemies.items) it.alive = false;
    for (const it of particles.items) it.alive = false;
    for (const it of pickups.items) it.alive = false;
    for (const it of mines.items) it.alive = false;
    for (const it of bloodStains.items) it.alive = false;
    for (const it of enemyBullets.items) it.alive = false;
    
    // Start first wave
    game.waveActive = true;
    
    // Ensure wave announcement is fully reset before showing wave 1
    waveAnnouncement.style.animation = 'none';
    waveAnnouncement.style.display = 'none';
    // Clear any existing timeouts to prevent flash
    waveAnnouncementTimeouts.forEach(timeout => clearTimeout(timeout));
    waveAnnouncementTimeouts = [];
    
    // Skip wave 1 announcement to avoid flash issue
    // showWaveAnnouncement(1, false);
    
    // Spawn first wave enemies within 2-4 seconds
    const spawnDuration = 2000 + Math.random() * 2000; // 2-4 seconds
    const spawnInterval = spawnDuration / game.waveEnemiesTarget;
    
    for (let i = 0; i < game.waveEnemiesTarget; i++) {
      setTimeout(() => {
        if (game.waveActive) {
          spawnEnemy(game);
          game.waveEnemiesSpawned++;
        }
      }, i * spawnInterval);
    }
  }

  startBtn.addEventListener('click', () => { 
    initAudio(); 
    if (game && game.state === STATE.PAUSE) {
      // Resume from pause
      togglePause();
    } else {
      // Start new game
      start(); 
    }
  });
  restartBtn.addEventListener('click', () => { start(); });

  // Start in menu
  game = newGame();

  // Improve crispness on some displays
  ctx.imageSmoothingEnabled = false;

  // Visibility pause
  document.addEventListener('visibilitychange', () => {
    if (document.hidden && game && game.state === STATE.RUN){
      togglePause();
    }
  });
  </script>
</body>
</html>
