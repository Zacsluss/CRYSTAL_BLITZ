<!doctype html>
<!-- Crystal Blitz v0.99 -->
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="screen-orientation" content="landscape">
  <meta name="version" content="0.99">
  <meta name="description" content="Crystal Blitz - High-performance arena shooter in a single HTML file">
  <title>Crystal Blitz v0.99 — Arena Shooter</title>
  <style>
    :root {
      --bg: #0b0d10;
      --fg: #e3e7ef;
      --muted: #99a2b2;
      --accent: #5af2c7;
      --danger: #ff5b6e;
      --warning: #ffd166;
      --panel: #12161d;
      --panel2: #0f1319;
      --shadow: rgba(0,0,0,0.35);
      --health-gradient: linear-gradient(90deg, #ff6b6b, #ffa5a5);
      --stamina-gradient: linear-gradient(90deg, #ffd166, #ffeb99);
    }
    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--fg);
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Noto Sans", "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    #hud {
      position: fixed;
      top: 20px;
      left: 20px;
      background: linear-gradient(180deg, rgba(18, 22, 29, 0.7), rgba(15, 19, 25, 0.7));
      padding: 20px 24px;
      border-radius: 10px;
      box-shadow: 0 6px 14px var(--shadow);
      font-size: 28px;
      user-select: none;
      pointer-events: none;
      min-width: 440px;
      backdrop-filter: blur(4px);
      z-index: 200;
      opacity: 0;
      visibility: hidden;
      transition: none;
    }
    #hud .row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
      white-space: nowrap;
    }
    #hud .bar {
      --w: 320px;
      position: relative;
      width: var(--w);
      height: 16px;
      background: #1a1f29;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid #1f2430;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);
    }
    #hud .bar > i {
      display: block;
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #34d1ff);
      box-shadow: inset 0 0 6px rgba(0,0,0,0.25);
      transition: none;
      position: relative;
      border-radius: 999px;
    }
    #hud .bar.healing > i::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, 
        rgba(255,255,255,0) 0%, 
        rgba(255,255,255,0.4) 45%, 
        rgba(255,255,255,0.6) 50%, 
        rgba(255,255,255,0.4) 55%, 
        rgba(255,255,255,0) 100%);
      animation: shimmer 1.5s infinite;
      opacity: 0.8;
    }
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(200%); }
    }
    #hud .bar.health > i { 
      background: var(--health-gradient); 
      box-shadow: 0 0 20px rgba(255, 107, 107, 1), 0 0 40px rgba(255, 107, 107, 0.6), inset 0 0 10px rgba(0,0,0,0.3);
      filter: brightness(1.1);
    }
    #hud .bar.health.taking-damage > i {
      background: linear-gradient(90deg, #ff3333, #ff6666) !important;
      box-shadow: 0 0 30px rgba(255, 0, 0, 1), 0 0 60px rgba(255, 0, 0, 0.8), inset 0 0 15px rgba(255,255,255,0.3) !important;
      filter: brightness(1.4) saturate(1.5);
      animation: damageFlash 0.3s ease-out;
    }
    @keyframes damageFlash {
      0% { 
        filter: brightness(2) saturate(2);
      }
      50% {
        filter: brightness(1.7) saturate(1.7);
      }
      100% { 
        filter: brightness(1.4) saturate(1.5);
      }
    }
    #hud .bar.health.low > i {
      animation: pulseLow 1s ease-in-out infinite;
    }
    @keyframes pulseLow {
      0%, 100% { 
        box-shadow: 0 0 20px rgba(255, 107, 107, 1), 0 0 40px rgba(255, 0, 0, 0.6), inset 0 0 10px rgba(0,0,0,0.3);
        filter: brightness(1.1);
      }
      50% { 
        box-shadow: 0 0 40px rgba(255, 107, 107, 1), 0 0 80px rgba(255, 0, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.2);
        filter: brightness(1.5);
      }
    }
    #hud .bar.stamina > i { 
      background: var(--stamina-gradient); 
      box-shadow: 0 0 20px rgba(255, 209, 102, 1), 0 0 40px rgba(255, 209, 102, 0.6), inset 0 0 10px rgba(0,0,0,0.3);
      filter: brightness(1.1);
    }
    #hud .bar.stamina.using-stamina > i {
      background: linear-gradient(90deg, #ff9933, #ffcc66) !important;
      box-shadow: 0 0 30px rgba(255, 153, 0, 1), 0 0 60px rgba(255, 200, 0, 0.8), inset 0 0 15px rgba(255,255,255,0.3) !important;
      filter: brightness(1.3) saturate(1.4);
      animation: staminaDrain 0.2s ease-out;
    }
    @keyframes staminaDrain {
      0% { 
        filter: brightness(1.8) saturate(1.8);
      }
      100% { 
        filter: brightness(1.3) saturate(1.4);
      }
    }
    #hud .bar.stamina.low > i {
      animation: pulseStaminaLow 0.8s ease-in-out infinite;
    }
    @keyframes pulseStaminaLow {
      0%, 100% { 
        box-shadow: 0 0 20px rgba(255, 209, 102, 1), 0 0 40px rgba(255, 200, 0, 0.6), inset 0 0 10px rgba(0,0,0,0.3);
        filter: brightness(1.1);
      }
      50% { 
        box-shadow: 0 0 40px rgba(255, 209, 102, 1), 0 0 80px rgba(255, 200, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.2);
        filter: brightness(1.6);
      }
    }
    #hud .bar.heat > i { 
      background: linear-gradient(90deg, #ff9933, #ff6600);
      box-shadow: 0 0 15px rgba(255, 153, 51, 0.8), inset 0 0 8px rgba(0,0,0,0.3);
      filter: brightness(1.1);
      transition: all 0.15s ease;
    }
    #hud .bar.heat.warning > i {
      background: linear-gradient(90deg, #ff6600, #ff4400) !important;
      box-shadow: 0 0 25px rgba(255, 102, 0, 1), 0 0 50px rgba(255, 102, 0, 0.6), inset 0 0 12px rgba(0,0,0,0.3) !important;
      filter: brightness(1.2);
      animation: heatWarning 0.8s ease-in-out infinite;
    }
    @keyframes heatWarning {
      0%, 100% { filter: brightness(1.2); }
      50% { filter: brightness(1.5); }
    }
    #hud .bar.heat.danger > i {
      background: linear-gradient(90deg, #ff3300, #ff0000) !important;
      box-shadow: 0 0 35px rgba(255, 0, 0, 1), 0 0 70px rgba(255, 0, 0, 0.8), inset 0 0 15px rgba(255,255,255,0.2) !important;
      filter: brightness(1.4) saturate(1.5);
      animation: heatDanger 0.4s ease-in-out infinite;
    }
    @keyframes heatDanger {
      0%, 100% { 
        filter: brightness(1.4) saturate(1.5);
        transform: scaleY(1);
      }
      50% { 
        filter: brightness(1.8) saturate(2);
        transform: scaleY(1.05);
      }
    }
    #hud .bar.heat.overheated > i {
      background: linear-gradient(90deg, #ffffff, #ff0000, #ffffff) !important;
      box-shadow: 0 0 50px rgba(255, 0, 0, 1), 0 0 100px rgba(255, 0, 0, 1), inset 0 0 20px rgba(255,255,255,0.5) !important;
      filter: brightness(2) saturate(0.5);
      animation: overheatPulse 0.3s ease-in-out infinite;
    }
    @keyframes overheatPulse {
      0%, 100% { 
        filter: brightness(2) saturate(0.5);
        background-position: 0% 50%;
      }
      50% { 
        filter: brightness(2.5) saturate(0.3);
        background-position: 100% 50%;
      }
    }
    #hud .muted { color: var(--muted); }
    #help {
      position: fixed;
      right: 12px;
      top: 12px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      padding: 10px 12px;
      border-radius: 10px;
      box-shadow: 0 6px 14px var(--shadow);
      user-select: none;
      font-size: 14px;
      max-width: 360px;
    }
    #help kbd {
      background: #1a1f29;
      border: 1px solid #293140;
      border-bottom-width: 2px;
      padding: 2px 6px;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
    }
    #crystalLegend {
      display: none !important; /* Deprecated - now in pause menu */
    }
    #optionsPanel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, 
        transparent 0%,
        transparent 30%,
        rgba(90, 242, 199, 0.4) 50%,
        transparent 70%,
        transparent 100%
      );
      opacity: 0;
      animation: topShimmer 6s infinite;
    }
    #optionsPanel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: radial-gradient(1200px 700px at 40% 35%, rgba(90,242,199,0.04), transparent),
                  linear-gradient(180deg, rgba(18, 22, 29, 0.45), rgba(15, 19, 25, 0.35));
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 24px 28px;
      border-radius: 14px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25),
                  inset 0 1px 0 rgba(255, 255, 255, 0.05),
                  inset 0 -1px 0 rgba(0, 0, 0, 0.1);
      z-index: 1000;
      /* Match banner sizing for consistency */
      width: min(90vw, 750px);
      height: min(90vh, 650px);
      overflow-y: auto;
      overflow-x: hidden;
      opacity: 0;
      animation: optionsFadeIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
                 glassUnderglow 8s ease-in-out infinite;
    }
    #optionsPanel .tab-container {
      display: flex;
      gap: 12px;
      margin-bottom: 24px;
      border-bottom: 1px solid rgba(90, 242, 199, 0.15);
      padding-bottom: 12px;
      opacity: 0;
      transform: translateY(-20px);
      animation: titleSlideIn 0.6s ease-out 0.3s forwards;
    }
    #optionsPanel .tab-button {
      background: rgba(90, 242, 199, 0.08);
      border: 1px solid rgba(90, 242, 199, 0.2);
      color: var(--muted);
      padding: 10px 20px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      backdrop-filter: blur(8px);
    }
    #optionsPanel .tab-button:hover {
      color: var(--fg);
      background: rgba(90, 242, 199, 0.15);
      border-color: rgba(90, 242, 199, 0.4);
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 8px 20px rgba(90, 242, 199, 0.25);
    }
    #optionsPanel .tab-button.active {
      color: #002e24;
      background: var(--accent);
      border-color: var(--accent);
      box-shadow: 0 8px 24px rgba(90, 242, 199, 0.35),
                  inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }
    #optionsPanel .tab-button.active:hover {
      filter: brightness(1.1);
    }
    #optionsPanel .tab-content {
      display: none;
    }
    #optionsPanel .tab-content.active {
      display: block;
      opacity: 0;
      transform: translateY(20px);
      animation: contentFadeIn 0.5s ease-out 0.5s forwards;
    }
    /* Override controls-panel opacity for options menu */
    #optionsPanel .controls-panel {
      opacity: 1 !important;
      transform: translateY(0) !important;
      animation: none !important;
      background: radial-gradient(ellipse at top, rgba(90, 242, 199, 0.03), transparent),
                  linear-gradient(135deg, rgba(26, 31, 41, 0.6), rgba(18, 22, 29, 0.5));
      border: 1px solid rgba(90, 242, 199, 0.15);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2),
                  inset 0 1px 0 rgba(255, 255, 255, 0.03);
    }
    @keyframes contentFadeIn {
      from { 
        opacity: 0; 
        transform: translateY(20px);
        filter: blur(4px);
      }
      to { 
        opacity: 1; 
        transform: translateY(0);
        filter: blur(0);
      }
    }
    @keyframes optionsFadeIn {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.8) rotate(-1deg); 
        filter: blur(8px); 
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1) rotate(0deg); 
        filter: blur(0px); 
      }
    }
    @keyframes optionsFadeOut {
      0% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1) rotate(0deg); 
        filter: blur(0px); 
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.9) rotate(1deg); 
        filter: blur(4px); 
      }
    }
    #optionsPanel button#optionsBackBtn {
      margin-top: 24px;
      width: 100%;
      background: linear-gradient(135deg, rgba(90, 242, 199, 0.1), rgba(90, 242, 199, 0.05));
      color: var(--accent);
      border: 1px solid rgba(90, 242, 199, 0.3);
      padding: 12px 20px;
      border-radius: 10px;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2),
                  inset 0 1px 0 rgba(255, 255, 255, 0.05);
      opacity: 0;
      transform: translateY(20px) scale(0.9);
      animation: buttonSlideIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.7s forwards;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      backdrop-filter: blur(8px);
    }
    #optionsPanel button#optionsBackBtn:hover {
      background: linear-gradient(135deg, rgba(90, 242, 199, 0.2), rgba(90, 242, 199, 0.1));
      border-color: var(--accent);
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 10px 30px rgba(90, 242, 199, 0.3),
                  inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    #optionsPanel button#optionsBackBtn:active {
      transform: translateY(0) scale(0.98);
    }
    
    /* Custom scrollbar styling for Options panel */
    #optionsPanel::-webkit-scrollbar {
      width: 12px;
    }
    #optionsPanel::-webkit-scrollbar-track {
      background: rgba(18, 22, 29, 0.6);
      border-radius: 6px;
      border: 1px solid rgba(90, 242, 199, 0.1);
    }
    #optionsPanel::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(90, 242, 199, 0.3), rgba(90, 242, 199, 0.15));
      border-radius: 6px;
      border: 1px solid rgba(90, 242, 199, 0.2);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    #optionsPanel::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(90, 242, 199, 0.4), rgba(90, 242, 199, 0.25));
      border-color: rgba(90, 242, 199, 0.3);
    }
    #optionsPanel::-webkit-scrollbar-thumb:active {
      background: linear-gradient(180deg, rgba(90, 242, 199, 0.5), rgba(90, 242, 199, 0.35));
    }
    
    /* Firefox scrollbar */
    #optionsPanel {
      scrollbar-width: thin;
      scrollbar-color: rgba(90, 242, 199, 0.3) rgba(18, 22, 29, 0.6);
    }
    
    /* Also style banner scrollbar for pause menu */
    #banner::-webkit-scrollbar {
      width: 12px;
    }
    #banner::-webkit-scrollbar-track {
      background: rgba(18, 22, 29, 0.6);
      border-radius: 6px;
      border: 1px solid rgba(90, 242, 199, 0.1);
    }
    #banner::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(90, 242, 199, 0.3), rgba(90, 242, 199, 0.15));
      border-radius: 6px;
      border: 1px solid rgba(90, 242, 199, 0.2);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    #banner::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(90, 242, 199, 0.4), rgba(90, 242, 199, 0.25));
      border-color: rgba(90, 242, 199, 0.3);
    }
    #banner::-webkit-scrollbar-thumb:active {
      background: linear-gradient(180deg, rgba(90, 242, 199, 0.5), rgba(90, 242, 199, 0.35));
    }
    #banner {
      scrollbar-width: thin;
      scrollbar-color: rgba(90, 242, 199, 0.3) rgba(18, 22, 29, 0.6);
    }
    /* Crystal and Enemy Legend Styling */
    #optionsPanel .crystal-legend,
    #optionsPanel .enemy-legend {
      padding: 20px !important;
      background: radial-gradient(ellipse at center, rgba(90, 242, 199, 0.02), transparent);
    }
    #optionsPanel .crystal-category,
    #optionsPanel .enemy-category {
      margin-bottom: 16px !important;
      padding: 12px;
      background: linear-gradient(135deg, rgba(18, 22, 29, 0.4), rgba(15, 19, 25, 0.3));
      border-radius: 8px;
      border: 1px solid rgba(90, 242, 199, 0.1);
    }
    #optionsPanel .crystal-category h4,
    #optionsPanel .enemy-category h4 {
      margin: 0 0 12px 0 !important;
      font-size: 14px !important;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    #optionsPanel .crystal-item,
    #optionsPanel .enemy-item {
      padding: 6px 8px;
      margin: 6px 0 !important;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      transition: all 0.2s ease;
      border: 1px solid transparent;
    }
    #optionsPanel .crystal-item:hover,
    #optionsPanel .enemy-item:hover {
      background: rgba(90, 242, 199, 0.05);
      border-color: rgba(90, 242, 199, 0.2);
      transform: translateX(4px);
    }
    #crystalLegend h3 {
      margin: 0 0 8px 0;
      color: var(--accent);
      font-size: 16px;
    }
    .crystal-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
    }
    .crystal-color {
      width: 16px;
      height: 16px;
      border-radius: 2px;
      border: 1px solid rgba(255,255,255,0.3);
      flex-shrink: 0;
    }
    .crystal-name {
      color: var(--fg);
      font-weight: 500;
      min-width: 80px;
    }
    .crystal-desc {
      color: var(--muted);
      font-size: 12px;
      flex-grow: 1;
    }
    #banner::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, 
        transparent 0%,
        transparent 30%,
        rgba(90, 242, 199, 0.4) 50%,
        transparent 70%,
        transparent 100%
      );
      opacity: 0;
      animation: topShimmer 6s infinite;
    }
    
    /* Unified responsive menu system */
    #banner {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: radial-gradient(1200px 700px at 40% 35%, rgba(90,242,199,0.04), transparent),
                  linear-gradient(180deg, rgba(18, 22, 29, 0.45), rgba(15, 19, 25, 0.35));
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 24px 28px;
      border-radius: 14px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25),
                  inset 0 1px 0 rgba(255, 255, 255, 0.05),
                  inset 0 -1px 0 rgba(0, 0, 0, 0.1);
      text-align: center;
      /* Responsive sizing - all menus same size */
      width: min(90vw, 750px);
      height: min(90vh, 650px);
      line-height: 1.5;
      opacity: 0;
      overflow-y: auto;
      overflow-x: hidden;
      animation: menuFadeIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
                 glassUnderglow 8s ease-in-out infinite;
    }
    #banner h1 {
      margin: 0 0 10px 0; 
      letter-spacing: 0.3px;
      opacity: 0;
      transform: translateY(-20px);
      animation: titleSlideIn 0.6s ease-out 0.3s forwards;
      white-space: nowrap;
      overflow: visible;
    }
    #banner .sub { 
      color: var(--muted); 
      margin-bottom: 16px;
      opacity: 0;
      transform: translateY(-15px);
      animation: subtitleSlideIn 0.5s ease-out 0.5s forwards;
    }
    #banner button {
      background: var(--accent);
      color: #002e24;
      border: none;
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 8px 16px rgba(90,242,199,0.25);
      opacity: 0;
      transform: translateY(20px) scale(0.9);
      animation: buttonSlideIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.7s forwards;
      transition: all 0.3s ease;
    }
    #banner button:hover { 
      filter: brightness(1.05);
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 12px 24px rgba(90,242,199,0.4);
    }
    #banner button:active {
      transform: translateY(0px) scale(0.98);
    }
    #banner button + button {
      margin-top: 12px;
      background: linear-gradient(135deg, rgba(90, 242, 199, 0.15), rgba(90, 242, 199, 0.08));
      color: var(--accent);
      border: 1px solid rgba(90, 242, 199, 0.3);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2),
                  inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }
    #banner button + button:hover {
      background: linear-gradient(135deg, rgba(90, 242, 199, 0.25), rgba(90, 242, 199, 0.15));
      border-color: var(--accent);
      filter: none;
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 10px 24px rgba(90, 242, 199, 0.3);
    }
    .controls-panel {
      margin: 16px 0;
      padding: 16px;
      background: linear-gradient(135deg, rgba(26, 31, 41, 0.9), rgba(18, 22, 29, 0.8));
      border-radius: 10px;
      border: 1px solid rgba(90, 242, 199, 0.2);
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      opacity: 0;
      transform: translateY(30px);
      animation: controlsSlideIn 0.6s ease-out 0.9s forwards;
    }
    .controls-panel .controls-title {
      margin-bottom: 12px;
      color: var(--accent);
      font-size: 16px;
      text-align: center;
    }
    .controls-panel .control-row {
      display: flex;
      align-items: center;
      margin: 8px 0;
      padding: 6px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .controls-panel .control-row:last-child {
      border-bottom: none;
    }
    .controls-panel .control-keys {
      display: inline-flex;
      gap: 4px;
      min-width: 120px;
    }
    .controls-panel .control-desc {
      color: var(--fg);
      font-weight: 500;
    }
    .controls-panel kbd {
      background: linear-gradient(135deg, #2a3441, #1f2733);
      border: 1px solid rgba(90, 242, 199, 0.3);
      border-bottom: 2px solid rgba(90, 242, 199, 0.4);
      padding: 4px 8px;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
      font-weight: 600;
      color: var(--accent);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    .controls-panel .mobile-note {
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 12px;
      text-align: center;
      color: var(--muted);
    }
    /* Tab system for pause menu */
    .tab-container {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      justify-content: center;
    }
    .tab-button {
      padding: 8px 16px;
      background: rgba(26, 31, 41, 0.7);
      border: 1px solid rgba(90, 242, 199, 0.3);
      border-radius: 6px;
      color: var(--muted);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 14px;
      line-height: 1;
      display: inline-block;
      vertical-align: middle;
      box-sizing: border-box;
      height: auto;
    }
    .tab-button.active {
      background: rgba(90, 242, 199, 0.2);
      color: var(--accent);
      border-color: var(--accent);
    }
    .tab-button:hover:not(.active) {
      background: rgba(90, 242, 199, 0.15);
      color: var(--fg);
    }

    /* CRITICAL FIX: Pause menu specific button styles with HIGHER SPECIFICITY */
    #banner .tab-button {
      background: rgba(0, 0, 0, 0.5) !important;
      color: var(--muted) !important;
      border: 1px solid var(--border) !important;
      transition: all 0.2s !important;
      padding: 8px 16px !important;
      margin: 0 !important;
      font-weight: 400 !important;
      font-style: normal !important;
      text-decoration: none !important;
      animation: none !important;
      opacity: 1 !important;
      transform: none !important;
      border-radius: 6px !important;
      box-shadow: none !important;
      box-sizing: border-box !important;
      font-size: 14px !important;
      line-height: 1 !important;
      height: 34px !important;
      min-height: 34px !important;
      max-height: 34px !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
      vertical-align: middle !important;
    }
    #banner .tab-button.active {
      background: rgba(90, 242, 199, 0.3) !important;
      color: var(--accent) !important;
      border-color: var(--accent) !important;
      box-shadow: 0 0 20px rgba(90, 242, 199, 0.4),
                  inset 0 0 10px rgba(90, 242, 199, 0.2) !important;
      height: 34px !important;
      min-height: 34px !important;
      max-height: 34px !important;
    }
    #banner .tab-button:hover:not(.active) {
      background: rgba(90, 242, 199, 0.15);
      color: var(--text);
      transform: translateY(-1px);
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    /* Enemy and Crystal legend styles */
    .enemy-legend,
    .crystal-legend {
      max-height: 400px;
      overflow-y: auto;
      padding-right: 8px;
    }
    .enemy-legend::-webkit-scrollbar,
    .crystal-legend::-webkit-scrollbar {
      width: 6px;
    }
    .enemy-legend::-webkit-scrollbar-track,
    .crystal-legend::-webkit-scrollbar-track {
      background: rgba(26, 31, 41, 0.5);
      border-radius: 3px;
    }
    .enemy-legend::-webkit-scrollbar-thumb,
    .crystal-legend::-webkit-scrollbar-thumb {
      background: rgba(90, 242, 199, 0.5);
      border-radius: 3px;
    }
    .enemy-category {
      margin-bottom: 16px;
    }
    .enemy-category h4 {
      color: var(--accent);
      margin: 0 0 8px 0;
      font-size: 14px;
      border-bottom: 1px solid rgba(90, 242, 199, 0.3);
      padding-bottom: 4px;
    }
    .enemy-entry {
      display: flex;
      align-items: center;
      margin: 6px 0;
      padding: 4px;
      background: rgba(18, 22, 29, 0.4);
      border-radius: 4px;
    }
    .enemy-icon {
      width: 30px;
      height: 30px;
      margin-right: 12px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      font-size: 16px;
    }
    .enemy-preview-canvas {
      margin-right: 12px;
      border-radius: 4px;
      background: #222;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
      width: 80px;
      height: 80px;
      flex-shrink: 0;
    }
    .enemy-info {
      flex: 1;
    }
    .enemy-name {
      font-weight: 600;
      color: var(--fg);
      font-size: 13px;
    }
    .enemy-desc {
      font-size: 11px;
      color: var(--muted);
      margin-top: 2px;
    }
    .stat-value {
      margin-left: 4px;
    }
    #gameOver::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, 
        transparent 0%,
        transparent 30%,
        rgba(255, 91, 110, 0.4) 50%,
        transparent 70%,
        transparent 100%
      );
      opacity: 0;
      animation: topShimmer 6s infinite;
    }
    
    #gameOver {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      display: none;
      background: linear-gradient(180deg, rgba(18, 22, 29, 0.45), rgba(15, 19, 25, 0.35));
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 30px 40px;
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25),
                  inset 0 1px 0 rgba(255, 255, 255, 0.05),
                  inset 0 -1px 0 rgba(0, 0, 0, 0.1);
      text-align: center;
      /* Expanded to fit enhanced stats with scrolling */
      width: min(90vw, 520px);
      max-height: 85vh;
      line-height: 1.4;
      opacity: 0;
      overflow-y: auto;
      overflow-x: hidden;
    }
    #gameOver.active {
      animation: glassUnderglow 8s ease-in-out infinite;
    }
    #gameOver h2 {
      margin: 0 0 20px 0;
      font-size: 48px;
      color: var(--danger);
    }
    #gameOver > div {
      font-size: 20px;
      margin-bottom: 30px;
      color: var(--fg);
    }
    #gameOver button {
      margin-top: 20px;
      background: var(--accent);
      color: #002e24;
      border: none;
      padding: 16px 40px;
      border-radius: 12px;
      font-weight: 700;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(90, 242, 199, 0.3);
    }
    #gameOver button:hover {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 6px 16px rgba(90,242,199,0.4);
    }
    #gameOver button:active {
      transform: translateY(0px) scale(0.98);
    }
    #fps {
      position: fixed;
      bottom: 10px; right: 12px;
      font-size: 11px;
      color: var(--muted);
      background: #0f1319ee;
      padding: 6px 10px;
      border-radius: 6px;
      user-select: none;
      font-family: 'Courier New', monospace;
      line-height: 1.4;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      backdrop-filter: blur(4px);
    }
    #powerupNotification {
      position: fixed;
      top: 180px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(18, 22, 29, 0.25), rgba(15, 19, 25, 0.25));
      border: 2px solid rgba(90, 242, 199, 0.3);
      padding: 15px 25px;
      border-radius: 8px;
      box-shadow: 
        0 8px 24px rgba(0,0,0,0.2),
        0 0 30px rgba(90,242,199,0.5),
        0 0 60px rgba(255,91,110,0.3),
        0 0 90px rgba(52,209,255,0.2),
        0 0 120px rgba(255,209,102,0.15);
      font-size: 24px;
      font-weight: 700;
      text-align: center;
      color: var(--accent);
      text-shadow: 0 0 8px rgba(90,242,199,0.6);
      letter-spacing: 1px;
      display: none;
      z-index: 1000;
      animation: powerupPulse 3s ease-out forwards, crystalRainbowGlow 2s ease-in-out infinite;
      pointer-events: none;
      user-select: none;
    }
    
    @keyframes crystalRainbowGlow {
      0%, 100% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 40px rgba(90,242,199,0.6),
          0 0 80px rgba(255,91,110,0.4),
          0 0 120px rgba(52,209,255,0.3);
      }
      25% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 40px rgba(255,91,110,0.6),
          0 0 80px rgba(52,209,255,0.4),
          0 0 120px rgba(255,209,102,0.3);
      }
      50% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 40px rgba(52,209,255,0.6),
          0 0 80px rgba(255,209,102,0.4),
          0 0 120px rgba(90,242,199,0.3);
      }
      75% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 40px rgba(255,209,102,0.6),
          0 0 80px rgba(90,242,199,0.4),
          0 0 120px rgba(255,91,110,0.3);
      }
    }
    #waveAnnouncement {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%) scale(1);
      background: linear-gradient(135deg, rgba(18, 22, 29, 0.25), rgba(15, 19, 25, 0.25));
      border: 2px solid rgba(90, 242, 199, 0.3);
      padding: 15px 25px;
      border-radius: 8px;
      box-shadow: 
        0 8px 24px rgba(0,0,0,0.2), 
        0 0 30px rgba(90,242,199,0.4),
        0 0 60px rgba(255,91,110,0.3),
        0 0 90px rgba(52,209,255,0.2),
        0 0 120px rgba(255,209,102,0.15);
      text-align: center;
      color: var(--accent);
      display: none;
      z-index: 1001;
      /* opacity handled by animation, not default CSS */
      backdrop-filter: blur(4px);
      pointer-events: none;
      user-select: none;
      min-width: 180px;
      animation: rainbowGlow 3s ease-in-out infinite;
    }
    
    @keyframes rainbowGlow {
      0%, 100% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 30px rgba(90,242,199,0.5),
          0 0 60px rgba(255,91,110,0.3),
          0 0 90px rgba(52,209,255,0.2);
      }
      25% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 30px rgba(255,91,110,0.5),
          0 0 60px rgba(52,209,255,0.3),
          0 0 90px rgba(255,209,102,0.2);
      }
      50% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 30px rgba(52,209,255,0.5),
          0 0 60px rgba(255,209,102,0.3),
          0 0 90px rgba(90,242,199,0.2);
      }
      75% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 30px rgba(255,209,102,0.5),
          0 0 60px rgba(90,242,199,0.3),
          0 0 90px rgba(255,91,110,0.2);
      }
    }
    #waveAnnouncement .wave-number {
      font-size: 24px;
      font-weight: 700;
      text-shadow: 0 0 8px rgba(90,242,199,0.8);
      margin-bottom: 4px;
      letter-spacing: 1px;
      line-height: 1;
    }
    #waveAnnouncement .wave-subtitle {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      text-shadow: 0 0 4px rgba(90,242,199,0.4);
      margin-top: 2px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    #waveAnnouncement.boss-wave {
      border-color: rgba(255, 68, 68, 0.3);
      background: linear-gradient(135deg, rgba(18, 22, 29, 0.25), rgba(25, 15, 15, 0.25));
      animation: bossRainbowGlow 2s ease-in-out infinite;
    }
    
    @keyframes bossRainbowGlow {
      0%, 100% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 40px rgba(255,68,68,0.6),
          0 0 80px rgba(255,91,110,0.4),
          0 0 120px rgba(255,209,102,0.2);
      }
      50% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 40px rgba(255,91,110,0.6),
          0 0 80px rgba(255,68,68,0.4),
          0 0 120px rgba(52,209,255,0.2);
      }
    }
    #waveAnnouncement.boss-wave .wave-number {
      color: #ff4444;
      text-shadow: 0 0 8px rgba(255,68,68,0.8);
    }
    #powerupDialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(180deg, rgba(18, 22, 29, 0.25), rgba(15, 19, 25, 0.25));
      border: 3px solid rgba(90, 242, 199, 0.4);
      padding: 24px 28px;
      border-radius: 16px;
      box-shadow: 
        0 16px 48px rgba(0,0,0,0.3),
        0 0 40px rgba(90,242,199,0.5),
        0 0 80px rgba(255,91,110,0.3),
        0 0 120px rgba(52,209,255,0.2),
        0 0 160px rgba(255,209,102,0.15);
      display: none;
      z-index: 2000;
      max-width: 600px;
      text-align: center;
      opacity: 0;
      pointer-events: none;
      user-select: none;
      animation: upgradeRainbowGlow 2.5s ease-in-out infinite;
    }
    
    @keyframes upgradeRainbowGlow {
      0%, 100% {
        box-shadow: 
          0 16px 48px rgba(0,0,0,0.3),
          0 0 50px rgba(90,242,199,0.6),
          0 0 100px rgba(255,91,110,0.4),
          0 0 150px rgba(52,209,255,0.3),
          0 0 200px rgba(255,209,102,0.2);
        border-color: rgba(90, 242, 199, 0.5);
      }
      25% {
        box-shadow: 
          0 16px 48px rgba(0,0,0,0.3),
          0 0 50px rgba(255,91,110,0.6),
          0 0 100px rgba(52,209,255,0.4),
          0 0 150px rgba(255,209,102,0.3),
          0 0 200px rgba(90,242,199,0.2);
        border-color: rgba(255, 91, 110, 0.5);
      }
      50% {
        box-shadow: 
          0 16px 48px rgba(0,0,0,0.3),
          0 0 50px rgba(52,209,255,0.6),
          0 0 100px rgba(255,209,102,0.4),
          0 0 150px rgba(90,242,199,0.3),
          0 0 200px rgba(255,91,110,0.2);
        border-color: rgba(52, 209, 255, 0.5);
      }
      75% {
        box-shadow: 
          0 16px 48px rgba(0,0,0,0.3),
          0 0 50px rgba(255,209,102,0.6),
          0 0 100px rgba(90,242,199,0.4),
          0 0 150px rgba(255,91,110,0.3),
          0 0 200px rgba(52,209,255,0.2);
        border-color: rgba(255, 209, 102, 0.5);
      }
    }
    #powerupDialog h2 {
      margin: 0 0 16px 0;
      color: var(--accent);
      font-size: 24px;
      text-shadow: 0 0 8px rgba(90,242,199,0.6);
    }
    .powerup-options {
      display: flex;
      gap: 16px;
      justify-content: center;
      margin-top: 20px;
    }
    .powerup-option {
      background: linear-gradient(180deg, #1a1f29, #0f1319);
      border: 2px solid #293140;
      border-radius: 12px;
      padding: 16px 12px;
      cursor: pointer;
      min-width: 160px;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      opacity: 0;
      transform: translateY(20px) scale(0.9);
      pointer-events: auto;
    }
    .powerup-option.animate-in {
      opacity: 1;
      transform: translateY(0px) scale(1);
    }
    .powerup-option:hover {
      border-color: var(--accent);
      box-shadow: 0 8px 24px rgba(90,242,199,0.4);
      transform: translateY(-4px) scale(1.05);
    }
    .powerup-option:active {
      transform: translateY(-2px) scale(0.98);
    }
    .powerup-option.selected {
      animation: powerupSelected 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
      border-color: #FFD700;
      box-shadow: 0 8px 32px rgba(255, 215, 0, 0.6);
    }
    .powerup-option h3 {
      margin: 0 0 8px 0;
      color: var(--accent);
      font-size: 16px;
    }
    .powerup-option p {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.3;
    }
    @keyframes powerupPulse {
      0% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.5) rotate(-3deg); 
        filter: blur(6px);
      }
      8% { 
        opacity: 0.9; 
        transform: translateX(-50%) scale(1.2) rotate(1deg); 
        filter: blur(1px);
      }
      15% { 
        opacity: 1; 
        transform: translateX(-50%) scale(0.95) rotate(-0.5deg); 
        filter: blur(0px);
      }
      25% { 
        transform: translateX(-50%) scale(1.05) rotate(0deg); 
      }
      35% { 
        transform: translateX(-50%) scale(1) rotate(0deg); 
      }
      90% { 
        opacity: 1; 
        transform: translateX(-50%) scale(1) rotate(0deg); 
      }
      100% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.8) rotate(1deg); 
        filter: blur(3px);
      }
    }
    canvas { display: block; }
    .edge-warning {
      position: fixed;
      background: rgba(255, 91, 110, 0.5);
      pointer-events: none;
      z-index: 100;
      animation: pulse 0.5s ease-in-out infinite alternate;
    }
    .edge-warning.top { top: 0; left: 0; right: 0; height: 16px; }
    .edge-warning.bottom { bottom: 0; left: 0; right: 0; height: 16px; }
    .edge-warning.left { left: 0; top: 0; bottom: 0; width: 16px; }
    .edge-warning.right { right: 0; top: 0; bottom: 0; width: 16px; }
    
    /* Main Menu Animations */
    @keyframes menuFadeIn {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.8) rotate(-1deg); 
        filter: blur(8px); 
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1) rotate(0deg); 
        filter: blur(0px); 
      }
    }
    @keyframes titleSlideIn {
      0% { 
        opacity: 0; 
        transform: translateY(-20px); 
        filter: blur(4px); 
      }
      100% { 
        opacity: 1; 
        transform: translateY(0px); 
        filter: blur(0px); 
      }
    }
    @keyframes subtitleSlideIn {
      0% { 
        opacity: 0; 
        transform: translateY(-15px); 
        filter: blur(2px); 
      }
      100% { 
        opacity: 1; 
        transform: translateY(0px); 
        filter: blur(0px); 
      }
    }
    @keyframes buttonSlideIn {
      0% { 
        opacity: 0; 
        transform: translateY(20px) scale(0.9); 
        filter: blur(2px); 
      }
      100% { 
        opacity: 1; 
        transform: translateY(0px) scale(1); 
        filter: blur(0px); 
      }
    }
    @keyframes controlsSlideIn {
      0% { 
        opacity: 0; 
        transform: translateY(30px); 
        filter: blur(2px); 
      }
      100% { 
        opacity: 1; 
        transform: translateY(0px); 
        filter: blur(0px); 
      }
    }
    
    /* Pause Menu Animations */
    @keyframes pauseSlideIn {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.9); 
        filter: blur(6px); 
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
    }
    @keyframes pauseSlideOut {
      0% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(1.1); 
        filter: blur(4px); 
      }
    }
    
    /* Game Over Animations */
    @keyframes gameOverDramaticEntry {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.5) rotate(-5deg); 
        filter: blur(10px); 
      }
      50% { 
        opacity: 0.8; 
        transform: translate(-50%, -50%) scale(1.1) rotate(2deg); 
        filter: blur(2px); 
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1) rotate(0deg); 
        filter: blur(0px); 
      }
    }
    @keyframes gameOverSlideOut {
      0% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.8); 
        filter: blur(6px); 
      }
    }
    
    /* Trippy Shockwave Reality Ripple Effect */
    @keyframes psychedelicRipple {
      0% {
        width: 10px;
        height: 10px;
        transform: translate(-50%, -50%) rotate(0deg);
        opacity: 0;
        filter: hue-rotate(0deg) blur(0px);
      }
      10% {
        width: 100px;
        height: 100px;
        transform: translate(-50%, -50%) rotate(36deg);
        opacity: 1;
        filter: hue-rotate(60deg) blur(0px);
      }
      30% {
        width: 300px;
        height: 300px;
        transform: translate(-50%, -50%) rotate(120deg);
        opacity: 0.9;
        filter: hue-rotate(180deg) blur(1px);
      }
      50% {
        width: 600px;
        height: 600px;
        transform: translate(-50%, -50%) rotate(180deg);
        opacity: 0.7;
        filter: hue-rotate(270deg) blur(2px);
      }
      70% {
        width: 900px;
        height: 900px;
        transform: translate(-50%, -50%) rotate(270deg);
        opacity: 0.4;
        filter: hue-rotate(360deg) blur(4px);
      }
      100% {
        width: 1500px;
        height: 1500px;
        transform: translate(-50%, -50%) rotate(360deg);
        opacity: 0;
        filter: hue-rotate(420deg) blur(10px);
      }
    }
    
    @keyframes realityTear {
      0% {
        clip-path: polygon(50% 50%, 50% 50%, 50% 50%, 50% 50%);
        transform: rotate(0deg) scale(0);
        filter: saturate(5) contrast(3);
      }
      25% {
        clip-path: polygon(45% 45%, 55% 45%, 55% 55%, 45% 55%);
        transform: rotate(90deg) scale(0.5);
      }
      50% {
        clip-path: polygon(30% 30%, 70% 30%, 70% 70%, 30% 70%);
        transform: rotate(180deg) scale(1);
        filter: saturate(2) contrast(1.5) brightness(1.5);
      }
      75% {
        clip-path: polygon(10% 10%, 90% 10%, 90% 90%, 10% 90%);
        transform: rotate(270deg) scale(1.5);
      }
      100% {
        clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
        transform: rotate(360deg) scale(2);
        filter: saturate(1) contrast(1) brightness(1);
        opacity: 0;
      }
    }
    
    @keyframes chromaShift {
      0%, 100% { filter: hue-rotate(0deg) saturate(3); }
      25% { filter: hue-rotate(90deg) saturate(4); }
      50% { filter: hue-rotate(180deg) saturate(5); }
      75% { filter: hue-rotate(270deg) saturate(4); }
    }
    
    @keyframes screenShake {
      0%, 100% { transform: translate(0, 0); }
      10% { transform: translate(-2px, 2px); }
      20% { transform: translate(2px, -2px); }
      30% { transform: translate(-2px, -2px); }
      40% { transform: translate(2px, 2px); }
      50% { transform: translate(-1px, 1px); }
      60% { transform: translate(1px, -1px); }
      70% { transform: translate(-1px, -1px); }
      80% { transform: translate(1px, 1px); }
      90% { transform: translate(0, 0); }
    }
    
    @keyframes warpGrid {
      0% {
        transform: perspective(1000px) rotateX(0deg) rotateZ(0deg) scale(1);
        background-position: 0 0, 0 0, 0 0, 0 0;
        opacity: 0;
        filter: blur(0px);
      }
      10% {
        transform: perspective(1000px) rotateX(60deg) rotateZ(10deg) scale(1.5);
        opacity: 1;
        filter: blur(0px);
      }
      25% {
        transform: perspective(1000px) rotateX(-30deg) rotateZ(-5deg) scale(0.8);
        background-position: -10px -10px, 10px 10px, -20px 20px, 20px -20px;
        opacity: 0.9;
      }
      50% {
        transform: perspective(1000px) rotateX(45deg) rotateZ(180deg) scale(1.2);
        background-position: 20px 20px, -20px -20px, 40px -40px, -40px 40px;
        opacity: 0.7;
        filter: blur(1px);
      }
      75% {
        transform: perspective(1000px) rotateX(-60deg) rotateZ(270deg) scale(1.8);
        background-position: -5px -5px, 5px 5px, -10px 10px, 10px -10px;
        opacity: 0.4;
        filter: blur(2px);
      }
      100% {
        transform: perspective(1000px) rotateX(0deg) rotateZ(360deg) scale(3);
        background-position: 50px 50px, -50px -50px, 100px -100px, -100px 100px;
        opacity: 0;
        filter: blur(5px);
      }
    }
    
    .game-start-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 999;
      opacity: 0;
      overflow: hidden;
      background: radial-gradient(ellipse at center, transparent 0%, rgba(11,13,16,0.4) 100%);
    }
    
    .ripple-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100vw;
      height: 100vh;
      z-index: 2;
      pointer-events: none;
    }
    
    .ripple {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 10px;
      height: 10px;
      border-radius: 50%;
      opacity: 0;
      background: transparent;
    }
    
    .ripple1 {
      border: 8px solid rgba(90,242,199,0.9);
      box-shadow: 
        0 0 40px rgba(90,242,199,0.8),
        inset 0 0 40px rgba(90,242,199,0.4);
      animation: psychedelicRipple 1.5s ease-out;
    }
    
    .ripple2 {
      border: 6px solid rgba(255,91,110,0.9);
      box-shadow: 
        0 0 40px rgba(255,91,110,0.8),
        inset 0 0 40px rgba(255,91,110,0.4);
      animation: psychedelicRipple 1.5s ease-out 0.2s;
    }
    
    .ripple3 {
      border: 4px solid rgba(52,209,255,0.9);
      box-shadow: 
        0 0 40px rgba(52,209,255,0.8),
        inset 0 0 40px rgba(52,209,255,0.4);
      animation: psychedelicRipple 1.5s ease-out 0.4s;
    }
    
    .ripple4 {
      border: 10px solid rgba(255,209,102,0.9);
      box-shadow: 
        0 0 40px rgba(255,209,102,0.8),
        inset 0 0 40px rgba(255,209,102,0.4);
      animation: psychedelicRipple 1.5s ease-out 0.6s;
    }
    
    .reality-tear {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, 
        rgba(90,242,199,0.3) 0%, 
        rgba(255,91,110,0.3) 25%, 
        rgba(52,209,255,0.3) 50%, 
        rgba(255,209,102,0.3) 75%, 
        rgba(90,242,199,0.3) 100%);
      animation: realityTear 1.8s ease-in-out;
      mix-blend-mode: screen;
      opacity: 0.6;
      pointer-events: none;
    }
    
    .warp-grid {
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background-image: 
        linear-gradient(rgba(90,242,199,0.6) 2px, transparent 2px),
        linear-gradient(90deg, rgba(90,242,199,0.6) 2px, transparent 2px),
        linear-gradient(45deg, rgba(255,91,110,0.3) 1px, transparent 1px),
        linear-gradient(-45deg, rgba(52,209,255,0.3) 1px, transparent 1px);
      background-size: 50px 50px, 50px 50px, 100px 100px, 100px 100px;
      animation: warpGrid 1.8s ease-out;
      transform-origin: center center;
      pointer-events: none;
      overflow: hidden;
    }
    
    /* Powerup Selection Animations */
    @keyframes powerupSelected {
      0% { 
        transform: translateY(-4px) scale(1.05);
      }
      20% { 
        transform: translateY(-12px) scale(1.15) rotate(2deg);
        filter: brightness(1.3);
      }
      50% { 
        transform: translateY(-8px) scale(1.2) rotate(-1deg);
        filter: brightness(1.5);
      }
      80% { 
        transform: translateY(-4px) scale(1.1) rotate(0deg);
        filter: brightness(1.2);
      }
      100% { 
        transform: translateY(-4px) scale(1.05);
        filter: brightness(1);
      }
    }
    
    @keyframes powerupDialogEntry {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.8); 
        filter: blur(6px); 
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
    }
    @keyframes powerupDialogExit {
      0% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(1.1); 
        filter: blur(4px); 
      }
    }
    
    /* Wave Card Animations */
    @keyframes waveCardEntry {
      0% { 
        opacity: 0; 
        transform: translateX(-50%) translateY(-30px) scale(0.5);
        filter: blur(4px);
      }
      10% { 
        opacity: 0.7; 
        transform: translateX(-50%) translateY(-5px) scale(1.1);
        filter: blur(1px);
      }
      25% { 
        opacity: 1; 
        transform: translateX(-50%) translateY(2px) scale(0.95);
        filter: blur(0px);
      }
      40% { 
        transform: translateX(-50%) translateY(-1px) scale(1.02);
      }
      60% { 
        transform: translateX(-50%) translateY(1px) scale(0.99);
      }
      100% { 
        transform: translateX(-50%) translateY(0) scale(1);
      }
    }
    
    @keyframes waveCardExit {
      0% { 
        opacity: 1; 
        transform: translateX(-50%) scale(1);
      }
      100% { 
        opacity: 0; 
        transform: translateX(-50%) translateY(-20px) scale(0.8);
        filter: blur(4px);
      }
    }
    
    /* Enhanced Wave Announcements */
    @keyframes waveDramaticEntry {
      0% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.3) rotateY(90deg); 
        filter: blur(10px);
      }
      30% { 
        opacity: 0.8; 
        transform: translateX(-50%) scale(1.3) rotateY(-10deg); 
        filter: blur(2px);
      }
      60% { 
        opacity: 1; 
        transform: translateX(-50%) scale(0.9) rotateY(5deg); 
        filter: blur(0px);
      }
      80% { 
        transform: translateX(-50%) scale(1.1) rotateY(-2deg); 
      }
      90% { 
        transform: translateX(-50%) scale(1) rotateY(0deg); 
      }
      95% { 
        opacity: 1; 
        transform: translateX(-50%) scale(1) rotateY(0deg); 
      }
      100% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.7) rotateY(-5deg); 
        filter: blur(4px);
      }
    }
    
    @keyframes bossWaveEntry {
      0% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.2); 
        filter: blur(15px) hue-rotate(0deg);
        background: linear-gradient(180deg, rgba(255, 0, 0, 0.9), rgba(139, 0, 0, 0.8));
      }
      15% { 
        opacity: 0.9; 
        transform: translateX(-50%) scale(1.5); 
        filter: blur(3px) hue-rotate(180deg);
      }
      30% { 
        opacity: 1; 
        transform: translateX(-50%) scale(0.8); 
        filter: blur(0px) hue-rotate(360deg);
      }
      50% { 
        transform: translateX(-50%) scale(1.2); 
      }
      70% { 
        transform: translateX(-50%) scale(1); 
      }
      90% { 
        opacity: 1; 
        transform: translateX(-50%) scale(1); 
      }
      100% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.5); 
        filter: blur(8px);
      }
    }

    /* Flashy Game Title Animations */
    .game-title {
      font-size: 42px !important;
      font-weight: 900;
      margin-bottom: 12px !important;
      text-transform: uppercase;
      position: relative;
      display: block;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      text-align: center;
      transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .title-letter {
      display: inline-block;
      background: linear-gradient(90deg, #ff00ff, #00ffff, #ffff00, #ff00ff);
      background-size: 300% 300%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: 
        epicRainbow 2s linear infinite,
        letterFloat 3s ease-in-out infinite,
        letterGlow 2s ease-in-out infinite alternate;
      position: relative;
      transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .title-space {
      display: inline-block;
      width: 0.3em;
    }
    
    /* Individual letter animations with delays */
    .title-letter:nth-child(1) { animation-delay: 0s; }
    .title-letter:nth-child(2) { animation-delay: 0.1s; }
    .title-letter:nth-child(3) { animation-delay: 0.2s; }
    .title-letter:nth-child(4) { animation-delay: 0.3s; }
    .title-letter:nth-child(5) { animation-delay: 0.4s; }
    .title-letter:nth-child(6) { animation-delay: 0.5s; }
    .title-letter:nth-child(7) { animation-delay: 0.6s; }
    .title-letter:nth-child(8) { animation-delay: 0.7s; }
    .title-letter:nth-child(10) { animation-delay: 0.8s; }
    .title-letter:nth-child(11) { animation-delay: 0.9s; }
    .title-letter:nth-child(12) { animation-delay: 1.0s; }
    .title-letter:nth-child(13) { animation-delay: 1.1s; }
    .title-letter:nth-child(14) { animation-delay: 1.2s; }
    .title-letter:nth-child(15) { animation-delay: 1.3s; }
    
    /* Hover effects */
    .game-title:hover {
      transform: scale(1.1);
    }
    
    .game-title:hover .title-letter {
      animation: 
        epicRainbow 0.3s linear infinite,
        letterDance 0.5s ease-in-out infinite,
        letterGlowIntense 0.3s ease-in-out infinite alternate;
      filter: drop-shadow(0 0 15px currentColor);
    }
    
    .game-title:hover .title-letter:nth-child(odd) {
      animation-direction: reverse;
    }

    @keyframes epicRainbow {
      0% { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }
    
    @keyframes titleBounce {
      0%, 100% { transform: translateY(-20px) scale(1) rotateZ(0deg); }
      25% { transform: translateY(-25px) scale(1.02) rotateZ(1deg); }
      50% { transform: translateY(-20px) scale(1) rotateZ(0deg); }
      75% { transform: translateY(-15px) scale(1.02) rotateZ(-1deg); }
    }
    
    @keyframes glowPulse {
      0% { 
        filter: drop-shadow(0 0 10px rgba(255, 0, 255, 0.6))
                drop-shadow(0 0 20px rgba(0, 255, 255, 0.4));
      }
      100% { 
        filter: drop-shadow(0 0 25px rgba(255, 255, 0, 0.8))
                drop-shadow(0 0 40px rgba(255, 0, 255, 0.6))
                drop-shadow(0 0 60px rgba(0, 255, 255, 0.4));
      }
    }
    
    @keyframes letterFloat {
      0%, 100% { 
        transform: translateY(0px) rotateZ(0deg);
      }
      25% { 
        transform: translateY(-5px) rotateZ(-2deg);
      }
      50% { 
        transform: translateY(0px) rotateZ(0deg);
      }
      75% { 
        transform: translateY(-3px) rotateZ(2deg);
      }
    }
    
    @keyframes letterGlow {
      0% { 
        filter: drop-shadow(0 0 5px rgba(255, 0, 255, 0.6));
        transform: scale(1);
      }
      100% { 
        filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.9));
        transform: scale(1.05);
      }
    }
    
    @keyframes letterDance {
      0%, 100% { 
        transform: translateY(0px) rotateZ(0deg) scale(1);
      }
      25% { 
        transform: translateY(-10px) rotateZ(-5deg) scale(1.2);
      }
      50% { 
        transform: translateY(5px) rotateZ(5deg) scale(0.9);
      }
      75% { 
        transform: translateY(-5px) rotateZ(-3deg) scale(1.1);
      }
    }
    
    @keyframes letterGlowIntense {
      0% { 
        filter: drop-shadow(0 0 10px rgba(255, 0, 255, 0.9))
                drop-shadow(0 0 20px rgba(255, 255, 0, 0.7));
      }
      100% { 
        filter: drop-shadow(0 0 25px rgba(0, 255, 255, 1))
                drop-shadow(0 0 40px rgba(255, 0, 255, 0.8));
      }
    }

    .game-subtitle {
      font-size: 16px;
      color: #5af2c7;
      font-weight: 600;
      text-shadow: 0 0 10px rgba(90, 242, 199, 0.5);
      animation: subtitleGlow 2.5s ease-in-out infinite alternate;
      letter-spacing: 1px;
    }

    @keyframes subtitleGlow {
      0% { 
        opacity: 0.8;
        text-shadow: 0 0 10px rgba(90, 242, 199, 0.5);
      }
      100% { 
        opacity: 1;
        text-shadow: 0 0 20px rgba(90, 242, 199, 0.8), 0 0 30px rgba(90, 242, 199, 0.4);
      }
    }
    
    /* Mobile Touch Zones Visual Indicators */
    #touchZones {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 450;
      display: none;
    }
    
    .touch-zone {
      position: absolute;
      border: 2px dashed rgba(90, 242, 199, 0.3);
      background: rgba(90, 242, 199, 0.05);
      pointer-events: none;
    }
    
    .touch-zone.left {
      left: 0;
      top: 0;
      width: 50%;
      height: 100%;
      border-right: 2px solid rgba(90, 242, 199, 0.3);
    }
    
    .touch-zone.right {
      right: 0;
      top: 0;
      width: 50%;
      height: 100%;
    }
    
    .touch-indicator {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: 3px solid rgba(90, 242, 199, 0.6);
      background: radial-gradient(circle, rgba(90, 242, 199, 0.3), transparent);
      pointer-events: none;
      display: none;
      transform: translate(-50%, -50%);
    }
    
    .touch-indicator.active {
      display: block;
      animation: touchPulse 0.3s ease-out;
    }
    
    @keyframes touchPulse {
      0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
    }
    
    /* Landscape Orientation Lock Message */
    #orientationWarning {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #0b0d10 0%, #12161d 100%);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      flex-direction: column;
      gap: 30px;
      padding: 40px;
      text-align: center;
    }
    
    #orientationWarning.show {
      display: flex !important;
    }
    
    .rotate-icon {
      width: 120px;
      height: 80px;
      border: 3px solid var(--accent);
      border-radius: 15px;
      position: relative;
      animation: rotatePhone 2s ease-in-out infinite;
      background: rgba(90, 242, 199, 0.1);
    }
    
    .rotate-icon::before {
      content: '📱';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
    }
    
    .rotate-icon::after {
      content: '↻';
      position: absolute;
      bottom: -35px;
      right: -35px;
      font-size: 32px;
      color: var(--accent);
      animation: spin 2s linear infinite;
    }
    
    @keyframes rotatePhone {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(90deg); }
    }
    
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .orientation-message {
      font-size: 28px;
      color: var(--fg);
      font-weight: 600;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    
    .orientation-submessage {
      font-size: 18px;
      color: var(--muted);
      margin-top: 10px;
    }
    
    /* Force landscape on mobile - show warning in portrait */
    @media screen and (orientation: portrait) and (max-width: 1024px) {
      #orientationWarning {
        display: flex !important;
      }
      
      #c, #gameStartOverlay, #hud, #mobileControls, #touchZones, #virtualJoystick, #banner, #gameOver {
        visibility: hidden !important;
      }
    }
    
    /* Optimize UI for landscape mobile */
    @media screen and (orientation: landscape) and (max-height: 600px) {
      #hud {
        top: 5px;
        left: 10px;
        padding: 10px 14px;
        font-size: 18px;
        min-width: 320px;
      }
      
      #hud .bar {
        --w: 220px;
        height: 10px;
      }
      
      .mobile-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }
      
      .sprint-btn {
        bottom: 15px;
        left: 15px;
        width: 75px;
        height: 75px;
      }
      
      .leap-btn {
        bottom: 15px;
        right: 15px;
        width: 75px;
        height: 75px;
      }
      
      .pause-btn {
        top: 5px;
        right: 10px;
        width: 45px;
        height: 45px;
        font-size: 20px;
      }
      
      #virtualJoystick {
        width: 100px;
        height: 100px;
      }
      
      .joystick-knob {
        width: 35px;
        height: 35px;
      }
    }
    
    /* Mobile Virtual Joystick */
    #virtualJoystick {
      position: fixed;
      width: 120px;
      height: 120px;
      display: none;
      pointer-events: none;
      z-index: 460;
    }
    
    .joystick-base {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 3px solid rgba(90, 242, 199, 0.4);
      background: radial-gradient(circle, rgba(18, 22, 29, 0.8), rgba(15, 19, 25, 0.6));
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }
    
    .joystick-knob {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), #34d1ff);
      border: 2px solid rgba(255, 255, 255, 0.3);
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 8px rgba(90, 242, 199, 0.5);
      transition: none;
    }
    
    /* Mobile Control Buttons */
    .mobile-btn {
      position: fixed;
      background: linear-gradient(135deg, rgba(18, 22, 29, 0.9), rgba(15, 19, 25, 0.8));
      border: 2px solid rgba(90, 242, 199, 0.5);
      border-radius: 50%;
      color: var(--accent);
      font-size: 28px;
      cursor: pointer;
      user-select: none;
      touch-action: none;
      z-index: 500;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      -webkit-tap-highlight-color: transparent;
    }
    
    .mobile-btn:active {
      transform: scale(0.95);
      background: linear-gradient(135deg, rgba(90, 242, 199, 0.3), rgba(90, 242, 199, 0.2));
      border-color: var(--accent);
      box-shadow: 0 0 20px rgba(90, 242, 199, 0.5);
    }
    
    .mobile-btn.active {
      background: linear-gradient(135deg, rgba(90, 242, 199, 0.4), rgba(90, 242, 199, 0.3));
      border-color: var(--accent);
      box-shadow: 0 0 25px rgba(90, 242, 199, 0.6);
    }
    
    /* Sprint Button - Bottom Left */
    .sprint-btn {
      width: 80px;
      height: 80px;
      left: 20px;
      bottom: 120px;
    }
    
    .sprint-btn.sprinting {
      animation: sprintPulse 0.5s ease-in-out infinite;
    }
    
    /* Leap Button - Bottom Right */
    .leap-btn {
      width: 80px;
      height: 80px;
      right: 20px;
      bottom: 120px;
      position: relative;
    }
    
    .leap-btn.ready {
      border-color: #00ffff;
      animation: leapReady 1s ease-in-out infinite;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
    }
    
    .leap-btn.cooldown {
      opacity: 0.5;
      border-color: rgba(90, 242, 199, 0.2);
    }
    
    .leap-cooldown {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top-color: var(--accent);
      display: none;
    }
    
    .leap-btn.cooldown .leap-cooldown {
      display: block;
      animation: rotateCooldown 3s linear;
    }
    
    /* Pause Button - Top Right */
    .pause-btn {
      width: 50px;
      height: 50px;
      right: 20px;
      top: 20px;
      font-size: 20px;
      opacity: 0.7;
    }
    
    .pause-btn:hover {
      opacity: 1;
    }
    
    /* Mobile Button Animations */
    @keyframes sprintPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    @keyframes leapReady {
      0% { 
        transform: scale(1);
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
      }
      50% { 
        transform: scale(1.05);
        box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
      }
      100% { 
        transform: scale(1);
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
      }
    }
    
    @keyframes rotateCooldown {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes hudFadeIn {
      0% {
        opacity: 0;
        visibility: hidden;
        transform: translateY(-10px) scale(0.95);
        filter: blur(4px);
      }
      50% {
        filter: blur(2px);
      }
      100% {
        opacity: 1;
        visibility: visible;
        transform: translateY(0) scale(1);
        filter: blur(0);
      }
    }
    
    @keyframes topShimmer {
      0%, 100% {
        opacity: 0;
        transform: translateX(-100%);
      }
      40% {
        opacity: 0;
      }
      50% {
        opacity: 0.8;
        transform: translateX(0%);
      }
      60% {
        opacity: 0;
      }
    }
    
    @keyframes glassUnderglow {
      0%, 100% {
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25),
                    inset 0 1px 0 rgba(255, 255, 255, 0.05),
                    inset 0 -1px 0 rgba(0, 0, 0, 0.1),
                    0 20px 60px -10px rgba(90, 242, 199, 0.15),
                    0 10px 40px -5px rgba(90, 242, 199, 0.2);
      }
      25% {
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25),
                    inset 0 1px 0 rgba(255, 255, 255, 0.05),
                    inset 0 -1px 0 rgba(0, 0, 0, 0.1),
                    0 25px 70px -10px rgba(90, 242, 199, 0.25),
                    0 15px 50px -5px rgba(52, 209, 255, 0.15);
      }
      50% {
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25),
                    inset 0 1px 0 rgba(255, 255, 255, 0.05),
                    inset 0 -1px 0 rgba(0, 0, 0, 0.1),
                    0 30px 80px -10px rgba(52, 209, 255, 0.2),
                    0 20px 60px -5px rgba(90, 242, 199, 0.25);
      }
      75% {
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25),
                    inset 0 1px 0 rgba(255, 255, 255, 0.05),
                    inset 0 -1px 0 rgba(0, 0, 0, 0.1),
                    0 25px 70px -10px rgba(52, 209, 255, 0.15),
                    0 15px 50px -5px rgba(90, 242, 199, 0.2);
      }
    }
    
    /* Hide mobile controls on desktop */
    @media (hover: hover) and (pointer: fine) {
      #mobileControls {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="game-start-overlay" id="gameStartOverlay">
    <div class="warp-grid"></div>
    <div class="reality-tear"></div>
    <div class="ripple-container">
      <div class="ripple ripple1"></div>
      <div class="ripple ripple2"></div>
      <div class="ripple ripple3"></div>
      <div class="ripple ripple4"></div>
    </div>
  </div>
  <div id="hud">
    <div class="row">Health
      <span class="bar health"><i id="healthBar" style="width:100%"></i></span>
      <span id="hpTxt">100</span>
    </div>
    <div class="row">Stamina
      <span class="bar stamina"><i id="staminaBar" style="width:100%"></i></span>
      <span id="staminaTxt">100</span>
    </div>
    <div class="row">Heat
      <span class="bar heat"><i id="heatBar" style="width:0%"></i></span>
      <span id="heatTxt">0</span>
    </div>
    <div class="row">Wave <span id="wave" class="stat-value">1</span> • Kills <span id="kills" class="stat-value">0</span></div>
  </div>
  <div id="banner">
    <h1 class="game-title">
      <span class="title-letter">⚡</span>
      <span class="title-letter">C</span>
      <span class="title-letter">R</span>
      <span class="title-letter">Y</span>
      <span class="title-letter">S</span>
      <span class="title-letter">T</span>
      <span class="title-letter">A</span>
      <span class="title-letter">L</span>
      <span class="title-space"> </span>
      <span class="title-letter">B</span>
      <span class="title-letter">L</span>
      <span class="title-letter">I</span>
      <span class="title-letter">T</span>
      <span class="title-letter">Z</span>
      <span class="title-letter">⚡</span>
    </h1>
    <div class="game-subtitle">SURVIVE THE ENDLESS WAVES</div>
    <div class="controls-panel">
      <div class="controls-title"><strong>Controls</strong></div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd>
        </div>
        <div class="control-desc">Move around the arena</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>Mouse</kbd>
        </div>
        <div class="control-desc">Aim and shoot</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>Shift</kbd>
        </div>
        <div class="control-desc">Dash through enemies</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>Space</kbd>
        </div>
        <div class="control-desc">Emergency leap</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>P</kbd>
        </div>
        <div class="control-desc">Pause game</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>F11</kbd>
        </div>
        <div class="control-desc">Toggle fullscreen</div>
      </div>
      <div class="mobile-note">Mobile: Touch left side to move, right side to aim/shoot<br>
        💨 Sprint (bottom left) | ⚡ Leap (bottom right) | ⏸️ Pause (top right)</div>
    </div>
    <button id="startBtn">Start</button>
    <button id="optionsBtn">Options</button>
  </div>
  <div id="optionsPanel" class="panel" style="display:none;">
    <!-- Options content will be dynamically created -->
  </div>
  <div id="gameOver">
    <h2>Game Over</h2>
    <div style="margin: 20px 0; font-size: 18px;">
      <div style="margin: 8px 0;">Wave: <span id="goWave" style="color: #5af2c7; font-weight: bold;">1</span></div>
      <div style="margin: 8px 0;">Kills: <span id="goKills" style="color: #5af2c7; font-weight: bold;">0</span></div>
      <div style="margin: 8px 0;">Time: <span id="goTime" style="color: #5af2c7; font-weight: bold;">0:00</span></div>
      <div style="margin: 8px 0;">Best Combo: <span id="goCombo" style="color: #FFD700; font-weight: bold;">0x</span></div>
      <div style="margin: 8px 0;">Accuracy: <span id="goAccuracy" style="color: #5af2c7; font-weight: bold;">0%</span></div>
    </div>
    <div id="newRecordBanner" style="display:none; margin: 15px 0; padding: 12px; background: linear-gradient(90deg, rgba(255,215,0,0.2), rgba(90,242,199,0.2)); border-radius: 8px; border: 2px solid #FFD700;">
      <div style="font-size: 20px; color: #FFD700; font-weight: bold;">🏆 NEW RECORDS! 🏆</div>
      <div id="recordsList" style="margin-top: 8px; font-size: 14px; color: #e3e7ef;"></div>
    </div>
    <div style="margin: 20px 0; padding: 15px; background: rgba(18,22,29,0.6); border-radius: 8px; font-size: 14px;">
      <div style="margin-bottom: 10px; color: #99a2b2; font-weight: bold;">CAREER STATS</div>
      <div style="margin: 5px 0;">Best Wave: <span id="statsBestWave" style="color: #e3e7ef;">0</span></div>
      <div style="margin: 5px 0;">Best Kills: <span id="statsBestKills" style="color: #e3e7ef;">0</span></div>
      <div style="margin: 5px 0;">Best Combo: <span id="statsBestCombo" style="color: #e3e7ef;">0x</span></div>
      <div style="margin: 5px 0;">Total Kills: <span id="statsTotalKills" style="color: #e3e7ef;">0</span></div>
      <div style="margin: 5px 0;">Games Played: <span id="statsGamesPlayed" style="color: #e3e7ef;">0</span></div>
      <div style="margin: 5px 0;">Total Playtime: <span id="statsTotalTime" style="color: #e3e7ef;">0h 0m</span></div>
    </div>
    <button id="restartBtn">Restart</button>
  </div>
  <div id="fps">FPS: —</div>
  <div id="powerupNotification"></div>
  <div id="waveAnnouncement">
    <div class="wave-number"></div>
    <div class="wave-subtitle"></div>
  </div>
  <div class="edge-warning top" id="edgeTop" style="display:none"></div>
  <div class="edge-warning bottom" id="edgeBottom" style="display:none"></div>
  <div class="edge-warning left" id="edgeLeft" style="display:none"></div>
  <div class="edge-warning right" id="edgeRight" style="display:none"></div>
  <div id="powerupDialog">
    <h2>Choose Your Upgrade</h2>
    <div class="powerup-options">
      <div class="powerup-option" id="powerupOption1">
        <h3 id="powerupTitle1">Title</h3>
        <p id="powerupDesc1">Description</p>
      </div>
      <div class="powerup-option" id="powerupOption2">
        <h3 id="powerupTitle2">Title</h3>
        <p id="powerupDesc2">Description</p>
      </div>
      <div class="powerup-option" id="powerupOption3">
        <h3 id="powerupTitle3">Title</h3>
        <p id="powerupDesc3">Description</p>
      </div>
    </div>
  </div>
  <div id="crystalLegend">
    <h3>Crystal Types</h3>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #00BFFF;"></div>
      <div class="crystal-name">Dual Shot</div>
      <div class="crystal-desc">Front & back bullets</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #32CD32;"></div>
      <div class="crystal-name">Triple Shot</div>
      <div class="crystal-desc">3-way spread</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #FF1493;"></div>
      <div class="crystal-name">Quad Shot</div>
      <div class="crystal-desc">4-way spread</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #FFD700;"></div>
      <div class="crystal-name">Homing</div>
      <div class="crystal-desc">Tracks enemies</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #FF4500;"></div>
      <div class="crystal-name">Explosive</div>
      <div class="crystal-desc">Area damage</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #FF69B4;"></div>
      <div class="crystal-name">Ricochet</div>
      <div class="crystal-desc">Bounces off walls</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #00BFFF;"></div>
      <div class="crystal-name">Lightning</div>
      <div class="crystal-desc">Chains to enemies</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #00CED1;"></div>
      <div class="crystal-name">Freeze Shot</div>
      <div class="crystal-desc">Slows enemies</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #8b4513;"></div>
      <div class="crystal-name">Shotgun</div>
      <div class="crystal-desc">Spreads on hit</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #ffa500;"></div>
      <div class="crystal-name">Cluster</div>
      <div class="crystal-desc">Splits into fragments</div>
    </div>
    <div class="crystal-item">
      <div class="crystal-color" style="background-color: #dc143c;"></div>
      <div class="crystal-name">Seeking</div>
      <div class="crystal-desc">Curves to enemies</div>
    </div>
  </div>
  
  <!-- Mobile Touch Zones -->
  <div id="touchZones">
    <div class="touch-zone left">
      <div style="position: absolute; top: 20px; left: 20px; color: rgba(90, 242, 199, 0.5); font-size: 14px;">MOVE</div>
    </div>
    <div class="touch-zone right">
      <div style="position: absolute; top: 20px; right: 20px; color: rgba(90, 242, 199, 0.5); font-size: 14px;">AIM & SHOOT</div>
    </div>
    <div id="touchIndicatorLeft" class="touch-indicator"></div>
    <div id="touchIndicatorRight" class="touch-indicator"></div>
  </div>
  
  <!-- Virtual Joystick -->
  <div id="virtualJoystick">
    <div class="joystick-base"></div>
    <div id="joystickKnob" class="joystick-knob"></div>
  </div>
  
  <!-- Orientation Warning -->
  <div id="orientationWarning">
    <div class="rotate-icon"></div>
    <div class="orientation-message">Please Rotate Your Device</div>
    <div class="orientation-submessage">Crystal Blitz requires landscape orientation for the best experience</div>
  </div>
  
  <!-- Mobile Control Buttons (only visible on touch devices) -->
  <div id="mobileControls" style="display:none">
    <button id="sprintBtn" class="mobile-btn sprint-btn">💨</button>
    <button id="leapBtn" class="mobile-btn leap-btn">
      <span class="leap-icon">⚡</span>
      <span class="leap-cooldown"></span>
    </button>
    <button id="pauseBtn" class="mobile-btn pause-btn">⏸️</button>
  </div>

  <script>
  'use strict';

  // ===== Canvas & Resize =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  
  // Offscreen canvas for static background grid (draw once, reuse forever)
  let bgCanvas = null;
  let bgCtx = null;
  let bgNeedsRedraw = true;
  
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    bgNeedsRedraw = true; // Redraw background on resize
  }
  window.addEventListener('resize', resize);
  resize();

  // ===== UI Elements =====
  // Helper function to get elements by ID
  const getElement = (id) => document.getElementById(id);

  // Single elements
  const startBtn = getElement('startBtn');
  const banner = getElement('banner');
  const hudHpBar = getElement('healthBar');
  const hudStaminaBar = getElement('staminaBar');
  const hudHeatBar = getElement('heatBar');
  const hpTxt = getElement('hpTxt');
  const staminaTxt = getElement('staminaTxt');
  const heatTxt = getElement('heatTxt');
  const waveTxt = getElement('wave');
  const killsTxt = getElement('kills');
  const fpsTxt = getElement('fps');
  const gameOverPanel = getElement('gameOver');
  const goWave = getElement('goWave');
  const goKills = getElement('goKills');
  const gameStartOverlay = getElement('gameStartOverlay');
  const restartBtn = getElement('restartBtn');
  const powerupNotification = getElement('powerupNotification');
  const waveAnnouncement = getElement('waveAnnouncement');
  const powerupDialog = getElement('powerupDialog');
  const crystalLegend = getElement('crystalLegend');
  const optionsPanel = getElement('optionsPanel');
  const optionsBtn = getElement('optionsBtn');

  // Grouped elements (powerup options, titles, descriptions)
  const powerupOptions = [1, 2, 3].map(i => getElement(`powerupOption${i}`));
  const powerupTitles = [1, 2, 3].map(i => getElement(`powerupTitle${i}`));
  const powerupDescs = [1, 2, 3].map(i => getElement(`powerupDesc${i}`));
  const edgeWarnings = {
    top: getElement('edgeTop'),
    bottom: getElement('edgeBottom'),
    left: getElement('edgeLeft'),
    right: getElement('edgeRight')
  };
  
  // Mobile control buttons
  const mobileControls = getElement('mobileControls');
  const sprintBtn = getElement('sprintBtn');
  const leapBtn = getElement('leapBtn');
  const pauseBtn = getElement('pauseBtn');

  // ============================================================
  // SECTION: MATH UTILITIES
  // ============================================================

  /** Mathematical constant for 2π (full circle in radians) */
  const TAU = Math.PI * 2;

  /**
   * Clamps a value between a minimum and maximum
   * @param {number} v - Value to clamp
   * @param {number} lo - Minimum value
   * @param {number} hi - Maximum value
   * @returns {number} Clamped value
   */
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  /**
   * Returns the squared length of a 2D vector (avoids expensive sqrt)
   * @param {number} x - X component
   * @param {number} y - Y component
   * @returns {number} Squared length (x² + y²)
   */
  function len2(x,y){ return x*x + y*y; }

  /** Reusable vector objects to eliminate array allocations during gameplay */
  const vecPool = {
    temp1: {x: 0, y: 0},
    temp2: {x: 0, y: 0},
    temp3: {x: 0, y: 0},
    temp4: {x: 0, y: 0}
  };

  /**
   * Fast length calculation for 2D vectors
   * @param {number} x - X component
   * @param {number} y - Y component
   * @returns {number} Vector length
   */
  function fastLength(x, y) {
    return Math.sqrt(x * x + y * y);
  }

  /**
   * Normalizes a 2D vector (legacy version with array allocation)
   * @param {number} x - X component
   * @param {number} y - Y component
   * @returns {Array<number>} Normalized vector as [x, y]
   * @deprecated Use normInPlace() to avoid allocations
   */
  function norm(x,y) {
    const L = fastLength(x,y); return [x/L, y/L];
  }

  /**
   * Normalizes a 2D vector in-place (no allocations)
   * @param {number} x - X component
   * @param {number} y - Y component
   * @param {Object} out - Output object with x, y properties
   * @returns {Object} The output object with normalized components
   */
  function normInPlace(x, y, out) {
    const L = fastLength(x, y);
    out.x = x / L;
    out.y = y / L;
    return out;
  }

  /**
   * Returns a random value in the range [a, b]
   * @param {number} a - Minimum value
   * @param {number} b - Maximum value
   * @returns {number} Random value
   */
  function randRange(a,b){ return a + Math.random()*(b-a); }

  /**
   * Returns the sign of a number (-1, 0, or 1)
   * @param {number} v - Input value
   * @returns {number} -1 if negative, 1 if positive or zero
   */
  function sign(v){ return v < 0 ? -1 : 1; }

  // ============================================================
  // SECTION: SAVE SYSTEM & STATS TRACKING
  // ============================================================

  const SAVE_KEY = 'crystalBlitz_save_v1';

  function getDefaultSave() {
    return {
      // High scores
      highestWave: 0,
      bestKills: 0,
      longestSurvivalTime: 0,
      bestCombo: 0,
      bestAccuracy: 0,

      // Career stats
      totalKills: 0,
      totalShots: 0,
      totalHits: 0,
      totalDeaths: 0,
      gamesPlayed: 0,
      totalPlayTime: 0,
    };
  }

  function loadSaveData() {
    try {
      const data = localStorage.getItem(SAVE_KEY);
      if (!data) return getDefaultSave();
      return {...getDefaultSave(), ...JSON.parse(data)};
    } catch (e) {
      console.warn('Failed to load save data:', e);
      return getDefaultSave();
    }
  }

  function saveSaveData() {
    try {
      localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
    } catch (e) {
      console.warn('Failed to save game data:', e);
    }
  }

  let saveData = loadSaveData();

  function updateHighScores(game) {
    let newRecords = [];

    // Calculate accuracy
    const accuracy = game.shotsFired > 0 ? (game.shotsHit / game.shotsFired) * 100 : 0;

    // Check for new records
    if (game.wave > saveData.highestWave) {
      saveData.highestWave = game.wave;
      newRecords.push('Highest Wave');
    }

    if (game.kills > saveData.bestKills) {
      saveData.bestKills = game.kills;
      newRecords.push('Most Kills');
    }

    if (game.t > saveData.longestSurvivalTime) {
      saveData.longestSurvivalTime = game.t;
      newRecords.push('Longest Survival');
    }

    if (game.highestCombo > saveData.bestCombo) {
      saveData.bestCombo = game.highestCombo;
      newRecords.push('Best Combo');
    }

    if (accuracy > saveData.bestAccuracy) {
      saveData.bestAccuracy = accuracy;
      newRecords.push('Best Accuracy');
    }

    // Update career stats
    saveData.totalKills += game.kills;
    saveData.totalShots += game.shotsFired || 0;
    saveData.totalHits += game.shotsHit || 0;
    saveData.totalDeaths += 1;
    saveData.gamesPlayed += 1;
    saveData.totalPlayTime += game.t;

    saveSaveData();

    return newRecords;
  }

  // ============================================================
  // SECTION: GAME CONSTANTS & CONFIGURATION
  // ============================================================

  /**
   * AI Behavior Constants - Centralized tuning values for enemy movement
   */
  const AI_CONSTANTS = {
    // Serpent (zigzag) behavior
    SERPENT_ZIGZAG_STRENGTH_X: 300,
    SERPENT_ZIGZAG_STRENGTH_Y: 250,
    SERPENT_SPEED_MULTIPLIER: 1.5,

    // Prowler (flanking) behavior
    PROWLER_FLANK_SPEED: 2.0,
    PROWLER_DIRECT_ATTRACTION: 0.2,

    // Berserker (dash) behavior
    BERSERKER_PROWL_SPEED: 1.2,
    BERSERKER_TELEGRAPH_SPEED: 0.2,
    BERSERKER_TELEGRAPH_DURATION: 1.0,
    BERSERKER_DASH_DURATION: 0.4,
    BERSERKER_DASH_MULTIPLIER: 3,
    BERSERKER_DASH_IMPULSE: 8,
    BERSERKER_COOLDOWN_MIN: 3,
    BERSERKER_COOLDOWN_MAX: 5,

    // Maniac (chaotic) behavior
    MANIAC_CHAOS_FACTOR: 800,
    MANIAC_SPEED_MULTIPLIER: 1.5,

    // Leaper (rush) behavior
    LEAPER_RUSH_MULTIPLIER: 4,
    LEAPER_RUSH_IMPULSE: 10,
    LEAPER_BETWEEN_RUSH_SPEED: 1.8,
    LEAPER_COOLDOWN_MIN: 1.0,
    LEAPER_COOLDOWN_MAX: 2.5,

    // Volatile (suicide crawler) behavior
    VOLATILE_ORBIT_RADIUS: 120,
    VOLATILE_ORBIT_SPEED: 1.2,
    VOLATILE_ORBIT_MOVE_SPEED: 1.5,
    VOLATILE_ORBIT_ATTRACTION: 0.2,
    VOLATILE_TELEGRAPH_DURATION: 1.0,
    VOLATILE_CHARGE_MULTIPLIER: 4,
    VOLATILE_CHARGE_IMPULSE: 15,

    // Boss behavior
    BOSS_SPEED_MULTIPLIER: 1.2,
    SUPERBOSS_PHASE_DURATION: 20,
    SUPERBOSS_ORBIT_SPEED: 1.8,
    SUPERBOSS_CHAOS_FACTOR: 400,
    SUPERBOSS_RUSH_POWER: 3.0,
    SUPERBOSS_RUSH_DURATION: 1.5,
    SUPERBOSS_STALK_SPEED: 0.3,

    // Basic movement
    BASIC_SPEED_MULTIPLIER: 2.6,
    WALK_SWAY_STRENGTH: 8,
  };

  /**
   * Performance Optimization Constants
   */
  const PERF_CONSTANTS = {
    TRIG_CACHE_SIZE: 1000,
    GRADIENT_CACHE_SIZE: 100,
    MAX_PARTICLES: 500,
    MAX_BLOOD_STAINS: 200,
  };

  // ============================================================
  // SECTION: INPUT & CONTROLS
  // ============================================================
  // ===== Input =====
  const keys = new Set();
  let mouseX = 0, mouseY = 0, mouseDown = false;
  
  // Mobile touch support with improved handling
  let touchMove = {x: 0, y: 0, startX: 0, startY: 0, active: false, id: null};
  let touchShoot = {x: 0, y: 0, active: false, id: null};
  let touchZonesElement = null;
  let virtualJoystick = null;
  let joystickKnob = null;
  let touchIndicatorLeft = null;
  let touchIndicatorRight = null;
  window.addEventListener('keydown', e => {
    if (e.code === 'KeyP' || e.code === 'Escape'){ togglePause(); return; }
    if (e.code === 'F11'){ 
      e.preventDefault();
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
      return; 
    }
    keys.add(e.code);
  });
  window.addEventListener('keyup', e => keys.delete(e.code));
  canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
  canvas.addEventListener('mousedown', () => { mouseDown = true; initAudio(); });
  window.addEventListener('mouseup', () => mouseDown = false);
  canvas.addEventListener('contextmenu', e => e.preventDefault());
  
  // Improved touch controls for mobile
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    initAudio();
    
    // Handle multiple touches
    for (let i = 0; i < e.touches.length; i++) {
      const touch = e.touches[i];
      // Use canvas bounds for more accurate detection
      const rect = canvas.getBoundingClientRect();
      const screenMidpoint = rect.width / 2;
      
      if (touch.clientX < screenMidpoint && !touchMove.active) {
        // Left side - movement
        touchMove.active = true;
        touchMove.id = touch.identifier;
        touchMove.startX = touch.clientX;
        touchMove.startY = touch.clientY;
        touchMove.x = touch.clientX;
        touchMove.y = touch.clientY;
        
        // Show virtual joystick at touch position
        if (virtualJoystick) {
          virtualJoystick.style.display = 'block';
          virtualJoystick.style.left = touch.clientX + 'px';
          virtualJoystick.style.top = touch.clientY + 'px';
          virtualJoystick.style.transform = 'translate(-50%, -50%)';
          virtualJoystick.style.bottom = 'auto'; // Reset bottom positioning
        }
        
        // Show touch indicator
        if (touchIndicatorLeft) {
          touchIndicatorLeft.style.left = touch.clientX + 'px';
          touchIndicatorLeft.style.top = touch.clientY + 'px';
          touchIndicatorLeft.classList.add('active');
        }
      } else if (touch.clientX >= screenMidpoint && !touchShoot.active) {
        // Right side - shooting/aiming
        touchShoot.active = true;
        touchShoot.id = touch.identifier;
        touchShoot.x = touch.clientX;
        touchShoot.y = touch.clientY;
        // Convert to canvas coordinates
        mouseX = (touch.clientX - rect.left) * (canvas.width / rect.width);
        mouseY = (touch.clientY - rect.top) * (canvas.height / rect.height);
        mouseDown = true;
        
        // Show touch indicator
        if (touchIndicatorRight) {
          touchIndicatorRight.style.left = touch.clientX + 'px';
          touchIndicatorRight.style.top = touch.clientY + 'px';
          touchIndicatorRight.classList.add('active');
        }
      }
    }
  });
  
  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    
    for (let i = 0; i < e.touches.length; i++) {
      const touch = e.touches[i];
      
      if (touchMove.active && touch.identifier === touchMove.id) {
        touchMove.x = touch.clientX;
        touchMove.y = touch.clientY;
        
        // Update joystick knob position
        if (joystickKnob && virtualJoystick) {
          const dx = touch.clientX - touchMove.startX;
          const dy = touch.clientY - touchMove.startY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const maxDistance = 40; // Max joystick movement
          
          if (distance > maxDistance) {
            const angle = Math.atan2(dy, dx);
            joystickKnob.style.left = (50 + (Math.cos(angle) * maxDistance * 100 / 120)) + '%';
            joystickKnob.style.top = (50 + (Math.sin(angle) * maxDistance * 100 / 120)) + '%';
          } else {
            joystickKnob.style.left = (50 + (dx * 100 / 120)) + '%';
            joystickKnob.style.top = (50 + (dy * 100 / 120)) + '%';
          }
        }
        
        // Update touch indicator
        if (touchIndicatorLeft) {
          touchIndicatorLeft.style.left = touch.clientX + 'px';
          touchIndicatorLeft.style.top = touch.clientY + 'px';
        }
      } else if (touchShoot.active && touch.identifier === touchShoot.id) {
        touchShoot.x = touch.clientX;
        touchShoot.y = touch.clientY;
        // Convert to canvas coordinates
        mouseX = (touch.clientX - rect.left) * (canvas.width / rect.width);
        mouseY = (touch.clientY - rect.top) * (canvas.height / rect.height);
        
        // Update touch indicator
        if (touchIndicatorRight) {
          touchIndicatorRight.style.left = touch.clientX + 'px';
          touchIndicatorRight.style.top = touch.clientY + 'px';
        }
      }
    }
  });
  
  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    
    // Check which touch ended
    let moveEnded = true;
    let shootEnded = true;
    
    for (let i = 0; i < e.touches.length; i++) {
      const touch = e.touches[i];
      if (touch.identifier === touchMove.id) moveEnded = false;
      if (touch.identifier === touchShoot.id) shootEnded = false;
    }
    
    if (moveEnded && touchMove.active) {
      touchMove.active = false;
      touchMove.id = null;
      
      // Hide virtual joystick and reset knob
      if (virtualJoystick) {
        virtualJoystick.style.display = 'none';
      }
      if (joystickKnob) {
        joystickKnob.style.left = '50%';
        joystickKnob.style.top = '50%';
      }
      if (touchIndicatorLeft) {
        touchIndicatorLeft.classList.remove('active');
      }
    }
    
    if (shootEnded && touchShoot.active) {
      touchShoot.active = false;
      touchShoot.id = null;
      mouseDown = false;
      
      if (touchIndicatorRight) {
        touchIndicatorRight.classList.remove('active');
      }
    }
  });
  
  // Prevent default touch behavior on canvas
  canvas.addEventListener('touchcancel', e => {
    e.preventDefault();
    touchMove.active = false;
    touchMove.id = null;
    touchShoot.active = false;
    touchShoot.id = null;
    mouseDown = false;
    
    // Hide all indicators
    if (virtualJoystick) virtualJoystick.style.display = 'none';
    if (joystickKnob) {
      joystickKnob.style.left = '50%';
      joystickKnob.style.top = '50%';
    }
    if (touchIndicatorLeft) touchIndicatorLeft.classList.remove('active');
    if (touchIndicatorRight) touchIndicatorRight.classList.remove('active');
  });
  
  // ===== Mobile Controls Detection & Setup =====
  const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
  
  // Initialize mobile UI elements
  touchZonesElement = document.getElementById('touchZones');
  virtualJoystick = document.getElementById('virtualJoystick');
  joystickKnob = document.getElementById('joystickKnob');
  touchIndicatorLeft = document.getElementById('touchIndicatorLeft');
  touchIndicatorRight = document.getElementById('touchIndicatorRight');
  const orientationWarning = document.getElementById('orientationWarning');
  
  if (isMobile) {
    // Show mobile controls and touch zones
    if (mobileControls) mobileControls.style.display = 'block';
    if (touchZonesElement) touchZonesElement.style.display = 'block';
    
    // Add mobile-specific styles and prevent scrolling
    document.body.style.overflow = 'hidden';
    document.body.style.touchAction = 'none';
    document.body.style.position = 'fixed';
    document.body.style.width = '100%';
    document.body.style.height = '100%';
    canvas.style.touchAction = 'none';
    
    // Prevent iOS bounce scrolling
    document.addEventListener('touchmove', function(e) {
      e.preventDefault();
    }, { passive: false });
    
    // Handle orientation changes
    function checkOrientation() {
      const isPortrait = window.innerHeight > window.innerWidth;
      
      if (isPortrait && isMobile) {
        // Show warning and pause game
        if (orientationWarning) {
          orientationWarning.classList.add('show');
        }
        if (game && game.state === STATE.RUN) {
          setState(game, STATE.PAUSE);
        }
        return false; // Not in correct orientation
      } else {
        // Hide warning and allow game
        if (orientationWarning) {
          orientationWarning.classList.remove('show');
        }
        // Update canvas size on orientation change
        if (game) {
          resize();
        }
        return true; // In correct orientation
      }
    }
    
    // Check orientation on load and changes
    window.addEventListener('orientationchange', () => {
      setTimeout(checkOrientation, 100); // Delay to let orientation settle
    });
    window.addEventListener('resize', () => {
      if (isMobile) checkOrientation();
    });
    
    // Initial orientation check
    setTimeout(() => {
      checkOrientation();
    }, 100);
    
    // Try to lock orientation if API is available (works on some Android devices)
    if (screen.orientation && screen.orientation.lock) {
      document.addEventListener('fullscreenchange', () => {
        if (document.fullscreenElement) {
          screen.orientation.lock('landscape').catch(() => {
            console.log('Orientation lock not supported');
          });
        }
      });
    }
    
    // Show mobile controls
    if (mobileControls) mobileControls.style.display = 'block';
    
    // Sprint button - toggle or hold behavior
    let sprintActive = false;
    sprintBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      sprintActive = true;
      keys.add('ShiftLeft');
      sprintBtn.classList.add('active', 'sprinting');
      initAudio();
    });
    
    sprintBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      e.stopPropagation();
      sprintActive = false;
      keys.delete('ShiftLeft');
      keys.delete('ShiftRight');
      sprintBtn.classList.remove('active', 'sprinting');
    });
    
    // Leap button
    leapBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (game && game.player && game.player.leapReady) {
        keys.add('Space');
        setTimeout(() => keys.delete('Space'), 100); // Quick tap
        initAudio();
      }
    });
    
    // Pause button
    pauseBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (game && (game.state === STATE.RUN || game.state === STATE.PAUSE)) {
        togglePause();
        initAudio();
      }
    });
    
    // Prevent accidental touches from bubbling
    mobileControls.addEventListener('touchstart', (e) => {
      if (e.target.classList.contains('mobile-btn')) {
        e.stopPropagation();
      }
    });
  }

  // ===== Security & Utility Functions =====
  function sanitizeText(text) {
    if (typeof text !== 'string') return '';
    return text.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;');
  }

  function safeParseInt(value, defaultValue = 0) {
    const parsed = parseInt(value, 10);
    return isNaN(parsed) ? defaultValue : parsed;
  }

  function safeParseFloat(value, defaultValue = 0.0) {
    const parsed = parseFloat(value);
    return isNaN(parsed) ? defaultValue : parsed;
  }

  // ============================================================
  // SECTION: PERFORMANCE OPTIMIZATIONS
  // ============================================================

  /** LRU cache for sine calculations (reduces Math.sin calls by ~90%) */
  const sinCache = new Map();
  /** LRU cache for cosine calculations (reduces Math.cos calls by ~90%) */
  const cosCache = new Map();
  /** Maximum cache size before LRU eviction */
  const TRIG_CACHE_SIZE = 1000;

  /**
   * Fast sine calculation with LRU caching
   * @param {number} angle - Angle in radians
   * @returns {number} Sine value
   */
  function fastSin(angle) {
    const key = Math.round(angle * 1000);
    if (!sinCache.has(key)) {
      if (sinCache.size > TRIG_CACHE_SIZE) {
        // LRU eviction - remove oldest entry
        const firstKey = sinCache.keys().next().value;
        sinCache.delete(firstKey);
      }
      sinCache.set(key, Math.sin(key / 1000));
    }
    return sinCache.get(key);
  }

  /**
   * Fast cosine calculation with LRU caching
   * @param {number} angle - Angle in radians
   * @returns {number} Cosine value
   */
  function fastCos(angle) {
    const key = Math.round(angle * 1000);
    if (!cosCache.has(key)) {
      if (cosCache.size > TRIG_CACHE_SIZE) {
        // LRU eviction - remove oldest entry
        const firstKey = cosCache.keys().next().value;
        cosCache.delete(firstKey);
      }
      cosCache.set(key, Math.cos(key / 1000));
    }
    return cosCache.get(key);
  }

  /**
   * Fast distance comparison using squared distance (avoids sqrt)
   * @param {number} x1 - First point X
   * @param {number} y1 - First point Y
   * @param {number} x2 - Second point X
   * @param {number} y2 - Second point Y
   * @param {number} maxDist - Maximum distance threshold
   * @returns {boolean} True if distance is less than or equal to maxDist
   */
  function fastDistanceCheck(x1, y1, x2, y2, maxDist) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const distSq = dx * dx + dy * dy;
    return distSq <= maxDist * maxDist;
  }

  /** Queue for batched DOM updates */
  let domUpdateQueue = [];
  /** Flag to track if DOM update is scheduled */
  let domUpdateScheduled = false;

  /**
   * Queues a DOM update to be executed in the next animation frame
   * Batches multiple updates to reduce reflows
   * @param {Function} fn - Function to execute for DOM update
   */
  function queueDOMUpdate(fn) {
    domUpdateQueue.push(fn);
    if (!domUpdateScheduled) {
      domUpdateScheduled = true;
      requestAnimationFrame(() => {
        for (const update of domUpdateQueue) {
          update();
        }
        domUpdateQueue = [];
        domUpdateScheduled = false;
      });
    }
  }

  /** Canvas state caching to avoid redundant context calls */
  let lastFillStyle = '';
  let lastStrokeStyle = '';
  let lastGlobalAlpha = 1;
  let lastLineWidth = 1;

  /**
   * Sets canvas fill style with caching to avoid redundant calls
   * @param {string} style - CSS color string
   */
  function setFillStyle(style) {
    // Validate style to prevent crashes
    let validStyle = '#ff0000'; // Default fallback
    if (style && style !== '' && style !== 'undefined' && style !== 'null' && style !== 'transparent' && style !== 'none') {
      validStyle = style;
    }

    if (lastFillStyle !== validStyle) {
      ctx.fillStyle = validStyle;
      lastFillStyle = validStyle;
    }
  }

  /**
   * Sets canvas stroke style with caching
   * @param {string} style - CSS color string
   */
  function setStrokeStyle(style) {
    if (lastStrokeStyle !== style) {
      ctx.strokeStyle = style;
      lastStrokeStyle = style;
    }
  }

  /**
   * Sets canvas global alpha with caching
   * @param {number} alpha - Alpha value (0-1)
   */
  function setGlobalAlpha(alpha) {
    if (lastGlobalAlpha !== alpha) {
      ctx.globalAlpha = alpha;
      lastGlobalAlpha = alpha;
    }
  }

  /**
   * Sets canvas line width with caching
   * @param {number} width - Line width in pixels
   */
  function setLineWidth(width) {
    if (lastLineWidth !== width) {
      ctx.lineWidth = width;
      lastLineWidth = width;
    }
  }
  
  function resetRenderState() {
    lastFillStyle = '';
    lastStrokeStyle = '';
    lastGlobalAlpha = 1;
    lastLineWidth = 1;
    // Also reset actual canvas state to ensure no bad state persists
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#ffffff';
    ctx.globalAlpha = 1;
    ctx.lineWidth = 1;
  }
  
  // Performance monitoring and adaptive quality
  let frameTimeHistory = [];
  let performanceLevel = 1.0; // 1.0 = full quality, 0.5 = reduced quality
  
  function updatePerformanceLevel(frameTime) {
    frameTimeHistory.push(frameTime);
    if (frameTimeHistory.length > 10) {
      frameTimeHistory.shift();
      const avgFrameTime = frameTimeHistory.reduce((a, b) => a + b) / frameTimeHistory.length;
      const targetFrameTime = 16.67; // 60 FPS
      
      if (avgFrameTime > targetFrameTime * 1.5) {
        performanceLevel = Math.max(0.3, performanceLevel - 0.1);
      } else if (avgFrameTime < targetFrameTime * 1.1) {
        performanceLevel = Math.min(1.0, performanceLevel + 0.05);
      }
    }
  }
  
  function shouldSpawnParticle() {
    // Use the counter for O(1) performance instead of O(n)
    if (activeParticleCount >= MAX_PARTICLES) return false;
    return Math.random() < performanceLevel;
  }
  
  // Helper to avoid duplicate game over code
  function triggerGameOver(g) {
    g.state = STATE.OVER;

    // Calculate session stats
    const minutes = Math.floor(g.t / 60);
    const seconds = Math.floor(g.t % 60);
    const accuracy = g.shotsFired > 0 ? Math.round((g.shotsHit / g.shotsFired) * 100) : 0;

    // Update high scores and get list of new records
    const newRecords = updateHighScores(g);

    // Update session stats display
    document.getElementById('goWave').textContent = g.wave.toString();
    document.getElementById('goKills').textContent = g.kills.toString();
    document.getElementById('goTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    document.getElementById('goCombo').textContent = g.highestCombo + 'x';
    document.getElementById('goAccuracy').textContent = accuracy + '%';

    // Show/hide new record banner
    const recordBanner = document.getElementById('newRecordBanner');
    const recordsList = document.getElementById('recordsList');
    if (newRecords.length > 0) {
      recordBanner.style.display = 'block';
      recordsList.innerHTML = newRecords.map(r => `<div>• ${r}</div>`).join('');
    } else {
      recordBanner.style.display = 'none';
    }

    // Update career stats display
    const totalMinutes = Math.floor(saveData.totalPlayTime / 60);
    const totalHours = Math.floor(totalMinutes / 60);
    const remainingMinutes = totalMinutes % 60;

    document.getElementById('statsBestWave').textContent = saveData.highestWave.toString();
    document.getElementById('statsBestKills').textContent = saveData.bestKills.toString();
    document.getElementById('statsBestCombo').textContent = saveData.bestCombo + 'x';
    document.getElementById('statsTotalKills').textContent = saveData.totalKills.toString();
    document.getElementById('statsGamesPlayed').textContent = saveData.gamesPlayed.toString();
    document.getElementById('statsTotalTime').textContent = `${totalHours}h ${remainingMinutes}m`;

    gameOverPanel.style.display = 'block';
    gameOverPanel.classList.add('active');
    gameOverPanel.style.animation = 'gameOverDramaticEntry 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards, glassUnderglow 8s ease-in-out infinite';

    // Hide HUD when game over
    const hud = document.getElementById('hud');
    hud.style.animation = 'hudFadeIn 0.3s ease-out reverse forwards';

    // Hide mobile controls during game over
    if (isMobile && mobileControls) {
      mobileControls.style.display = 'none';
    }
  }
  
  // Generate upgrades display for pause menu
  function createUpgradesDisplay() {
    if (!game || !game.player) return '';
    
    const upgrades = [];
    const player = game.player;
    
    // Check static powerup upgrades
    for (const [upgradeId, count] of player.upgradeCounts) {
      const powerup = staticPowerups.find(p => p.id === upgradeId);
      if (powerup && count > 0) {
        const stackText = count > 1 ? ` (×${count})` : '';
        upgrades.push(`${powerup.name}${stackText}`);
      }
    }
    
    // Check temporary effects
    if (player.activeEffects && player.activeEffects.size > 0) {
      for (const [effect, shots] of player.activeEffects) {
        if (shots > 0) {
          const effectName = effect.charAt(0).toUpperCase() + effect.slice(1);
          upgrades.push(`${effectName} (${shots} shots)`);
        }
      }
    }
    
    // Check pattern multipliers  
    if (player.patternMultipliers && player.patternMultipliers.size > 0) {
      for (const [pattern, shots] of player.patternMultipliers) {
        if (shots > 0) {
          const patternName = pattern.charAt(0).toUpperCase() + pattern.slice(1);
          upgrades.push(`${patternName} Pattern (${shots} shots)`);
        }
      }
    }
    
    // Check legacy upgrades
    if (player.upgradeShots > 0) {
      upgrades.push(`Dual Shot (${player.upgradeShots} shots)`);
    }
    
    return upgrades.length > 0 ? upgrades : ['No upgrades acquired'];
  }

  // ===== Audio (procedural, no assets) =====
  let audioCtx = null;
  function initAudio(){
    try {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // resume on iOS Safari
        audioCtx.resume && audioCtx.resume();
      }
    } catch (audioError) {
      // Audio initialization failed
      // Game can continue without audio
    }
  }
  function beep(freq=440, duration=0.05, type='square', gain=0.02){
    if (!audioCtx) return;
    try {
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      g.gain.value = gain;
      osc.connect(g).connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      osc.start(now);
      osc.stop(now + duration);
    } catch (beepError) {
      // Audio beep error
      // Silently fail for audio errors
    }
  }
  function shootSound(){ beep(680, 0.04, 'square', 0.1); }
  function hitSound(){ beep(220, 0.07, 'sawtooth', 0.15); }
  function criticalHitSound(){ beep(400, 0.05, 'triangle', 0.18); }
  function staminaDepletedSound(){ 
    beep(300, 0.06, 'triangle', 0.12); 
    setTimeout(() => beep(280, 0.06, 'triangle', 0.10), 100); // Second pulse after 100ms
  }
  function hurtSound(){ beep(120, 0.1, 'sine', 0.2); }
  function waveSound(){ beep(440, 0.12, 'triangle', 0.1); }
  function enemyDeathSound(enemy) {
    // Different death sounds based on enemy type and size
    const baseFreq = enemy.r > 20 ? 60 :   // Super bosses - very deep
                     enemy.r > 16 ? 90 :   // Large enemies (tanks, bosses) - deep
                     enemy.r < 12 ? 200 :  // Small enemies (fast, zerglings) - high  
                     160;                  // Normal enemies - medium
    
    const variation = (Math.random() - 0.5) * 30; // ±15 Hz variation for more character
    const freq = baseFreq + variation;
    const duration = enemy.r > 16 ? 0.18 : enemy.r < 12 ? 0.06 : 0.1; // Size-based duration
    const volume = Math.min(0.15, 0.08 + enemy.r * 0.003); // Volume scales with size
    
    beep(freq, duration, 'sawtooth', volume);
  }

  // ===== Static Powerups =====
  const staticPowerups = [
    {id: 'speedBoost', name: 'Speed Boost', desc: '+12.5% movement speed', apply: (p) => p.speed *= 1.125},
    {id: 'healthRegen', name: 'Health Regen', desc: '+0.5 HP/sec regeneration', apply: (p) => p.healthRegenRate = (p.healthRegenRate || 0) + 0.5},
    {id: 'maxHealth', name: 'Max Health', desc: '+30 maximum health', apply: (p) => { p.maxHp += 30; p.hp = Math.min(p.hp + 30, p.maxHp); }},
    {id: 'staminaBoost', name: 'Stamina Boost', desc: '+25% stamina regeneration', apply: (p) => p.staminaRegen *= 1.25},
    {id: 'rapidFire', name: 'Rapid Fire', desc: '12.5% faster shooting', apply: (p) => p.fireDelay *= 0.875},
    {id: 'bulletSize', name: 'Bullet Size', desc: '25% larger bullets', apply: (p) => p.bulletSize = 1.25},
    {id: 'bulletSpeed', name: 'Bullet Speed', desc: '25% faster bullets', apply: (p) => p.bulletSpeed = 1.25},
    {id: 'piercingShot', name: 'Piercing Shot', desc: '+1 bullet piercing', apply: (p) => p.piercingCount = (p.piercingCount || 0) + 1},
    {id: 'shield', name: 'Shield', desc: '+25% damage reduction', apply: (p) => p.damageReduction = Math.min(0.9, p.damageReduction + 0.25)},
    {id: 'knockbackImmune', name: 'Knockback Resistance', desc: '+50% knockback reduction', apply: (p) => p.knockbackResistance = (p.knockbackResistance || 0) + 0.5},
    {id: 'magneticCrystals', name: 'Magnetic Crystals', desc: '+80px attraction range', apply: (p) => p.magneticRange = (p.magneticRange || 0) + 80},
    {id: 'lucky', name: 'Lucky', desc: '+20% crystal drop rate', apply: (p) => p.luckyBonus = (p.luckyBonus || 0) + 0.20},
    {id: 'dashCooldown', name: 'Dash Cooldown', desc: '-15% dash cooldown', apply: (p) => p.dashCooldownReduction = (p.dashCooldownReduction || 0) + 0.15},
    {id: 'criticalChance', name: 'Critical Strike', desc: '+10% critical hit chance', apply: (p) => p.criticalChance = Math.min(0.5, (p.criticalChance || 0) + 0.1)},
    {id: 'vampire', name: 'Vampire', desc: '+0.5 HP per enemy killed', apply: (p) => p.vampiricHealing = (p.vampiricHealing || 0) + 0.5},
    {id: 'adrenaline', name: 'Adrenaline', desc: '+20% speed for 3s after damage', apply: (p) => p.adrenalineBoost = true},
    {id: 'efficient', name: 'Efficient', desc: '+5% chance shots don\'t consume ammo', apply: (p) => p.ammoEfficiency = Math.min(0.50, (p.ammoEfficiency || 0) + 0.05)},
    {id: 'heatSink', name: 'Heat Sink', desc: '+25% heat dissipation', apply: (p) => p.heatDissipation *= 1.25},
    {id: 'coolantSystem', name: 'Coolant System', desc: '-20% heat per shot', apply: (p) => p.heatEfficiencyMod *= 0.8},
    {id: 'extendedMagazine', name: 'Extended Magazine', desc: '+25% max heat capacity', apply: (p) => { p.maxHeat *= 1.25; }}
  ];

  // ===== Powerup Notification =====
  function showPowerupNotification(powerupName) {
    powerupNotification.textContent = powerupName.toUpperCase();
    powerupNotification.style.display = 'block';
    powerupNotification.style.animation = 'none';
    
    // Choose animation based on content type
    let animationName = 'powerupPulse';
    let duration = 3000;
    
    if (powerupName.includes('BOSS')) {
      animationName = 'bossWaveEntry';
      duration = 4000;
    } else if (powerupName.includes('WAVE')) {
      animationName = 'waveDramaticEntry';
      duration = 3500;
    }
    
    // Force reflow to restart animation
    powerupNotification.offsetHeight;
    powerupNotification.style.animation = `${animationName} ${duration/1000}s cubic-bezier(0.34, 1.56, 0.64, 1) forwards`;
    
    // Hide after animation completes
    setTimeout(() => {
      powerupNotification.style.display = 'none';
    }, duration);
  }

  // ===== Wave Announcement =====
  let waveAnnouncementTimeouts = [];
  let nextWaveTimeoutId = null; // Track wave transition timeout
  let waveTransitionInProgress = false; // Prevent duplicate wave transitions
  
  function showWaveAnnouncement(waveNumber, isBossWave = false) {
    // Don't show if game is paused or in powerup selection
    if (game && (game.state === STATE.POWERUP || game.state === STATE.PAUSE || game.state === STATE.OVER)) {
      return;
    }
    
    // CRITICAL: If already showing, don't restart animation
    if (waveAnnouncement.dataset.active === 'true' || waveAnnouncement.style.display !== 'none') {
      // Wave announcement already active, skipping
      return;
    }
    
    // Clear any existing timeouts to prevent overlapping animations
    waveAnnouncementTimeouts.forEach(timeout => clearTimeout(timeout));
    waveAnnouncementTimeouts = [];
    
    // Force clean the element state first
    waveAnnouncement.style.animation = '';
    waveAnnouncement.style.display = 'none';
    waveAnnouncement.style.opacity = '0';
    waveAnnouncement.dataset.active = 'false';
    void waveAnnouncement.offsetHeight; // Force reflow to clear animation state
    
    const waveNumberEl = waveAnnouncement.querySelector('.wave-number');
    const subtitleEl = waveAnnouncement.querySelector('.wave-subtitle');
    
    waveNumberEl.textContent = `WAVE ${waveNumber}`;
    
    // Set subtitle based on wave number and type
    if (isBossWave) {
      subtitleEl.textContent = 'SUPER BOSS INCOMING!';
    } else if (waveNumber === 3) {
      subtitleEl.textContent = 'HEAVY ENEMIES UNLOCKED!';
    } else {
      subtitleEl.textContent = 'GET READY';
    }
    
    // Apply boss wave styling
    if (isBossWave) {
      waveAnnouncement.classList.add('boss-wave');
    } else {
      waveAnnouncement.classList.remove('boss-wave');
    }
    
    // Use requestAnimationFrame for clean start
    requestAnimationFrame(() => {
      // Final state check
      if (game && (game.state === STATE.POWERUP || game.state === STATE.PAUSE || game.state === STATE.OVER)) {
        return;
      }
      
      waveAnnouncement.style.display = 'block';
      waveAnnouncement.style.opacity = '0'; // Start from 0 opacity
      waveAnnouncement.dataset.active = 'true';
      
      // Apply animation on next frame
      requestAnimationFrame(() => {
        // Include both the entry animation and the continuous rainbow glow
        const glowAnimation = isBossWave ? 'bossRainbowGlow 2s ease-in-out infinite' : 'rainbowGlow 3s ease-in-out infinite';
        waveAnnouncement.style.animation = `waveCardEntry 1.2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards, ${glowAnimation}`;
        waveAnnouncement.style.opacity = ''; // Let animation control opacity
      });
    });
    
    // Hide after showing
    const hideTimeout = setTimeout(() => {
      // Only hide if still active and showing
      if (waveAnnouncement.dataset.active === 'true' && waveAnnouncement.style.display !== 'none') {
        if (game && game.state === STATE.RUN) {
          waveAnnouncement.style.animation = 'waveCardExit 0.4s ease-out forwards';
          const removeTimeout = setTimeout(() => {
            waveAnnouncement.style.display = 'none';
            waveAnnouncement.style.opacity = '';
            waveAnnouncement.dataset.active = 'false';
            waveAnnouncement.style.animation = '';
          }, 400);
          waveAnnouncementTimeouts.push(removeTimeout);
        } else {
          // If not in RUN state, hide immediately
          waveAnnouncement.style.display = 'none';
          waveAnnouncement.style.opacity = '';
          waveAnnouncement.dataset.active = 'false';
          waveAnnouncement.style.animation = '';
        }
      }
    }, 2500);
    waveAnnouncementTimeouts.push(hideTimeout);
  }

  // ===== Powerup Selection =====
  function showPowerupDialog() {
    // Pause game for powerup selection (different from manual pause)
    if (game && game.state === STATE.RUN) {
      setState(game, STATE.POWERUP);
    }
    
    // Cleanly hide wave announcement if it's showing
    if (waveAnnouncement.dataset.active === 'true' || waveAnnouncement.style.display !== 'none') {
      waveAnnouncementTimeouts.forEach(timeout => clearTimeout(timeout));
      waveAnnouncementTimeouts = [];
      waveAnnouncement.dataset.active = 'false';
      waveAnnouncement.style.animation = 'waveCardExit 0.2s ease-out forwards';
      setTimeout(() => {
        waveAnnouncement.style.display = 'none';
        waveAnnouncement.style.animation = ''; // Clear animation
      }, 200);
    }
    
    // Also ensure game start overlay is hidden
    gameStartOverlay.style.animation = 'none';
    gameStartOverlay.style.opacity = '0';
    
    // Hide powerup notification if it's showing
    powerupNotification.style.animation = 'none';
    powerupNotification.style.display = 'none';
    
    // Filter out maxed upgrades
    const p = game.player;
    const availablePowerups = staticPowerups.filter(powerup => {
      // Shield maxed at 90%
      if (powerup.id === 'shield' && (p.damageReduction || 0) >= 0.9) {
        return false;
      }
      // Knockback resistance maxed at 100%
      if (powerup.id === 'knockbackImmune' && (p.knockbackResistance || 0) >= 1.0) {
        return false;
      }
      // Critical chance maxed at 50%
      if (powerup.id === 'criticalChance' && (p.criticalChance || 0) >= 0.5) {
        return false;
      }
      // Ammo efficiency maxed at 50% (15 stacks of 5% - reasonable cap)
      if (powerup.id === 'efficient' && (p.ammoEfficiency || 0) >= 0.50) {
        return false;
      }
      return true;
    });
    
    // Select 3 unique random powerups (no duplicates in same selection)
    const selected = [];
    const availableIndices = [...Array(availablePowerups.length).keys()]; // [0,1,2,3,4,...]
    
    while (selected.length < 3 && availableIndices.length > 0) {
      const randomIndex = Math.floor(Math.random() * availableIndices.length);
      const powerupIndex = availableIndices.splice(randomIndex, 1)[0];
      selected.push(availablePowerups[powerupIndex]);
    }
    
    // Populate dialog
    // Update powerup options using arrays
    selected.forEach((powerup, i) => {
      powerupTitles[i].textContent = powerup?.name || 'None';
      powerupDescs[i].textContent = powerup?.desc || 'No more powerups';
    });
    
    // Small delay to ensure all other UI is hidden before showing dialog
    setTimeout(() => {
      powerupDialog.style.display = 'block';
      powerupDialog.style.animation = 'powerupDialogEntry 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
      
      // Animate in powerup options with staggered delays
      const powerupOptions = powerupDialog.querySelectorAll('.powerup-option');
      powerupOptions.forEach((option, index) => {
        option.classList.remove('animate-in');
        setTimeout(() => {
          option.classList.add('animate-in');
        }, 200 + index * 100);
      });
    }, 50); // 50ms delay to ensure UI cleanup
    
    // Add click handlers
    const handleChoice = (choice) => {
      const powerup = selected[choice];
      if (powerup) {
        // Add selection animation to clicked option
        const selectedOption = powerupOptions[choice];
        selectedOption.classList.add('selected');
        
        // Apply powerup (stackable)
        powerup.apply(game.player);
        
        // Track upgrade count for pause menu display
        const currentCount = game.player.upgradeCounts.get(powerup.id) || 0;
        game.player.upgradeCounts.set(powerup.id, currentCount + 1);
        
        // Delay dialog close to show selection animation
        setTimeout(() => {
          // Hide dialog with animation and resume game
          powerupDialog.style.animation = 'powerupDialogExit 0.3s ease-out forwards';
          setTimeout(() => {
            powerupDialog.style.display = 'none';
            selectedOption.classList.remove('selected');
            if (game && game.state === STATE.POWERUP) {
              setState(game, STATE.RUN);
            }
            // Show notification after dialog is fully closed
            showPowerupNotification(powerup.name);
          }, 300);
        }, 200);
      }
    };
    
    // Set up click handlers using array
    powerupOptions.forEach((option, i) => {
      option.onclick = () => handleChoice(i);
    });
  }

  // ===== Random Seeded? (not needed here) =====

  // ===== Game State =====
  const STATE = { MENU:0, RUN:1, PAUSE:2, OVER:3, POWERUP:4 };
  let game = null;

  // State transition validation
  function setState(game, newState) {
    if (!game) return false;
    const validTransitions = {
      [STATE.MENU]: [STATE.RUN],
      [STATE.RUN]: [STATE.PAUSE, STATE.POWERUP, STATE.OVER],
      [STATE.PAUSE]: [STATE.RUN, STATE.MENU, STATE.OVER],
      [STATE.POWERUP]: [STATE.RUN],
      [STATE.OVER]: [STATE.MENU]
    };
    if (validTransitions[game.state] && validTransitions[game.state].includes(newState)) {
      game.state = newState;
      return true;
    }
    return false;
  }

  function newGame(){
    return {
      state: STATE.MENU,
      width: () => canvas.width,
      height: () => canvas.height,
      t: 0,
      wave: 1,
      kills: 0,
      player: makePlayer(canvas.width/2, canvas.height/2),
      spawnTimer: 0,
      waveActive: false, // Wave in progress
      waveEnemiesSpawned: 0, // Enemies spawned this wave
      waveEnemiesTarget: 15, // Total enemies for current wave
      waveBossesSpawned: 0, // Bosses spawned this wave
      waveBossesTarget: 0, // Target bosses for this wave
      maxEnemies: 30, // Base cap, dynamically scaled
      grid: makeSpatialHash(64),
      difficulty: 1,
      paused: false,
      fpsSamples: [],
      fpsSum: 0, // Running sum for efficient FPS calculation
      invulTime: 0,
      damageFlash: 0, // Red vignette flash timer
      // Stats tracking
      shotsFired: 0,
      shotsHit: 0,
      currentCombo: 0,
      highestCombo: 0,
      comboTimer: 0,
    };
  }

  // ===== Spatial Hash (for enemy lookup) =====
  function makeSpatialHash(cell){
    return {
      cell: cell,
      map: new Map(),
      key(ix,iy){ return (ix << 16) | (iy & 0xFFFF); }, // Numeric key instead of string
      reset(){ this.map.clear(); },
      insert(e){
        const ix = Math.floor(e.x / this.cell);
        const iy = Math.floor(e.y / this.cell);
        const k = this.key(ix,iy);
        let arr = this.map.get(k);
        if (!arr){ arr = []; this.map.set(k, arr); }
        arr.push(e);
        e._cellX = ix; e._cellY = iy;
      },
      near(x,y){
        const ix = Math.floor(x / this.cell);
        const iy = Math.floor(y / this.cell);
        const out = [];
        for (let dx = -1; dx <= 1; dx++){
          for (let dy = -1; dy <= 1; dy++){
            const k = this.key(ix+dx, iy+dy);
            const arr = this.map.get(k);
            if (arr) out.push(...arr);
          }
        }
        return out;
      }
    };
  }

  // ===== Object Pools =====
  const MAX_PARTICLES = 500; // Hard cap on total particles
  const MAX_BLOOD_STAINS = 200; // Hard cap on blood stains
  const MAX_FOOTSTEPS = 300; // Hard cap on footstep marks
  let activeParticleCount = 0; // Used for efficient particle limit checking
  
  function makePool(createFn, initial=0, maxSize=1000){
    const items = [];
    for (let i=0;i<initial;i++) items.push(createFn());
    return {
      items,
      spawn(initFn){
        for (let i=0;i<items.length;i++){
          const it = items[i];
          if (!it.alive){
            initFn(it); it.alive = true;
            return it;
          }
        }
        // Check pool size limit
        if (items.length >= maxSize) {
          // Try to reuse any dead item one more time
          const deadItem = items.find(it => !it.alive);
          if (deadItem) {
            initFn(deadItem); deadItem.alive = true;
            return deadItem;
          }
          return null; // Pool is full, cannot spawn
        }
        const it = createFn();
        initFn(it); it.alive = true;
        items.push(it);
        return it;
      }
    };
  }

  // ===== Entities =====
  function makePlayer(x,y){
    return {
      x, y,
      vx:0, vy:0,
      speed: 260,
      radius: 12,
      color: '#00ff00',
      hp: 100,
      maxHp: 100,
      stamina: 100,
      exhausted: 0, // Exhaustion cooldown timer
      ammo: Infinity,
      upgradeShots: 0, // V-formation upgrade shots remaining
      bulletType: 'normal', // Legacy - kept for compatibility 
      bulletTimer: 0, // Legacy - kept for compatibility
      bulletPattern: 'single', // Legacy - kept for compatibility
      patternTimer: 0, // Legacy - kept for compatibility
      // New modular effects system
      activeEffects: new Map(), // Map of effect type -> remaining shots
      // New multiplicative pattern system
      patternMultipliers: new Map(), // Map of pattern type -> remaining shots
      fireDelay: 0.12,
      fireTimer: 0,
      // Weapon overheat system
      heat: 0,
      maxHeat: 100,
      overheated: false,
      heatPerShot: 2, // Base heat per shot (50 shots to overheat)
      heatDissipation: 25, // Heat dissipated per second when not firing
      overheatCooldown: 40, // Heat level to recover to after overheating
      heatEfficiencyMod: 1.0, // Modifier from upgrades
      dashCd: 0, dashReady: true,
      // Emergency leap system
      leapCd: 0, leapReady: true,
      leapDistance: 120, // Distance of leap
      leapSpeed: 1200, // Speed during leap
      // Static powerups
      staticPowerups: [],
      // Upgrade tracking for pause menu display
      upgradeCounts: new Map(),
      healthRegen: false,
      staminaRegen: 1.0,
      bulletSize: 1.0,
      bulletSpeed: 1.0,
      piercingShot: false,
      damageReduction: 0,
      knockbackImmune: false,
      magneticCrystals: false,
      lucky: false,
      healthRegenTimer: 0,
    };
  }

  const bullets = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, r:4, life:0, maxLife: 1.0, 
    type:'normal', pierces:0, bounces:0, homingTarget:null, 
    hitEnemies: new Set(),
    effectSet: new Set() // O(1) effect lookups instead of O(n) array.includes()
  }));

  const enemies = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, r:14, hp:2, speed: 90, touchDmg: 12, color:'#ff5b6e',
    deathTimer: 0, dying: false, originalColor: '#ff5b6e', behavior: 'stalker', isShooter: false
  }));

  const particles = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, life:0, maxLife:0.3, size:2, color:'#ffffff'
  }));

  const pickups = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, type:'upgrade', bounceTimer:0, collected:false
  }));

  const bloodStains = makePool(() => ({
    alive:false, x:0, y:0, life:0, maxLife:6.0, size:2, alpha:1.0, vx:0, vy:0, settled:false
  }));

  const footsteps = makePool(() => ({
    alive:false, x:0, y:0, life:0, maxLife:3.0, size:6, alpha:0.3, angle:0, isPlayer:false, isLeft:false
  }));

  const enemyBullets = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, r:3, life:0, maxLife:3.0
  }));

  const mines = makePool(() => ({
    alive:false, x:0, y:0, r:8, fuseTime:0, maxFuseTime:30.0, isArmed:false,
    triggerRadius:35, explosionRadius:70, explosionDamage:8, flashTimer:0, 
    isTriggered:false, owner:null
  }));

  // Bullet powerup types
  const bulletPowerups = [
    {type: 'upgrade', color: '#32CD32', shots: 50, name: 'Dual Shot'},
    {type: 'triple', color: '#00BFFF', shots: 50, name: 'Triple Shot'},
    {type: 'quad', color: '#FF1493', shots: 50, name: 'Quad Shot'},
    {type: 'homing', color: '#FFD700', shots: 25, name: 'Homing'},
    {type: 'explosive', color: '#FF4500', shots: 50, name: 'Explosive'},
    {type: 'ricochet', color: '#FF69B4', shots: 50, name: 'Ricochet'},
    {type: 'lightning', color: '#00BFFF', shots: 50, name: 'Lightning'},
    {type: 'freeze', color: '#00CED1', shots: 50, name: 'Freeze Shot'},
    {type: 'shotgun', color: '#8B4513', shots: 50, name: 'Shrapnel'},
    {type: 'cluster', color: '#FFA500', shots: 50, name: 'Cluster'},
    {type: 'seeking', color: '#DC143C', shots: 50, name: 'Seeking'}
  ];

  // Create O(1) lookup map to replace O(n) Array.find() calls
  const bulletPowerupMap = new Map();
  for (const powerup of bulletPowerups) {
    bulletPowerupMap.set(powerup.type, powerup);
  }

  // Pre-compute filtered arrays to eliminate O(n) filter operations
  const nonHomingPowerups = bulletPowerups.filter(bp => bp.type !== 'homing');
  const nonHomingLength = nonHomingPowerups.length;

  // Enemy types for variety
  const enemyTypes = [
    {r:14, hp:1, speed:120, dmg:5, color:'#AAFF00', name:'stalker'}, // yellow-green (medium speed)
    {r:12, hp:1, speed:180, dmg:5, color:'#FF8800', name:'wraith'}, // bright orange (very fast) - increased from 10
    {r:18, hp:3, speed:80, dmg:8, color:'#00CCFF', name:'brute'}, // sky blue (slow)
    {r:14, hp:2, speed:220, dmg:5, color:'#FF2200', name:'swarm'}, // red-orange (blazing fast) - increased from 12
  ];

  // Behavior pools - unlock new behaviors every 2 waves (earlier unlocks for fun)
  const behaviorPools = [
    // Wave 1: Basic behaviors with volatiles (NO bombers)
    ['stalker', 'serpent', 'leaper', 'volatile'],
    // Waves 2-3: Add bombers and more behaviors (2x prowler weight)
    ['stalker', 'serpent', 'prowler', 'prowler', 'berserker', 'leaper', 'volatile', 'bomber'],
    // Waves 4-5: Add juggernauts and dividers (2x prowler weight)
    ['stalker', 'serpent', 'prowler', 'prowler', 'berserker', 'leaper', 'volatile', 'juggernaut', 'divider', 'trapper', 'bomber'],
    // Waves 5-6: Add maniac behavior (2x prowler weight)
    ['stalker', 'serpent', 'prowler', 'prowler', 'berserker', 'maniac', 'leaper', 'volatile', 'juggernaut', 'vortex', 'divider', 'trapper', 'bomber'],
    // Waves 7+: All behaviors (2x prowler weight)
    ['stalker', 'serpent', 'prowler', 'prowler', 'berserker', 'maniac', 'leaper', 'volatile', 'juggernaut', 'vortex', 'divider', 'trapper', 'bomber']
  ];

  function spawnEnemy(g, clusterX = null, clusterY = null){
    const w = g.width(), h = g.height();
    const margin = 20;
    let x=0,y=0;
    
    if (clusterX !== null && clusterY !== null) {
      // Spawn in cluster near the provided coordinates
      const spread = 40;
      x = clusterX + (Math.random() - 0.5) * spread;
      y = clusterY + (Math.random() - 0.5) * spread;
    } else {
      // Normal edge spawn
      const side = (Math.random() * 4) | 0; // Faster than Math.floor
      if (side===0){ x=randRange(margin, w-margin); y=-margin; }
      else if (side===1){ x=randRange(margin, w-margin); y=h+margin; }
      else if (side===2){ x=-margin; y=randRange(margin, h-margin); }
      else { x=w+margin; y=randRange(margin, h-margin); }
    }
    enemies.spawn(e => {
      e.x = x; e.y = y;
      e.vx = 0; e.vy = 0;
      
      // Reset shooter status to defaults (behavior will be set later)
      e.isShooter = false;
      e.shootTimer = 0;
      
      // Select enemy type based on wave with swarm replacement logic
      let type;
      if (Math.random() < 0.3) {
        // 30% chance for swarm throughout the game
        type = enemyTypes.find(t => t.name === 'swarm');
      } else {
        // Normal enemy type selection (excluding swarm)
        const baseTypes = enemyTypes.filter(t => t.name !== 'swarm');
        const availableTypes = Math.min(baseTypes.length, 1 + Math.floor(g.wave/3));
        type = baseTypes[(Math.random() * availableTypes) | 0];
      }
      
      // Apply type stats with difficulty scaling (reduced by 30%)
      const diff = 1 + g.wave * 0.06; // Gentler scaling (was 0.084)
      // Add ±10% size variance for visual variety
      const sizeVariance = 0.9 + Math.random() * 0.2; // 0.9 to 1.1
      e.r = type.r * sizeVariance;
      e.hp = Math.ceil(type.hp * diff);
      e.speed = Math.min(500, type.speed * diff * (0.85 + Math.random() * 0.3)); // ±15% speed variance, capped at 500
      e.touchDmg = Math.ceil(type.dmg * diff * 0.7); // Additional 30% reduction for damage
      // Add slight color variation for each speed-based color
      const colorVariations = {
        '#AAFF00': ['#99FF00', '#BBFF00', '#AAFF00', '#88FF00'], // Stalker - yellow-green
        '#FF8800': ['#FF7700', '#FF9900', '#FF8800', '#FFAA00'], // Wraith - bright orange  
        '#00CCFF': ['#00BBFF', '#00DDFF', '#00CCFF', '#00AAFF'], // Brute - sky blue
        '#FF2200': ['#FF1100', '#FF3300', '#FF2200', '#FF4400'], // Swarm - red-orange
        '#FF0000': ['#FF0000', '#FF2222', '#EE0000', '#CC0000'], // Overlord - pure red
        '#FFCC00': ['#FFBB00', '#FFDD00', '#FFCC00', '#FFAA00'], // Elite - golden
        '#00FF88': ['#00FF77', '#00FF99', '#00FF88', '#00FFAA'], // Gunners - cyan-green
        '#FF4400': ['#FF3300', '#FF5500', '#FF4400', '#FF6600'], // Volatile - orange-red
        '#CC44FF': ['#BB33FF', '#DD55FF', '#CC44FF', '#AA22FF'], // Juggernaut - magenta
        '#00FFCC': ['#00FFBB', '#00FFDD', '#00FFCC', '#00FFAA'], // Vortex - cyan
        '#FF6600': ['#FF5500', '#FF7700', '#FF6600', '#FF8800'], // Berserker - orange
        '#0088FF': ['#0077FF', '#0099FF', '#0088FF', '#00AAFF'], // Divider - blue
        '#4444FF': ['#3333FF', '#5555FF', '#4444FF', '#6666FF'], // Trapper - blue-purple
        '#8844FF': ['#7733FF', '#9955FF', '#8844FF', '#AA66FF'], // Bomber - purple
        '#FFAA00': ['#FF9900', '#FFBB00', '#FFAA00', '#FFCC00'], // Maniac - yellow-orange
        '#88FF00': ['#77FF00', '#99FF00', '#88FF00', '#AAFF00']  // Prowler/Serpent - lime
      };
      // ENSURE EVERY ENEMY STARTS WITH A VALID COLOR
      const baseColor = type.color || '#ff4444'; // Default to red if no color
      const variations = colorVariations[baseColor] || ['#ff4444']; // Fallback array
      const selectedColor = variations[(Math.random() * variations.length) | 0] || '#ff4444';
      
      // SET ALL THREE COLOR PROPERTIES TO THE SAME VALID COLOR
      e.color = selectedColor;
      e.originalColor = selectedColor;
      e.baseColor = selectedColor;
      e.deathTimer = 0;
      e.dying = false;
      
      // Boss spawning logic - limited per wave
      if (g.wave % 10 === 0 && g.waveBossesSpawned < g.waveBossesTarget) {
        // Super boss spawn (limited quantity per wave)
        e.r *= 3; e.hp *= 9; e.touchDmg *= 1.5;
        e.speed *= 1.5; // 1.5x speed boost for super bosses
        e.color = '#FF0000'; e.originalColor = '#FF0000'; e.behavior = 'superboss'; // Pure red (fastest)
        e.phaseTimer = 0; // Timer for behavior changes
        e.currentPhase = 0; // Current movement phase
        g.waveBossesSpawned++;
      } else if (g.wave % 5 === 0 && g.wave % 10 !== 0 && Math.random() < 0.1) {
        // Mini-boss every 5 waves (10% chance)
        e.r *= 1.3; e.hp *= 2; e.touchDmg *= 1.3;
        e.color = '#FFCC00'; e.originalColor = '#FFCC00'; e.behavior = 'boss'; // Golden yellow (fast)
      } else {
        // First select behavior from available pool based on current wave
        // Wave 1 = pool 0, Wave 2-3 = pool 1, Wave 4-5 = pool 2, etc.
        let poolIndex = 0;
        if (g.wave >= 7) poolIndex = 4;
        else if (g.wave >= 5) poolIndex = 3;
        else if (g.wave >= 4) poolIndex = 2;
        else if (g.wave >= 2) poolIndex = 1;
        const availableBehaviors = behaviorPools[poolIndex];
        e.behavior = availableBehaviors[(Math.random() * availableBehaviors.length) | 0];
        
        // THEN check if this slow/medium enemy becomes a shooter (25% chance)
        // This preserves the behavior but adds shooting capability
        // EXCEPT volatile enemies cannot be shooters (too dangerous combo)
        if (type.speed <= 120 && Math.random() < 0.25 && e.behavior !== 'volatile') {
          e.isShooter = true;
          e.shootTimer = Math.random() * 2.0; // Random initial delay
          
          // Determine shooter pattern based on wave and chance
          const rand = Math.random();
          if (g.wave >= 3 && rand < 0.3) {
            e.shootPattern = 'spread';
            e.color = '#00FF88'; 
            e.originalColor = '#00FF88';
            e.baseColor = '#00FF88'; // Cyan-green for spread shooter (slow)
          } else if (g.wave >= 5 && rand < 0.6) {
            e.shootPattern = 'burst';
            e.burstCount = 0; // Track bursts in sequence
            e.color = '#00FF88'; 
            e.originalColor = '#00FF88';
            e.baseColor = '#00FF88'; // Cyan-green for burst shooter (slow)
          } else {
            e.shootPattern = 'single';
            e.color = '#00FF88'; 
            e.originalColor = '#00FF88';
            e.baseColor = '#00FF88'; // Cyan-green for single shooter (slow)
          }
        }
      }
      
      // Set special colors and stats for specific behaviors (preserve shooter status)
      if (e.behavior === 'volatile') {
        // Only set color if not already a shooter (shooters keep their color)
        if (!e.isShooter) {
          e.color = '#FF4400'; // Orange-red for suicide crawlers (very fast)
          e.originalColor = '#FF4400';
          e.baseColor = '#FF4400'; // Used during orbiting state
        }
        // Speed cap for suicide crawlers to prevent crazy speeds
        e.speed = Math.min(e.speed, Math.min(400, 180 + g.wave * 5)); // More gradual speed increase
      } else if (e.behavior === 'juggernaut') {
        // Make them extra tanky and slow
        e.hp = Math.ceil(e.hp * 1.8); // 80% more HP
        e.speed *= 0.7; // 30% slower
        e.touchDmg = Math.ceil(e.touchDmg * 1.3); // 30% more damage
        e.color = '#CC44FF'; // Magenta for slowpush tanks (slowest)
        e.originalColor = '#CC44FF';
        e.baseColor = '#CC44FF';
        e.knockbackStrength = 250; // Knockback force
        
        // Shield system
        const baseShieldHP = 15;
        const diff = 1 + g.wave * 0.06; // Gentler scaling
        e.shieldHP = Math.ceil(baseShieldHP * diff);
        e.maxShieldHP = e.shieldHP;
        e.hasShield = true;
        
        // Shield direction tracking (90% speed for counterplay)
        e.shieldDirection = { x: 1, y: 0 }; // Initial direction
      } else if (e.behavior === 'vortex') {
        // Make them distinctive and slower
        e.speed = Math.min(500, e.speed * 0.8); // 20% slower for spiral shooters, capped at 500
        e.color = '#00FFCC'; // Cyan for spiral shooters (slow)
        e.originalColor = '#00FFCC';
        e.baseColor = '#00FFCC';
      } else if (e.behavior === 'berserker') {
        // Speed cap for dash zombies to prevent crazy dash speeds
        e.speed = Math.min(e.speed, Math.min(400, 150 + g.wave * 4)); // More gradual speed increase
        e.color = '#FF6600'; // Orange for charge enemies (very fast)
        e.originalColor = '#FF6600';
        e.baseColor = '#FF6600';
      } else if (e.behavior === 'divider') {
        // Make them slightly tankier and distinctive
        e.hp = Math.ceil(e.hp * 1.3); // 30% more HP
        e.r = Math.ceil(e.r * 1.1); // 10% bigger
        e.color = '#0088FF'; // Blue for splitters (very slow)
        e.originalColor = '#0088FF';
        e.baseColor = '#0088FF';
      } else if (e.behavior === 'trapper') {
        // Make them slower and distinctive
        e.speed *= 0.8; // 20% slower (plus 30% in behavior = 44% total reduction)
        e.color = '#4444FF'; // Blue-purple for mine layers (very slow)
        e.originalColor = '#4444FF';
        e.baseColor = '#4444FF';
      } else if (e.behavior === 'bomber') {
        // Grenadiers - throw grenades at player
        e.speed *= 0.7; // 30% slower, they rely on ranged attacks
        e.color = '#8844FF'; // Purple for grenadiers (very slow)
        e.originalColor = '#8844FF';
        e.baseColor = '#8844FF';
        e.r *= 1.1; // Slightly bigger
      } else if (e.behavior === 'maniac') {
        // Erratic enemies - use yellow-orange for medium-fast chaotic movement
        if (!e.isShooter) {
          e.color = '#FFAA00'; // Yellow-orange for erratic (fast bursts)
          e.originalColor = '#FFAA00';
          e.baseColor = '#FFAA00';
        }
        e.speed *= 1.2; // 20% speed boost for maniacs
      } else if (e.behavior === 'prowler' || e.behavior === 'serpent') {
        // Flanking and zigzag patterns with appropriate speed colors
        if (!e.isShooter) {
          if (e.behavior === 'prowler') {
            // Prowlers are fast (40% boost) - use orange color
            e.color = '#FF8800'; // Orange for fast flanking
            e.originalColor = '#FF8800';
            e.baseColor = '#FF8800';
          } else {
            // Serpents are medium-fast (30% boost) - use yellow-green
            e.color = '#AAFF00'; // Yellow-green for medium-fast zigzag
            e.originalColor = '#AAFF00';
            e.baseColor = '#AAFF00';
          }
        }
        if (e.behavior === 'prowler') {
          e.speed *= 1.4; // 40% speed boost for prowlers to flank effectively
        } else if (e.behavior === 'serpent') {
          e.speed *= 1.3; // 30% speed boost for serpents
        }
      } else if (e.behavior === 'stalker') {
        // Keep default color unless shooter
        if (e.isShooter) {
          // Ensure shooter color is preserved
          e.color = '#00FF88';
          e.originalColor = '#00FF88';
          e.baseColor = '#00FF88';
        }
      } else if (e.behavior === 'leaper') {
        // Make leapers 30% faster base speed
        e.speed *= 1.3;
      }
      
      // Random spawn animation - DISABLE FADE TO PREVENT INVISIBILITY
      e.spawnAnimation = 'scale'; // Only use scale, never fade
      e.spawnTimer = 0.5; // 0.5 second spawn animation
      
      e.alive = true;
    });
  }

  // Calculate bullet count and directions from active pattern multipliers
  // Handle enemy death and crystal drops consistently
  function handleEnemyDeath(enemy, game) {
    if (enemy.hp <= 0 && !enemy.dying) {
      // Start death animation instead of immediate removal
      enemy.dying = true;
      enemy.deathTimer = 0.2; // 0.2 second death animation
      
      // Enemy death sound based on type/size
      enemyDeathSound(enemy);
      
      // Large blood burst on death
      spawnBlood(enemy.x, enemy.y, 0, 0, 'death');
      
      // Volatile explosion - bigger and more dramatic
      if (enemy.behavior === 'volatile') {
        // Extra explosion sound
        beep(80, 0.2, 'sawtooth', 0.15); // Deep explosion boom
        
        // Large explosion particles with shockwave effect
        const explosionParticles = 35; // More particles for bigger explosion
        
        // Create expanding shockwave ring
        for (let i = 0; i < 20; i++) {
          particles.spawn(p => {
            const angle = (i / 20) * TAU;
            const speed = 250; // Uniform speed for ring effect
            p.x = enemy.x; p.y = enemy.y;
            p.vx = fastCos(angle) * speed;
            p.vy = fastSin(angle) * speed;
            p.life = 0; p.maxLife = 0.4; // Short lived for shockwave
            p.size = 6; // Medium size
            p.color = '#ff8800'; // Orange shockwave
            p.hasGravity = false;
            p.alive = true;
          });
        }
        
        // Main explosion particles
        for (let i = 0; i < explosionParticles; i++) {
          particles.spawn(p => {
            const angle = (i / explosionParticles) * TAU + Math.random() * 0.4;
            const speed = randRange(200, 450); // Faster particles
            p.x = enemy.x; p.y = enemy.y;
            p.vx = fastCos(angle) * speed;
            p.vy = fastSin(angle) * speed;
            p.life = 0; p.maxLife = randRange(0.6, 1.2); // Longer lasting
            p.size = randRange(4, 9); // Bigger particles
            // Purple-orange explosion to match enemy color
            if (Math.random() < 0.3) {
              p.color = '#8844ff'; // Some purple (enemy color)
            } else {
              // Orange explosion with variation
              const orangeBase = 0xff;
              const orangeGreen = 0x44 + Math.floor(Math.random() * 40) - 20;
              p.color = '#' + orangeBase.toString(16) + Math.max(0x20, Math.min(0x88, orangeGreen)).toString(16).padStart(2,'0') + '00';
            }
            p.hasGravity = false;
            p.alive = true;
          });
        }
        
        // Damage player if close enough (explosion radius)
        const explosionRadius = 80; // Increased from 45 for more danger
        const distToPlayer = fastLength(enemy.x - game.player.x, enemy.y - game.player.y);
        if (distToPlayer <= explosionRadius && game.invulTime <= 0) {
          // Apply damage with reduction
          const explosionDamage = 8; // Base explosion damage
          const actualDamage = Math.ceil(explosionDamage * (1 - game.player.damageReduction));
          game.player.hp -= actualDamage;
          
          // Set invulnerability and damage flash
          game.invulTime = 0.35;
          game.damageFlash = 0.3;
          
          // Knockback from explosion
          const knockbackForce = 400;
          const dx = game.player.x - enemy.x;
          const dy = game.player.y - enemy.y;
          const dist = Math.max(1, distToPlayer);
          game.player.vx += (dx / dist) * knockbackForce;
          game.player.vy += (dy / dist) * knockbackForce;
          
          // Effects
          hurtSound();
          spawnBlood(game.player.x, game.player.y, 0, 0, 'player');
          
          // Check for player death
          if (game.player.hp <= 0) {
            triggerGameOver(game);
          }
        }
        
        // Damage other enemies in explosion radius (friendly fire)
        for (const otherEnemy of enemies.items) {
          if (!otherEnemy.alive || otherEnemy.dying || otherEnemy === enemy) continue;
          
          const distToEnemy = fastLength(enemy.x - otherEnemy.x, enemy.y - otherEnemy.y);
          if (distToEnemy <= explosionRadius) {
            // Scale damage based on distance (closer = more damage)
            const damageFalloff = 1 - (distToEnemy / explosionRadius) * 0.5; // 50-100% damage
            const explosionDamage = Math.ceil(10 * damageFalloff); // 5-10 damage
            otherEnemy.hp -= explosionDamage;
            
            // Knockback from explosion center
            const knockbackForce = 150;
            const dx = otherEnemy.x - enemy.x;
            const dy = otherEnemy.y - enemy.y;
            const dist = Math.max(1, fastLength(dx, dy));
            otherEnemy.vx += (dx / dist) * knockbackForce;
            otherEnemy.vy += (dy / dist) * knockbackForce;
            
            // Handle enemy death if killed by explosion
            if (otherEnemy.hp <= 0 && !otherEnemy.dying) {
              handleEnemyDeath(otherEnemy, game);
            }
          }
        }
      }
      
      // Splitter zombie - spawns 2-3 smaller enemies on death
      if (enemy.behavior === 'divider') {
        const childCount = 2 + Math.floor(Math.random() * 2); // 2-3 children
        const spreadAngle = TAU; // Full circle spread
        
        for (let i = 0; i < childCount; i++) {
          const angle = (i / childCount) * spreadAngle + Math.random() * 0.5; // Even spread with variance
          const distance = randRange(20, 40); // Spawn distance from parent
          
          // Spawn child enemy using existing spawn system
          enemies.spawn(child => {
            child.x = enemy.x + fastCos(angle) * distance;
            child.y = enemy.y + fastSin(angle) * distance;
            child.vx = fastCos(angle) * randRange(50, 100); // Initial velocity away from parent
            child.vy = fastSin(angle) * randRange(50, 100);
            
            // Child stats - smaller and weaker than parent
            child.r = Math.max(9, enemy.r * 0.6); // 60% size, minimum 9 radius (increased from 6)
            child.hp = Math.max(1, Math.floor(enemy.hp * 0.4)); // 40% HP, minimum 1
            child.speed = enemy.speed * 1.2; // 20% faster
            child.touchDmg = Math.max(1, Math.floor(enemy.touchDmg * 0.7)); // 70% damage
            child.color = '#ff66ff'; // Pink for child splitters
            child.originalColor = '#ff66ff';
            child.baseColor = '#ff66ff'; // Ensure all color properties are set
            child.behavior = 'normal'; // Children use normal behavior
            child.deathTimer = 0;
            child.dying = false;
            child.alive = true;
            
            // Clamp to screen bounds
            child.x = clamp(child.x, child.r, game.width() - child.r);
            child.y = clamp(child.y, child.r, game.height() - child.r);
          });
        }
        
        beep(250, 0.08, 'sawtooth', 0.10); // Splitting sound
      }
      
      // Enemy pop/burst effect - satisfying explosion
      const popParticles = enemy.behavior === 'volatile' ? 20 : 15; // More particles for volatile
      for (let i = 0; i < popParticles; i++) {
        particles.spawn(p => {
          const angle = (i / popParticles) * TAU + Math.random() * 0.3; // Even spread with variance
          const speed = randRange(150, 300);
          p.x = enemy.x; p.y = enemy.y;
          p.vx = fastCos(angle) * speed;
          p.vy = fastSin(angle) * speed;
          p.life = 0; p.maxLife = randRange(0.4, 0.8);
          p.size = randRange(3, 6);
          p.color = enemy.originalColor; // Match enemy color
          p.hasGravity = false; // Pure radial burst
          p.alive = true;
        });
      }
      
      // Create realistic blood spray stains
      const numStains = randRange(15, 25);
      for (let i = 0; i < numStains; i++) {
        bloodStains.spawn(stain => {
          // Spray pattern - blood lands in burst around death point
          const angle = Math.random() * TAU;
          const distance = randRange(5, 35);
          stain.x = enemy.x + Math.cos(angle) * distance;
          stain.y = enemy.y + Math.sin(angle) * distance;
          
          // Initial movement (blood droplets still traveling)
          stain.vx = Math.cos(angle) * randRange(20, 80);
          stain.vy = Math.sin(angle) * randRange(20, 80);
          
          stain.life = 0;
          stain.maxLife = 6.0;
          stain.size = randRange(1, 4); // Smaller individual droplets
          stain.alpha = 0.8;
          stain.settled = false;
          stain.alive = true;
        });
      }
      
      // Crystal drop logic - bosses get special treatment
      const p = game.player;
      if (enemy.behavior === 'boss' || enemy.behavior === 'superboss') {
        // Bosses: 20% chance to drop homing crystal
        if (Math.random() < 0.20) {
          spawnBossPickup(enemy.x, enemy.y);
        }
      } else {
        // Special drops for specific enemy types
        if ((enemy.behavior === 'trapper' || enemy.behavior === 'bomber') && Math.random() < 0.01) {
          // 1% chance for minelayers and grenadiers to drop Remote Detonator
          spawnDetonatorPickup(enemy.x, enemy.y);
        } else {
          // Regular enemies: 4% chance to drop any crystal (+20% per lucky upgrade)
          const baseRate = 0.04;
          const luckyMultiplier = 1 + (p.luckyBonus || 0);
          const dropRate = baseRate * luckyMultiplier;
          const roll = Math.random();
          if (roll < dropRate) {
            spawnBulletPickup(enemy.x, enemy.y);
          }
        }
      }
      
      game.kills++;

      // Combo system: increment combo on kill and reset timer
      game.currentCombo++;
      game.comboTimer = 3.0; // 3 second window to chain next kill
      if (game.currentCombo > game.highestCombo) {
        game.highestCombo = game.currentCombo;
      }

      // Vampiric healing
      const player = game.player;
      if (player && player.vampiricHealing) {
        player.hp = Math.min(player.maxHp, player.hp + player.vampiricHealing);
      }
      
      // Check if wave is complete (half of enemies killed)
      const aliveEnemies = enemies.items.filter(e => e.alive && !e.dying).length;
      const enemiesKilledThisWave = game.waveEnemiesSpawned - aliveEnemies;
      if (game.waveActive && enemiesKilledThisWave >= Math.floor(game.waveEnemiesTarget * 0.5)) {
        // Wave complete! Start next wave after brief delay
        game.waveActive = false;
        
        // CRITICAL: Prevent duplicate wave transitions
        if (waveTransitionInProgress) {
          return; // Already transitioning, don't schedule another
        }
        waveTransitionInProgress = true;
        
        // Cancel any existing wave transition
        if (nextWaveTimeoutId) {
          clearTimeout(nextWaveTimeoutId);
        }
        
        // Store timeout ID so we can cancel it if needed
        nextWaveTimeoutId = setTimeout(() => {
          waveTransitionInProgress = false; // Reset flag
          nextWaveTimeoutId = null; // Clear timeout ID
          game.wave++;
          game.waveEnemiesSpawned = 0;
          game.waveBossesSpawned = 0;
          // Proper enemy scaling: Wave 1=15, Wave 10=30, Wave 50=60, Wave 100=90
          // Using a square root-based scaling for gradual increase
          if (game.wave <= 50) {
            // From wave 1-50: 15 to 60 enemies
            // Formula: 15 + 45 * sqrt((wave-1)/49)
            const progress = (game.wave - 1) / 49; // 0 to 1
            game.waveEnemiesTarget = Math.floor(15 + 45 * Math.sqrt(progress));
          } else {
            // From wave 51-100: 60 to 90 enemies
            // Formula: 60 + 30 * ((wave-50)/50)
            const progress = Math.min(1, (game.wave - 50) / 50); // 0 to 1, capped
            game.waveEnemiesTarget = Math.floor(60 + 30 * progress);
          }
          // Set boss target for this wave
          if (game.wave % 10 === 0) {
            game.waveBossesTarget = Math.floor(game.wave / 10); // 1 boss on round 10, 2 on round 20, etc.
          } else {
            game.waveBossesTarget = 0;
          }
          waveSound();
          
          // Only show wave announcement if not in powerup dialog
          if (game.state !== STATE.POWERUP) {
            if (game.wave % 10 === 0) {
              showWaveAnnouncement(game.wave, true);
            } else {
              showWaveAnnouncement(game.wave, false);
            }
          }
          game.waveActive = true;
          
          // Spawn all enemies within 2-4 seconds
          const spawnDuration = 2000 + Math.random() * 2000; // 2-4 seconds
          const spawnInterval = spawnDuration / game.waveEnemiesTarget;
          
          // 30% chance for cluster spawn pattern
          if (Math.random() < 0.3) {
            // Cluster spawn - spawn in groups
            const clustersCount = 2 + Math.floor(Math.random() * 3); // 2-4 clusters
            const enemiesPerCluster = Math.ceil(game.waveEnemiesTarget / clustersCount);
            
            for (let c = 0; c < clustersCount; c++) {
              // Pick random edge for cluster
              const side = (Math.random() * 4) | 0;
              let clusterX, clusterY;
              const w = game.width(), h = game.height();
              if (side===0){ clusterX=randRange(50, w-50); clusterY=-20; }
              else if (side===1){ clusterX=randRange(50, w-50); clusterY=h+20; }
              else if (side===2){ clusterX=-20; clusterY=randRange(50, h-50); }
              else { clusterX=w+20; clusterY=randRange(50, h-50); }
              
              for (let e = 0; e < enemiesPerCluster && game.waveEnemiesSpawned < game.waveEnemiesTarget; e++) {
                const delay = (c * clustersCount * 500) + (e * 100); // Stagger clusters
                setTimeout(() => {
                  if (game.waveActive && game.waveEnemiesSpawned < game.waveEnemiesTarget) {
                    spawnEnemy(game, clusterX, clusterY);
                    game.waveEnemiesSpawned++;
                  }
                }, delay);
              }
            }
          } else {
            // Normal spread spawn
            for (let i = 0; i < game.waveEnemiesTarget; i++) {
              setTimeout(() => {
                if (game.waveActive) {
                  spawnEnemy(game);
                  game.waveEnemiesSpawned++;
                }
              }, i * spawnInterval);
            }
          }
        }, 3000); // 3 second breathing room between waves (allows previous wave card to fully disappear)
      }
      
      // Powerup selection - accelerating progression: 10, 25, 50, 100, then formula-based
      if (!game.level) game.level = 0;
      if (!game.nextLevelup) game.nextLevelup = 10; // First level at 10 kills
      
      if (game.kills >= game.nextLevelup) {
        showPowerupDialog();
        game.level++;
        
        // Calculate kills needed for next level
        let killsForNextLevel;
        if (game.level === 1) {
          killsForNextLevel = 25; // Level 2 needs 25 more
        } else if (game.level === 2) {
          killsForNextLevel = 50; // Level 3 needs 50 more
        } else if (game.level === 3) {
          killsForNextLevel = 100; // Level 4 needs 100 more
        } else {
          // Level 5+: 50 + 50 × (level - 4)
          // Level 5 = 50 + 50×1 = 100, Level 6 = 50 + 50×2 = 150, etc.
          killsForNextLevel = 50 + 50 * (game.level - 3);
        }
        
        game.nextLevelup += killsForNextLevel;
      }
    }
  }

  // Calculate bullet count and directions from active pattern multipliers
  function calculateBulletPattern(player) {
    let totalBullets = 1; // Base single bullet
    
    // Apply all pattern multipliers
    for (const [pattern, shots] of player.patternMultipliers) {
      if (shots > 0) {
        if (pattern === 'triple') totalBullets *= 3;
        else if (pattern === 'quad') totalBullets *= 4;
      }
    }
    
    // Cap at 16 bullets maximum
    totalBullets = Math.min(totalBullets, 16);
    
    // Get mouse direction as the center of the pattern
    const [baseDx, baseDy] = norm(mouseX - player.x, mouseY - player.y);
    const baseAngle = Math.atan2(baseDy, baseDx);
    
    // Calculate evenly spaced angles CENTERED on mouse direction
    const directions = [];
    if (totalBullets === 1) {
      // Single bullet - use mouse direction exactly
      directions.push({dx: baseDx, dy: baseDy});
    } else {
      // Multiple bullets - one ALWAYS points to mouse, others evenly spaced around it
      const angleStep = TAU / totalBullets;
      
      for (let i = 0; i < totalBullets; i++) {
        const angle = baseAngle + (angleStep * i);
        const dx = fastCos(angle);
        const dy = fastSin(angle);
        directions.push({dx, dy});
      }
      
      // First bullet always goes exactly toward mouse
      directions[0] = {dx: baseDx, dy: baseDy};
    }
    
    return {totalBullets, directions};
  }

  function spawnBullet(x,y,dirX,dirY,effects=[]){
    const baseSpeed = 720;
    const player = game?.player;
    const speed = baseSpeed * (player?.bulletSpeed || 1.0);
    const size = 4 * (player?.bulletSize || 1.0);
    
    // Critical hit calculation
    const critChance = player?.criticalChance || 0;
    const isCritical = Math.random() < critChance;
    
    bullets.spawn(b => {
      b.x = x; b.y = y;
      b.vx = dirX * speed;
      b.vy = dirY * speed;
      b.r = size;
      b.life = 0;
      
      // Convert effects array to Set for O(1) lookups (vs O(n) includes())
      b.effectSet.clear();
      for (let i = 0, len = effects.length; i < len; i++) {
        b.effectSet.add(effects[i]); // Faster loop without for-of iterator
      }
      
      b.maxLife = b.effectSet.has('ricochet') ? 4.0 : 2.0;
      b.type = effects.length > 0 ? effects[0] : 'normal'; // Legacy compatibility
      b.effects = effects; // Direct reference instead of spread operator (no new array)
      b.pierces = (player?.piercingCount || 0);
      b.bounces = b.effectSet.has('ricochet') ? 3 : 0;
      b.homingTarget = null;
      b.hitEnemies.clear(); // Reset hit enemies for this bullet
      b.critical = isCritical;
      b.alive = true;
    });
  }


  function spawnEnemyBullet(x, y, targetX, targetY, angleOffset = 0, speedMult = 1.0) {
    const baseAngle = Math.atan2(targetY - y, targetX - x) + angleOffset;
    const dx = fastCos(baseAngle), dy = fastSin(baseAngle);
    const speed = Math.min(350, 200 + game.wave) * speedMult; // 200 base + 1 per wave, capped at 350
    
    enemyBullets.spawn(b => {
      b.x = x;
      b.y = y;
      b.vx = dx * speed;
      b.vy = dy * speed;
      b.r = 3;
      b.life = 0;
      b.maxLife = 3.0;
      b.alive = true;
    });
  }

  // Enhanced shooter patterns
  function spawnEnemyBurstFire(x, y, targetX, targetY, burstCount = 3) {
    for (let i = 0; i < burstCount; i++) {
      spawnEnemyBullet(x, y, targetX, targetY);
    }
  }

  function spawnEnemySpreadShot(x, y, targetX, targetY, bulletCount = 3, spreadAngle = Math.PI/4) {
    const halfSpread = spreadAngle / 2;
    for (let i = 0; i < bulletCount; i++) {
      const angleOffset = bulletCount === 1 ? 0 : 
        -halfSpread + (i / (bulletCount - 1)) * spreadAngle;
      spawnEnemyBullet(x, y, targetX, targetY, angleOffset);
    }
  }

  function spawnBulletPickup(x, y){
    pickups.spawn(p => {
      p.x = x; p.y = y;
      p.vx = (Math.random() - 0.5) * 100;
      // Variable bounce heights
      const bounceVariation = 0.7 + Math.random() * 0.6; // 0.7x to 1.3x
      p.vy = -(Math.random() * 150 + 50) * bounceVariation;
      // Weighted crystal selection - homing is 3x rarer than each regular crystal
      // Weight: 7 regular crystals (weight=1 each) + 1 homing (weight=1/3)
      // Homing probability = (1/3) / (7 + 1/3) = 1/22 ≈ 4.54%
      let selectedPowerup;
      if (Math.random() < 1/22) { // 1/22 = ~4.54% chance for homing
        selectedPowerup = bulletPowerupMap.get('homing');
      } else {
        // Choose from pre-computed non-homing crystals (avoid O(n) filter)
        selectedPowerup = nonHomingPowerups[(Math.random() * nonHomingLength) | 0];
      }
      p.type = selectedPowerup.type;
      p.bounceTimer = 0;
      p.collected = false;
      p.rotationSpeed = 2 + Math.random() * 4; // Random rotation speed between 2-6
      p.rotation = Math.random() * TAU; // Random starting rotation
      p.alive = true;
    });
  }

  function spawnBossPickup(x, y){
    pickups.spawn(p => {
      p.x = x; p.y = y;
      p.vx = (Math.random() - 0.5) * 100;
      // Variable bounce heights (bosses drop with more force)
      const bounceVariation = 1.0 + Math.random() * 0.5; // 1.0x to 1.5x
      p.vy = -(Math.random() * 150 + 50) * bounceVariation;
      // Boss always drops homing crystal
      const homingPowerup = bulletPowerupMap.get('homing');
      p.type = homingPowerup.type;
      p.bounceTimer = 0;
      p.collected = false;
      p.rotationSpeed = 2 + Math.random() * 4; // Random rotation speed between 2-6
      p.rotation = Math.random() * TAU; // Random starting rotation
      p.alive = true;
    });
  }
  
  function spawnDetonatorPickup(x, y){
    pickups.spawn(p => {
      p.x = x; p.y = y;
      p.vx = (Math.random() - 0.5) * 100;
      // Detonators drop with less bounce (heavier)
      const bounceVariation = 0.5 + Math.random() * 0.3; // 0.5x to 0.8x
      p.vy = -(Math.random() * 150 + 50) * bounceVariation;
      p.type = 'detonator'; // Special type for detonator
      p.bounceTimer = 0;
      p.collected = false;
      p.rotationSpeed = 1; // Detonator rotates slowly
      p.rotation = 0; // Start aligned
      p.alive = true;
    });
  }

  function spawnBurst(x,y, n=10, color='#ffffff'){
    const adaptiveN = (n * performanceLevel) | 0; // Bit operation faster than Math.floor
    for (let i=0;i<adaptiveN;i++){
      if (shouldSpawnParticle()) {
        particles.spawn(p => {
          const a = Math.random()*TAU;
          const s = 40 + Math.random() * 120; // Inline randRange for speed
          p.x = x; p.y = y;
          p.vx = fastCos(a)*s;
          p.vy = fastSin(a)*s;
          p.life = 0; 
          // Longer lifespan for explosions (optimized color check)
          const isExplosion = color === '#ff8000' || color === '#ff4000' || color === '#ffff00';
          p.maxLife = isExplosion ? 
                      0.8 + Math.random() * 0.4 : 0.2 + Math.random() * 0.3;
          p.size = isExplosion ? 
                   2 + Math.random() * 4 : 1.5 + Math.random() * 2;
          p.color = color;
          p.hasGravity = false;
          p.alive = true;
        });
      }
    }
  }

  // Pre-computed blood colors to avoid runtime generation
  const BLOOD_COLORS = ['#ff0000', '#cc0000', '#800000', '#990000', '#e60000', '#b30000', '#660000', '#a60000'];
  
  function spawnBlood(x, y, dirX=0, dirY=0, type='impact'){
    // Check blood stain cap
    let activeStains = 0;
    for (const s of bloodStains.items) {
      if (s.alive) activeStains++;
    }
    if (activeStains >= MAX_BLOOD_STAINS) return; // Don't spawn if at cap
    
    
    if (type === 'impact') {
      // Small blood spray from bullet impact
      for (let i=0; i<8; i++){
        particles.spawn(p => {
          const spread = 0.6;
          const baseAngle = dirX !== 0 || dirY !== 0 ? Math.atan2(dirY, dirX) : Math.random() * TAU;
          const angle = baseAngle + (Math.random()-0.5)*spread;
          const speed = 80 + Math.random() * 100; // Inline for speed
          p.x = x; p.y = y;
          p.vx = fastCos(angle) * speed;
          p.vy = fastSin(angle) * speed;
          p.life = 0; p.maxLife = 0.3 + Math.random() * 0.5; // Inline randRange
          p.size = 1 + Math.random() * 2; // Inline randRange
          p.color = BLOOD_COLORS[(Math.random() * BLOOD_COLORS.length) | 0];
          p.hasGravity = true;
          p.alive = true;
        });
      }
    } else if (type === 'death') {
      // Large blood burst when enemy dies
      const deathParticleCount = performanceLevel > 0.5 ? 15 : 8;
      for (let i=0; i<deathParticleCount; i++){
        particles.spawn(p => {
          const angle = Math.random() * TAU;
          const speed = 60 + Math.random() * 190; // Inline randRange
          p.x = x; p.y = y;
          p.vx = fastCos(angle) * speed;
          p.vy = fastSin(angle) * speed;
          p.life = 0; p.maxLife = 0.8 + Math.random() * 0.7; // Inline randRange
          p.size = 2 + Math.random() * 4; // Inline randRange
          p.color = BLOOD_COLORS[(Math.random() * BLOOD_COLORS.length) | 0];
          p.hasGravity = true;
          p.alive = true;
        });
      }
    } else if (type === 'player') {
      // Player damage - red particles flying outward
      const playerParticleCount = performanceLevel > 0.5 ? 10 : 5;
      for (let i=0; i<playerParticleCount; i++){
        particles.spawn(p => {
          const angle = Math.random() * TAU;
          const speed = 100 + Math.random() * 100; // Inline randRange
          p.x = x; p.y = y;
          p.vx = fastCos(angle) * speed;
          p.vy = fastSin(angle) * speed;
          p.life = 0; p.maxLife = 0.4 + Math.random() * 0.3; // Inline randRange
          p.size = 2 + Math.random() * 2; // Inline randRange
          p.color = '#ff0000';
          p.hasGravity = true;
          p.alive = true;
        });
      }
    }
  }

  // Footstep spawning function
  function spawnFootstep(x, y, angle, isPlayer = false, entity = null) {
    // Check footstep cap
    let activeFootsteps = 0;
    for (const f of footsteps.items) {
      if (f.alive) activeFootsteps++;
    }
    if (activeFootsteps >= MAX_FOOTSTEPS) return;
    
    // Track which foot for alternating steps
    if (!entity.nextFoot) entity.nextFoot = false;
    const isLeft = entity.nextFoot;
    entity.nextFoot = !entity.nextFoot;
    
    // Calculate perpendicular offset for left/right foot placement
    const perpOffset = isPlayer ? 4 : 3;
    const perpX = Math.cos(angle + Math.PI/2) * perpOffset * (isLeft ? 1 : -1);
    const perpY = Math.sin(angle + Math.PI/2) * perpOffset * (isLeft ? 1 : -1);
    
    footsteps.spawn(f => {
      f.x = x + perpX;
      f.y = y + perpY;
      f.life = 0;
      f.maxLife = 3.0; // Moderate fade time
      f.size = isPlayer ? 7 : 5; // Slightly larger
      f.alpha = 0.35; // More opaque start
      f.angle = angle; // Direction of movement
      f.isPlayer = isPlayer;
      f.isLeft = isLeft;
      f.alive = true;
    });
  }

  // ===== Gradient Cache (for performance) =====
  const gradientCache = new Map();
  const MAX_GRADIENT_CACHE_SIZE = 100;
  
  // ===== Update & Draw =====
  function update(g, dt){
    g.t += dt;
    if (g.invulTime > 0) g.invulTime -= dt;
    if (g.damageFlash > 0) g.damageFlash -= dt;

    // Combo timer decay
    if (g.comboTimer > 0) {
      g.comboTimer -= dt;
      if (g.comboTimer <= 0) {
        g.currentCombo = 0; // Reset combo when timer expires
      }
    }

    // Static powerup effects
    const p = g.player;
    if (p.healthRegenRate > 0) {
      p.healthRegenTimer = (p.healthRegenTimer || 0) - dt;
      if (p.healthRegenTimer <= 0) {
        p.hp = Math.min(p.hp + p.healthRegenRate, p.maxHp);
        p.healthRegenTimer = 1.0; // Check every second
      }
    }

    // Input -> movement (keyboard + touch)
    let ax=0, ay=0;
    if (keys.has('KeyW')) ay -= 1;
    if (keys.has('KeyS')) ay += 1;
    if (keys.has('KeyA')) ax -= 1;
    if (keys.has('KeyD')) ax += 1;
    
    // Improved touch movement with virtual joystick
    if (touchMove.active) {
      const deadZone = 15; // Smaller dead zone for better responsiveness
      const touchDx = touchMove.x - touchMove.startX;
      const touchDy = touchMove.y - touchMove.startY;
      const touchDist = fastLength(touchDx, touchDy);
      
      if (touchDist > deadZone) {
        // Normalize and scale the input
        const maxDist = 60; // Maximum joystick distance
        const scale = Math.min(touchDist, maxDist) / maxDist;
        const angle = Math.atan2(touchDy, touchDx);
        
        ax += Math.cos(angle) * scale * 1.2; // Increased sensitivity
        ay += Math.sin(angle) * scale * 1.2;
      }
    }
    
    // Exhaustion cooldown
    if (p.exhausted > 0) p.exhausted -= dt;
    
    // Adrenaline timer countdown
    if (p.adrenalineTimer > 0) p.adrenalineTimer -= dt;
    
    // Leap cooldown
    if (p.leapCd > 0) {
      p.leapCd -= dt;
      if (p.leapCd <= 0) p.leapReady = true;
    }
    
    // Emergency leap (Space key)
    if (keys.has('Space') && p.leapReady && (ax || ay)) {
      const leapVec = normInPlace(ax, ay, vecPool.temp1);
      p.vx += leapVec.x * p.leapSpeed;
      p.vy += leapVec.y * p.leapSpeed;
      p.leapCd = 3.0; // 3 second cooldown
      p.leapReady = false;
      beep(400, 0.08, 'triangle', 0.03); // Leap sound effect
    }
    
    // Stamina system
    const wantsToSprint = keys.has('ShiftLeft') || keys.has('ShiftRight');
    const canSprint = p.stamina > 0 && p.exhausted <= 0;
    const isSprinting = wantsToSprint && canSprint && (ax || ay);
    
    // Store sprinting state for HUD updates
    p.isSprinting = isSprinting;
    
    if (isSprinting) {
      // Drain stamina: 20% per second (100% in 5 seconds)
      const oldStamina = p.stamina;
      p.stamina = Math.max(0, p.stamina - 20 * dt);
      
      // If stamina just hit 0, trigger exhaustion
      if (oldStamina > 0 && p.stamina <= 0) {
        const baseExhaustion = 2.0; // 2 second cooldown
        const reduction = p.dashCooldownReduction || 0;
        p.exhausted = baseExhaustion * (1 - reduction);
        staminaDepletedSound(); // Play unique 2-pulse sound
      }
    } else {
      // Regenerate stamina: 12.5% per second (0% to 100% in 8 seconds) + stamina boost
      p.stamina = Math.min(100, p.stamina + 12.5 * dt * p.staminaRegen);
    }
    
    if (ax || ay){
      const moveVec = normInPlace(ax, ay, vecPool.temp1);
      const nx = moveVec.x, ny = moveVec.y;
      const waveSpeedBonus = g.wave * 0.4; // +0.4 speed per wave
      const adrenalineBonus = (p.adrenalineTimer > 0) ? 1.2 : 1.0; // +20% speed during adrenaline
      const baseSpeed = (p.speed + waveSpeedBonus) * adrenalineBonus;
      const speed = Math.min(500, isSprinting ? baseSpeed*1.6 : baseSpeed); // Hard cap at 500
      p.vx += nx * speed * dt * 4;
      p.vy += ny * speed * dt * 4;
    }
    // friction
    p.vx *= (1 - 6*dt);
    p.vy *= (1 - 6*dt);
    // integrate
    p.x = clamp(p.x + p.vx*dt, p.radius, g.width()-p.radius);
    p.y = clamp(p.y + p.vy*dt, p.radius, g.height()-p.radius);
    
    // Spawn footsteps when moving
    if (!p.footstepTimer) p.footstepTimer = 0;
    const playerSpeed = fastLength(p.vx, p.vy);
    if (playerSpeed > 30) { // Only spawn when actually moving
      p.footstepTimer -= dt;
      if (p.footstepTimer <= 0) {
        const moveAngle = Math.atan2(p.vy, p.vx);
        spawnFootstep(p.x, p.y, moveAngle, true, p);
        // Faster footsteps when sprinting
        p.footstepTimer = isSprinting ? 0.15 : 0.25;
      }
    }

    // Heat dissipation when not firing
    if (!mouseDown || p.overheated) {
      p.heat = Math.max(0, p.heat - p.heatDissipation * dt);
      
      // Recovery from overheat state
      if (p.overheated && p.heat <= p.overheatCooldown) {
        p.overheated = false;
      }
    }
    
    // Calculate heat-based penalties
    let heatSpreadMod = 0;
    let heatFireRateMod = 1.0;
    let canFire = true;
    
    const weaponHeatPercent = p.heat / p.maxHeat;
    if (weaponHeatPercent >= 0.5 && weaponHeatPercent < 0.75) {
      // 50-75% heat: Slight spread increase
      heatSpreadMod = 0.03;
    } else if (weaponHeatPercent >= 0.75 && weaponHeatPercent < 0.9) {
      // 75-90% heat: More spread, 15% slower fire rate
      heatSpreadMod = 0.06;
      heatFireRateMod = 1.15;
    } else if (weaponHeatPercent >= 0.9 && weaponHeatPercent < 1.0) {
      // 90-100% heat: Heavy spread, 30% slower fire rate, rapid heat gain
      heatSpreadMod = 0.10;
      heatFireRateMod = 1.3;
    } else if (p.heat >= p.maxHeat) {
      // Overheated: Weapon locked
      p.overheated = true;
      p.heat = Math.min(p.heat, p.maxHeat); // Cap at max
      canFire = false;
    }
    
    // shooting
    if (p.fireTimer > 0) p.fireTimer -= dt;
    if (mouseDown && p.fireTimer <= 0 && canFire && !p.overheated){
      const shootVec = normInPlace(mouseX - p.x, mouseY - p.y, vecPool.temp1);
      const dx = shootVec.x, dy = shootVec.y;
      
      // Gather all active effects (new modular system)
      const activeEffects = [];
      for (const [effect, shots] of p.activeEffects) {
        if (shots > 0) activeEffects.push(effect);
      }
      
      // Calculate bullet pattern (multiplicative system)
      const {totalBullets, directions} = calculateBulletPattern(p);
      const hasUpgrade = p.upgradeShots > 0;
      
      // New unified shooting system - handle all patterns/upgrades
      if (hasUpgrade && totalBullets === 1) {
        // Special case: Front + Back shot with single bullet
        const {dx, dy} = directions[0]; // Use the single calculated direction
        spawnBullet(p.x + dx*p.radius*1.1, p.y + dy*p.radius*1.1, dx, dy, activeEffects); // Front
        spawnBullet(p.x - dx*p.radius*1.1, p.y - dy*p.radius*1.1, -dx, -dy, activeEffects); // Back
        // Check for ammo efficiency (chance to not consume ammo)
        const efficiencyChance = p.ammoEfficiency || 0;
        if (Math.random() >= efficiencyChance) {
          p.upgradeShots--;
        }
      } else if (hasUpgrade && totalBullets > 1) {
        // V-formation applied to each bullet direction (double the bullets)
        const vAngle = 0.15; // Smaller angle for multi-bullet spread
        const cs1 = Math.cos(vAngle), sn1 = Math.sin(vAngle);
        const cs2 = Math.cos(-vAngle), sn2 = Math.sin(-vAngle);
        
        for (const {dx, dy} of directions) {
          const sx1 = dx*cs1 - dy*sn1, sy1 = dx*sn1 + dy*cs1;
          const sx2 = dx*cs2 - dy*sn2, sy2 = dx*sn2 + dy*cs2;
          spawnBullet(p.x + sx1*p.radius*1.1, p.y + sy1*p.radius*1.1, sx1, sy1, activeEffects);
          spawnBullet(p.x + sx2*p.radius*1.1, p.y + sy2*p.radius*1.1, sx2, sy2, activeEffects);
        }
        // Check for ammo efficiency (chance to not consume ammo)
        const efficiencyChance = p.ammoEfficiency || 0;
        if (Math.random() >= efficiencyChance) {
          p.upgradeShots--;
        }
      } else {
        // Normal pattern shooting - spawn bullet for each direction
        for (const {dx, dy} of directions) {
          if (totalBullets === 1) {
            // Single bullet - add slight spread when sprinting + heat spread
            const baseSpread = (keys.has('ShiftLeft')||keys.has('ShiftRight')) ? 0.08 : 0.02;
            const spread = baseSpread + heatSpreadMod;
            const s = (Math.random()-0.5)*spread;
            const cs = Math.cos(s), sn = Math.sin(s);
            const sx = dx*cs - dy*sn, sy = dx*sn + dy*cs;
            spawnBullet(p.x + sx*p.radius*1.1, p.y + sy*p.radius*1.1, sx, sy, activeEffects);
          } else {
            // Multiple bullets - no spread, perfect circle
            spawnBullet(p.x + dx*p.radius*1.1, p.y + dy*p.radius*1.1, dx, dy, activeEffects);
          }
        }
      }
      
      // Decrement all active effects and pattern multipliers after shooting
      // Check for ammo efficiency (chance to not consume ammo)
      const efficiencyChance = p.ammoEfficiency || 0;
      if (Math.random() >= efficiencyChance) {
        for (const [effect, shots] of p.activeEffects) {
          if (shots > 0) p.activeEffects.set(effect, shots - 1);
        }
        for (const [pattern, shots] of p.patternMultipliers) {
          if (shots > 0) p.patternMultipliers.set(pattern, shots - 1);
        }
      }
      
      // Apply fire rate penalty from heat
      p.fireTimer = p.fireDelay * heatFireRateMod;
      
      // Generate heat per trigger pull, NOT per bullet (multi-shot doesn't increase heat)
      const actualBulletCount = hasUpgrade ? totalBullets * 2 : totalBullets;
      let heatGenerated = p.heatPerShot; // Fixed heat per shot regardless of bullet count
      
      // Extra heat generation when already hot (90%+)
      if (p.heat >= p.maxHeat * 0.9) {
        heatGenerated *= 1.5; // 50% more heat when near overheat
      }
      
      p.heat = Math.min(p.maxHeat, p.heat + heatGenerated * p.heatEfficiencyMod);
      shootSound();

      // Track shots fired for accuracy stat
      g.shotsFired += actualBulletCount;
    }

    // Enemy spawning now handled by setTimeout in wave completion logic
    // (All enemies spawn within 2-4 seconds at wave start)

    // Build spatial grid of enemies
    g.grid.reset();
    
    // Check for enemies near screen edges
    let nearTop = false, nearBottom = false, nearLeft = false, nearRight = false;
    const edgeThreshold = 100;
    
    // Cache expensive calculations
    const gameWidth = g.width();
    const gameHeight = g.height();
    const rightEdge = gameWidth - edgeThreshold;
    const bottomEdge = gameHeight - edgeThreshold;
    
    for (const e of enemies.items){
      if (!e.alive) continue;
      
      // Update spawn timer
      if (e.spawnTimer && e.spawnTimer > 0) {
        e.spawnTimer -= dt;
      }
      
      // Handle death animation
      if (e.dying) {
        e.deathTimer -= dt;
        // Death animation: white flash → red flash → fade
        const progress = 1 - (e.deathTimer / 0.2);
        if (progress < 0.3) {
          e.color = '#ffffff'; // White flash
        } else if (progress < 0.7) {
          e.color = '#ff0000'; // Red flash
        } else {
          e.color = e.originalColor || '#ff4444'; // Fade back to original (with fallback)
        }
        
        if (e.deathTimer <= 0) {
          e.alive = false; // Actually remove enemy
          continue;
        }
        // Don't do normal movement/behavior during death animation
        g.grid.insert(e);
        continue;
      }
      
      // Update critical hit flash timer
      if (e.critFlashTimer > 0) {
        e.critFlashTimer -= dt;
      }
      
      // Check edge proximity (using cached values)
      if (e.y < edgeThreshold) nearTop = true;
      if (e.y > bottomEdge) nearBottom = true;
      if (e.x < edgeThreshold) nearLeft = true;
      if (e.x > rightEdge) nearRight = true;
      
      // Handle freeze effect
      if (e.frozen > 0) e.frozen -= dt;
      const freezeMultiplier = e.frozen > 0 ? 0.5 : 1.0; // 50% speed when frozen
      
      // Apply behavior-specific movement (replaces old generic movement)
      const dirVec = normInPlace(p.x - e.x, p.y - e.y, vecPool.temp1);
      const dx = dirVec.x, dy = dirVec.y;
      
      // Add human-like walking cadence to all enemies
      if (!e.cadence) e.cadence = Math.random() * TAU; // Random starting phase
      e.cadence += dt * 4; // Walking rhythm frequency
      const walkRhythm = 0.8 + 0.2 * fastSin(e.cadence); // 0.6 to 1.0 speed multiplier
      
      if (e.behavior === 'stalker') {
        // Improved gait-like movement toward player
        const gaitPattern = 0.7 + 0.4 * fastSin(e.cadence) + 0.1 * fastSin(e.cadence * 2); // More realistic gait
        const stepSway = fastSin(e.cadence + Math.PI/4) * 8; // Slight left-right sway while walking
        const perpX = -dy; // Perpendicular to movement direction
        const perpY = dx;
        
        e.vx += dx * e.speed * dt * 2.6 * gaitPattern * freezeMultiplier; // Increased 30% from 2.0 to 2.6
        e.vy += dy * e.speed * dt * 2.6 * gaitPattern * freezeMultiplier;
        e.vx += perpX * stepSway * dt * freezeMultiplier; // Add subtle sway
        e.vy += perpY * stepSway * dt * freezeMultiplier;
      } else if (e.behavior === 'serpent') {
        // Strong zigzag movement - very noticeable serpentine pattern
        e.vx += dx * e.speed * dt * AI_CONSTANTS.SERPENT_SPEED_MULTIPLIER * walkRhythm * freezeMultiplier;
        e.vy += dy * e.speed * dt * AI_CONSTANTS.SERPENT_SPEED_MULTIPLIER * walkRhythm * freezeMultiplier;
        // Much stronger zigzag for clear serpentine movement
        e.vx += fastSin(g.t * 10 + e.x * 0.01) * AI_CONSTANTS.SERPENT_ZIGZAG_STRENGTH_X * dt * freezeMultiplier;
        e.vy += fastCos(g.t * 8 + e.y * 0.01) * AI_CONSTANTS.SERPENT_ZIGZAG_STRENGTH_Y * dt * freezeMultiplier;
      } else if (e.behavior === 'prowler') {
        // Flanking movement - circles around to attack from sides
        const playerAngle = Math.atan2(p.y - e.y, p.x - e.x);
        // Larger flanking angle for more obvious circling
        const flankAngle = playerAngle + fastSin(g.t * 3 + e.x * 0.005) * Math.PI/2;
        const fx = fastCos(flankAngle);
        const fy = fastSin(flankAngle);
        // Faster flanking movement
        e.vx += fx * e.speed * dt * AI_CONSTANTS.PROWLER_FLANK_SPEED * walkRhythm * freezeMultiplier;
        e.vy += fy * e.speed * dt * AI_CONSTANTS.PROWLER_FLANK_SPEED * walkRhythm * freezeMultiplier;
        // Less direct attraction for more flanking
        e.vx += dx * e.speed * dt * AI_CONSTANTS.PROWLER_DIRECT_ATTRACTION * freezeMultiplier;
        e.vy += dy * e.speed * dt * AI_CONSTANTS.PROWLER_DIRECT_ATTRACTION * freezeMultiplier;
      } else if (e.behavior === 'berserker') {
        // Enhanced dash zombie with telegraph system
        if (!e.dashState) e.dashState = 'prowling';
        if (!e.dashTimer) e.dashTimer = 2 + Math.random() * 3;
        
        e.dashTimer -= dt;
        
        if (e.dashState === 'prowling') {
          // Prowl around player between dashes
          e.vx += dx * e.speed * dt * AI_CONSTANTS.BERSERKER_PROWL_SPEED * walkRhythm * freezeMultiplier;
          e.vy += dy * e.speed * dt * AI_CONSTANTS.BERSERKER_PROWL_SPEED * walkRhythm * freezeMultiplier;

          if (e.dashTimer <= 0) {
            // Start telegraph phase
            e.dashState = 'telegraph';
            e.dashTimer = AI_CONSTANTS.BERSERKER_TELEGRAPH_DURATION;
            e.originalColor = e.color;
            e.dashDirection = { x: dx, y: dy }; // Lock dash direction
            beep(400, 0.1, 'triangle', 0.08); // Telegraph warning sound
          }
        } else if (e.dashState === 'telegraph') {
          // Flash bright white during telegraph and slow down
          e.color = Math.sin(g.t * 12) > 0 ? '#ffffff' : e.originalColor;

          // Move very slowly during telegraph
          e.vx += dx * e.speed * dt * AI_CONSTANTS.BERSERKER_TELEGRAPH_SPEED * freezeMultiplier;
          e.vy += dy * e.speed * dt * AI_CONSTANTS.BERSERKER_TELEGRAPH_SPEED * freezeMultiplier;

          if (e.dashTimer <= 0) {
            // Start dash
            e.dashState = 'dashing';
            e.dashTimer = AI_CONSTANTS.BERSERKER_DASH_DURATION;
            e.color = '#ffff00'; // Bright yellow while dashing
            beep(600, 0.05, 'sawtooth', 0.12); // Dash sound
          }
        } else if (e.dashState === 'dashing') {
          // Fast linear dash in locked direction
          const dashSpeed = e.speed * AI_CONSTANTS.BERSERKER_DASH_MULTIPLIER;
          e.vx += e.dashDirection.x * dashSpeed * dt * AI_CONSTANTS.BERSERKER_DASH_IMPULSE;
          e.vy += e.dashDirection.y * dashSpeed * dt * AI_CONSTANTS.BERSERKER_DASH_IMPULSE;

          if (e.dashTimer <= 0) {
            // Return to prowling
            e.dashState = 'prowling';
            e.dashTimer = AI_CONSTANTS.BERSERKER_COOLDOWN_MIN + Math.random() * (AI_CONSTANTS.BERSERKER_COOLDOWN_MAX - AI_CONSTANTS.BERSERKER_COOLDOWN_MIN);
            e.color = e.originalColor; // Restore original color
          }
        }
      } else if (e.behavior === 'maniac') {
        // Truly chaotic, unpredictable movement - much more erratic
        const panicRhythm = 0.5 + 0.5 * Math.sin(e.cadence * 3);
        // Much stronger random movement
        e.vx += (Math.random() - 0.5) * AI_CONSTANTS.MANIAC_CHAOS_FACTOR * dt * panicRhythm;
        e.vy += (Math.random() - 0.5) * AI_CONSTANTS.MANIAC_CHAOS_FACTOR * dt * panicRhythm;
        // Faster base movement toward player
        e.vx += dx * e.speed * AI_CONSTANTS.MANIAC_SPEED_MULTIPLIER * dt * freezeMultiplier;
        e.vy += dy * e.speed * AI_CONSTANTS.MANIAC_SPEED_MULTIPLIER * dt * freezeMultiplier;
      } else if (e.behavior === 'superboss') {
        // Super boss with changing movement phases every 20 seconds
        e.phaseTimer = (e.phaseTimer || 0) + dt;
        if (e.phaseTimer >= 20) {
          e.phaseTimer = 0;
          e.currentPhase = (e.currentPhase + 1) % 4; // Cycle through 4 phases
        }
        
        const phase = e.currentPhase || 0;
        const heavyStep = 0.8 + 0.4 * Math.sin(e.cadence * 0.3); // Powerful rhythm
        
        if (phase === 0) {
          // Phase 0: Relentless pursuit - direct aggressive chase
          e.vx += dx * e.speed * dt * 2.0 * heavyStep;
          e.vy += dy * e.speed * dt * 2.0 * heavyStep;
        } else if (phase === 1) {
          // Phase 1: Circling predator - orbits around player
          const orbitSpeed = 1.8;
          const perpDx = -dy; // Perpendicular to player direction  
          const perpDy = dx;
          e.vx += (dx * 0.8 + perpDx * orbitSpeed) * e.speed * dt * heavyStep;
          e.vy += (dy * 0.8 + perpDy * orbitSpeed) * e.speed * dt * heavyStep;
        } else if (phase === 2) {
          // Phase 2: Erratic berserker - unpredictable bursts
          const chaos = 0.7 + 0.6 * Math.sin(e.cadence * 4); // Chaotic rhythm
          e.vx += ((Math.random() - 0.5) * 400 + dx * 150) * dt * chaos;
          e.vy += ((Math.random() - 0.5) * 400 + dy * 150) * dt * chaos;
        } else {
          // Phase 3: Charging bull - periodic devastating rushes
          if (!e.rushPhase) e.rushPhase = { timer: 0, charging: false };
          e.rushPhase.timer += dt;
          
          if (!e.rushPhase.charging && e.rushPhase.timer >= 2) {
            e.rushPhase.charging = true;
            e.rushPhase.timer = 0;
            e.rushDirection = { x: dx, y: dy }; // Lock rush direction
          }
          
          if (e.rushPhase.charging) {
            if (e.rushPhase.timer < 1.5) {
              // Charging for 1.5 seconds
              const rushPower = 3.0 + Math.sin(e.rushPhase.timer * 8) * 0.5;
              e.vx += e.rushDirection.x * e.speed * dt * rushPower;
              e.vy += e.rushDirection.y * e.speed * dt * rushPower;
            } else {
              // Reset for next cycle
              e.rushPhase.charging = false;
              e.rushPhase.timer = 0;
            }
          } else {
            // Slow stalking between charges
            e.vx += dx * e.speed * dt * 0.3 * heavyStep;
            e.vy += dy * e.speed * dt * 0.3 * heavyStep;
          }
        }
      } else if (e.behavior === 'boss') {
        // Boss moves deliberately with heavy footsteps
        const heavyStep = 0.9 + 0.2 * Math.sin(e.cadence * 0.5); // Still rhythmic but faster
        e.vx += dx * e.speed * dt * 1.2 * heavyStep;
        e.vy += dy * e.speed * dt * 1.2 * heavyStep;
      } else if (e.behavior === 'leaper') {
        // Zergling rush behavior - quick leap attacks like player emergency dash
        if (!e.rushTimer) e.rushTimer = Math.random() * 1.5 + 0.5; // Initial delay
        e.rushTimer -= dt;
        
        if (e.rushTimer <= 0) {
          // Perform rush leap toward player
          const rushSpeed = e.speed * 4; // 4x speed burst (increased from 3x)
          e.vx += dx * rushSpeed * dt * 10; // Stronger impulse
          e.vy += dy * rushSpeed * dt * 10;
          e.rushTimer = 1.0 + Math.random() * 1.5; // 1.0-2.5 second cooldown (faster leaps)
        } else {
          // Fast movement between rushes (no longer slow!)
          e.vx += dx * e.speed * dt * 1.8 * walkRhythm; // 1.8x speed (was 0.8x)
          e.vy += dy * e.speed * dt * 1.8 * walkRhythm;
        }
      } else if (e.behavior === 'volatile') {
        // Suicide crawler - orbits player then charges periodically
        if (!e.chargeState) e.chargeState = 'orbiting';
        if (!e.chargeTimer) e.chargeTimer = 10 + Math.random() * 10; // 10-20 second orbit time
        if (!e.orbitAngle) e.orbitAngle = Math.random() * TAU; // Random starting orbit position
        // baseColor is now set during enemy creation
        
        e.chargeTimer -= dt;
        
        if (e.chargeState === 'orbiting') {
          // Orbit around player at medium distance
          const orbitRadius = 120;
          const orbitSpeed = 1.2; // Orbit speed
          e.orbitAngle += dt * orbitSpeed;
          
          const targetX = p.x + fastCos(e.orbitAngle) * orbitRadius;
          const targetY = p.y + fastSin(e.orbitAngle) * orbitRadius;
          
          const orbitDx = targetX - e.x;
          const orbitDy = targetY - e.y;
          const orbitVec = normInPlace(orbitDx, orbitDy, vecPool.temp3);
          
          // Move toward orbit position with some attraction to player
          e.vx += orbitVec.x * e.speed * dt * 1.5;
          e.vy += orbitVec.y * e.speed * dt * 1.5;
          e.vx += dx * e.speed * dt * 0.2; // Slight player attraction
          e.vy += dy * e.speed * dt * 0.2;
          
          e.color = e.baseColor || e.originalColor || '#8844ff'; // Use baseColor with fallbacks
          
          if (e.chargeTimer <= 0) {
            // Start telegraph phase
            e.chargeState = 'telegraph';
            e.chargeTimer = 1.0; // Telegraph for 1 second
          }
        } else if (e.chargeState === 'telegraph') {
          // Flash bright red during telegraph
          e.color = Math.sin(g.t * 15) > 0 ? '#ff0000' : (e.baseColor || e.originalColor || '#8844ff');
          
          // Slow down during telegraph
          e.vx += dx * e.speed * dt * 0.2;
          e.vy += dy * e.speed * dt * 0.2;
          
          if (e.chargeTimer <= 0) {
            // Start charging
            e.chargeState = 'charging';
            e.chargeTimer = 4.0; // Longer charge duration
            e.color = '#ff0000'; // Stay red while charging
            beep(350, 0.12, 'sawtooth', 0.10); // Charge sound
          }
        } else if (e.chargeState === 'charging') {
          // Seeking charge - gentler curve toward player like seeking bullets
          const seekVec = normInPlace(p.x - e.x, p.y - e.y, vecPool.temp2);
          const sx = seekVec.x, sy = seekVec.y;
          
          // Use seeking bullet approach - blend current direction with target direction
          const currentSpeed = fastLength(e.vx, e.vy) || e.speed * 2; // 2x base speed
          const currentVec = currentSpeed > 0 ? normInPlace(e.vx, e.vy, vecPool.temp3) : { x: sx, y: sy };
          const seekingStrength = 0.15; // Gentler than bullet seeking (0.2)
          
          // Gradually curve toward player
          const newDx = currentVec.x + sx * seekingStrength;
          const newDy = currentVec.y + sy * seekingStrength;
          const finalVec = normInPlace(newDx, newDy, vecPool.temp1);
          
          // Apply final velocity at 2x speed
          const targetSpeed = e.speed * 2; // Actual 2x speed
          e.vx = finalVec.x * targetSpeed;
          e.vy = finalVec.y * targetSpeed;
          
          // Check if hit screen boundaries
          const gameWidth = g.width();
          const gameHeight = g.height();
          const hitBoundary = (e.x <= e.r || e.x >= gameWidth - e.r || 
                              e.y <= e.r || e.y >= gameHeight - e.r);
          
          if (e.chargeTimer <= 0 || hitBoundary) {
            // Reset to orbiting instead of exploding
            e.chargeState = 'orbiting';
            e.chargeTimer = 8 + Math.random() * 8; // 8-16 second orbit before next charge
            e.color = e.baseColor || e.originalColor || '#8844ff'; // Back to base with fallbacks
            e.orbitAngle = Math.atan2(e.y - p.y, e.x - p.x); // Start orbit from current position
          }
        }
      } else if (e.behavior === 'juggernaut') {
        // Slow push - deliberate tanky movement toward player
        const pushStep = 0.9 + 0.2 * Math.sin(e.cadence * 0.4); // Heavy, slow rhythm
        e.vx += dx * e.speed * dt * 0.8 * pushStep * freezeMultiplier; // Slow but persistent
        e.vy += dy * e.speed * dt * 0.8 * pushStep * freezeMultiplier;
        
        // Update shield direction at 90% of rotation speed for counterplay
        if (e.hasShield && e.shieldDirection) {
          const shieldRotationSpeed = 0.9; // 90% speed
          const targetDir = { x: dx, y: dy };
          
          // Smoothly interpolate shield direction toward player direction
          e.shieldDirection.x = e.shieldDirection.x * (1 - shieldRotationSpeed * dt) + targetDir.x * shieldRotationSpeed * dt;
          e.shieldDirection.y = e.shieldDirection.y * (1 - shieldRotationSpeed * dt) + targetDir.y * shieldRotationSpeed * dt;
          
          // Normalize shield direction
          const len = fastLength(e.shieldDirection.x, e.shieldDirection.y);
          if (len > 0) {
            e.shieldDirection.x /= len;
            e.shieldDirection.y /= len;
          }
        }
      } else if (e.behavior === 'vortex') {
        // Spiral shooter - slow movement, rotates aim and shoots in patterns
        e.vx += dx * e.speed * dt * 0.6 * walkRhythm * freezeMultiplier; // Slow movement
        e.vy += dy * e.speed * dt * 0.6 * walkRhythm * freezeMultiplier;
        
        // Initialize spiral shooting properties
        if (!e.spiralAngle) e.spiralAngle = 0;
        if (!e.spiralShootTimer) e.spiralShootTimer = Math.random() * 2;
        
        // Rotate spiral angle continuously
        const rotationSpeed = 3.0; // radians per second
        e.spiralAngle += rotationSpeed * dt;
        
        // Shoot periodically in spiral pattern
        e.spiralShootTimer -= dt;
        if (e.spiralShootTimer <= 0) {
          spawnEnemyBullet(e.x, e.y, 
            e.x + fastCos(e.spiralAngle) * 100, 
            e.y + fastSin(e.spiralAngle) * 100);
          e.spiralShootTimer = 0.6; // Half frequency (was 0.3)
          beep(320, 0.04, 'triangle', 0.04); // High-pitched spiral sound
        }
      } else if (e.behavior === 'divider') {
        // Splitter zombie - normal movement with slight erratic behavior
        const splitStep = 0.8 + 0.3 * Math.sin(e.cadence * 1.5); // Slightly erratic rhythm
        e.vx += dx * e.speed * dt * 1.0 * splitStep * freezeMultiplier;
        e.vy += dy * e.speed * dt * 1.0 * splitStep * freezeMultiplier;
        // Add slight random movement for unpredictability
        e.vx += (Math.random() - 0.5) * 50 * dt;
        e.vy += (Math.random() - 0.5) * 50 * dt;
      } else if (e.behavior === 'trapper') {
        // Mine layer - slow movement, drops mines periodically
        e.vx += dx * e.speed * dt * 0.7 * walkRhythm * freezeMultiplier; // 30% slower
        e.vy += dy * e.speed * dt * 0.7 * walkRhythm * freezeMultiplier;
        
        // Initialize mine dropping properties
        if (!e.mineDropTimer) e.mineDropTimer = 1 + Math.random() * 2;
        if (!e.minesDropped) e.minesDropped = 0;
        const maxMines = 8; // Increased limit to 8 mines per enemy
        
        // Drop mines periodically every 6 seconds
        e.mineDropTimer -= dt;
        if (e.mineDropTimer <= 0 && e.minesDropped < maxMines) {
          // Spawn mine at current position
          mines.spawn(mine => {
            mine.x = e.x + (Math.random() - 0.5) * 20; // Slight position variance
            mine.y = e.y + (Math.random() - 0.5) * 20;
            mine.fuseTime = 0;
            mine.maxFuseTime = 30.0; // Long fuse - only triggered by proximity
            mine.isArmed = false; // Not armed immediately
            mine.triggerRadius = 35; // Original radius for triggering
            mine.explosionRadius = 70; // Doubled explosion radius
            mine.explosionDamage = 8 + game.wave * 1; // Scales with wave
            mine.flashTimer = 0;
            mine.isTriggered = false; // New triggered state
            mine.isGrenade = false; // Explicitly mark as NOT a grenade
            mine.r = 8; // Standard mine size
            mine.alive = true;
            mine.owner = e; // Track which enemy dropped it
          });
          
          e.minesDropped++;
          e.mineDropTimer = 12.0; // Fixed 12 second interval
          beep(180, 0.08, 'square', 0.06); // Mine drop sound
        }
      } else if (e.behavior === 'bomber') {
        // Grenadier - uses mixed movement patterns with grenade throwing
        const currentDist = fastLength(p.x - e.x, p.y - e.y);
        
        // Initialize pattern timer if not set
        if (!e.patternTimer) {
          e.patternTimer = 0;
          e.currentPattern = Math.floor(Math.random() * 3);
        }
        
        // Switch patterns every 2-3 seconds
        e.patternTimer += dt;
        if (e.patternTimer > 2 + Math.random()) {
          e.patternTimer = 0;
          e.currentPattern = (e.currentPattern + 1) % 3;
        }
        
        // Use persistent pattern choice
        if (e.currentPattern === 0) {
          // Normal chase pattern with walk rhythm
          const gaitPattern = 0.7 + 0.4 * fastSin(e.cadence) + 0.1 * fastSin(e.cadence * 2);
          e.vx += dx * e.speed * dt * 1.2 * gaitPattern * freezeMultiplier;
          e.vy += dy * e.speed * dt * 1.2 * gaitPattern * freezeMultiplier;
        } else if (e.currentPattern === 1) {
          // Zigzag approach
          e.vx += dx * e.speed * dt * 0.8 * walkRhythm * freezeMultiplier;
          e.vy += dy * e.speed * dt * 0.8 * walkRhythm * freezeMultiplier;
          e.vx += fastSin(g.t * 4 + e.x * 0.01) * 60 * dt * freezeMultiplier;
          e.vy += fastCos(g.t * 3 + e.y * 0.01) * 60 * dt * freezeMultiplier;
        } else {
          // Flanking movement
          const playerAngle = Math.atan2(p.y - e.y, p.x - e.x);
          const flankAngle = playerAngle + fastSin(g.t * 1.5 + e.x * 0.005) * Math.PI/3;
          const fx = fastCos(flankAngle);
          const fy = fastSin(flankAngle);
          e.vx += fx * e.speed * dt * 0.9 * walkRhythm * freezeMultiplier;
          e.vy += fy * e.speed * dt * 0.9 * walkRhythm * freezeMultiplier;
          // Some direct attraction
          e.vx += dx * e.speed * dt * 0.3 * freezeMultiplier;
          e.vy += dy * e.speed * dt * 0.3 * freezeMultiplier;
        }
        
        // Initialize grenade throwing properties
        if (!e.grenadeTimer) e.grenadeTimer = 2 + Math.random() * 2;
        if (!e.grenadesThrown) e.grenadesThrown = 0;
        const maxGrenades = 12; // Maximum grenades per enemy
        
        // Throw grenades periodically (range: 0-600 pixels ONLY)
        e.grenadeTimer -= dt;
        if (e.grenadeTimer <= 0 && e.grenadesThrown < maxGrenades) {
          // STRICT distance check - only throw if within range
          if (currentDist <= 600 && currentDist > 0) {
            // Target exact current player position
            const targetX = p.x;
            const targetY = p.y;
            
            // Calculate grenade physics for proper arc
            const throwSpeed = 300; // Fixed projectile speed of 300
            const gravity = 600; // Gravity constant
            
            // Spawn grenade (using mine system but with different behavior)
            mines.spawn(grenade => {
              // Start grenade at enemy position (no offset for accuracy)
              grenade.x = e.x;
              grenade.y = e.y;
              
              // Calculate direction to player
              const throwDx = targetX - e.x;
              const throwDy = targetY - e.y;
              const throwDist = Math.sqrt(throwDx * throwDx + throwDy * throwDy);
              
              // Set velocity at fixed speed toward player
              grenade.vx = (throwDx / throwDist) * throwSpeed;
              grenade.vy = (throwDy / throwDist) * throwSpeed;
              
              // Calculate travel time based on distance and speed
              const travelTime = throwDist / throwSpeed;
              
              // Calculate initial upward velocity for proper arc
              // Using physics: z = vz*t - 0.5*g*t² = 0 when t = travelTime
              // So: vz = 0.5*g*travelTime
              grenade.vz = (gravity * travelTime) / 2;
              grenade.z = 1; // Start slightly above ground
              grenade.gravity = gravity; // Store gravity for this grenade
              
              grenade.fuseTime = 0;
              grenade.maxFuseTime = travelTime + 0.8; // Explode 0.8s after landing
              grenade.isArmed = false;
              grenade.triggerRadius = 0; // No proximity trigger, only timer
              grenade.explosionRadius = 60; // Slightly smaller than mines
              grenade.explosionDamage = 10 + game.wave * 0.5; // Scales with wave
              grenade.flashTimer = 0;
              grenade.isTriggered = false;
              grenade.isGrenade = true; // Mark as grenade for special rendering
              grenade.targetX = targetX; // Where it should land
              grenade.targetY = targetY;
              grenade.alive = true;
              grenade.owner = e;
              grenade.r = 8; // Same size as mines for consistency
            });
          
            e.grenadesThrown++;
            beep(400, 0.1, 'sawtooth', 0.08); // Grenade throw sound
          }
          // Reset timer regardless of whether we threw (prevents rapid checks)
          e.grenadeTimer = 3.0 + Math.random() * 2; // 3-5 second interval
        }
      } else {
        // DEFAULT MOVEMENT - Basic pursuit for any unrecognized behavior
        e.vx += dx * e.speed * dt * 1.5 * walkRhythm * freezeMultiplier;
        e.vy += dy * e.speed * dt * 1.5 * walkRhythm * freezeMultiplier;
      }
      
      // Shooter enemy logic with different patterns
      if (e.isShooter) {
        e.shootTimer -= dt;
        if (e.shootTimer <= 0) {
          if (e.shootPattern === 'spread') {
            spawnEnemySpreadShot(e.x, e.y, p.x, p.y, 3, Math.PI/3); // 3 bullets, 60° spread
            e.shootTimer = 2.5; // Slightly slower for spread
            beep(280, 0.08, 'sine', 0.10); // Lower, longer sound for spread
          } else if (e.shootPattern === 'burst') {
            spawnEnemyBullet(e.x, e.y, p.x, p.y);
            e.burstCount++;
            
            if (e.burstCount >= 3) {
              e.shootTimer = 3.0; // Long cooldown after burst
              e.burstCount = 0;
              beep(320, 0.05, 'sine', 0.06); // Final burst sound
            } else {
              e.shootTimer = 0.15; // Quick successive shots
              beep(300, 0.04, 'sine', 0.06); // Rapid burst sound
            }
          } else {
            // Single shot (default)
            spawnEnemyBullet(e.x, e.y, p.x, p.y);
            e.shootTimer = 2.0; // Reset timer
            beep(300, 0.06, 'sine', 0.08); // Enemy shooting sound
          }
        }
      }
      
      // damp
      e.vx *= (1 - 3*dt);
      e.vy *= (1 - 3*dt);
      e.x += e.vx*dt;
      e.y += e.vy*dt;
      // clamp bounds
      e.x = clamp(e.x, e.r, g.width()-e.r);
      e.y = clamp(e.y, e.r, g.height()-e.r);
      
      // Spawn footsteps for enemies
      if (!e.footstepTimer) e.footstepTimer = 0;
      const enemySpeed = fastLength(e.vx, e.vy);
      if (enemySpeed > 20) { // Lower threshold for enemies
        e.footstepTimer -= dt;
        if (e.footstepTimer <= 0) {
          const moveAngle = Math.atan2(e.vy, e.vx);
          spawnFootstep(e.x, e.y, moveAngle, false, e);
          // Enemy footstep frequency based on speed
          e.footstepTimer = 0.3 - Math.min(0.1, enemySpeed * 0.0005);
        }
      }
      g.grid.insert(e);
    }
    
    // Update edge warnings
    // Update edge warnings using object
    edgeWarnings.top.style.display = nearTop ? 'block' : 'none';
    edgeWarnings.bottom.style.display = nearBottom ? 'block' : 'none';
    edgeWarnings.left.style.display = nearLeft ? 'block' : 'none';
    edgeWarnings.right.style.display = nearRight ? 'block' : 'none';

    // bullets - cache expensive property access and dimensions
    const bulletSpeedMult = game?.player?.bulletSpeed || 1.0;
    const gameWidthBounds = g.width() + 10;
    const gameHeightBounds = g.height() + 10;
    
    for (const b of bullets.items){
      if (!b.alive) continue;
      
      // Homing bullets
      const effects = b.effects || [];
      if (b.effectSet.has('homing')) {
        // Find new target if current target is dead/dying or we don't have one
        if (!b.homingTarget || !b.homingTarget.alive || b.homingTarget.dying || b.hitEnemies.has(b.homingTarget)) {
          let closest = null, closestDist = Infinity;
          for (const e of enemies.items) {
            if (!e.alive || e.dying || b.hitEnemies.has(e)) continue; // Skip dead/dying/already hit enemies
            const dist = fastLength(e.x - b.x, e.y - b.y);
            if (dist < closestDist) { closest = e; closestDist = dist; }
          }
          b.homingTarget = closest;
        }
      }
      
      if (b.effectSet.has('homing') && b.homingTarget && b.homingTarget.alive && !b.homingTarget.dying) {
        const homingVec = normInPlace(b.homingTarget.x - b.x, b.homingTarget.y - b.y, vecPool.temp2);
        const hx = homingVec.x, hy = homingVec.y;
        
        // Use consistent target speed instead of current speed (cache property access)
        const bulletSpeedMult = game?.player?.bulletSpeed || 1.0;
        const baseSpeed = 720 * bulletSpeedMult;
        const homingStrength = 0.3; // Even stronger homing
        
        b.vx = (b.vx * (1-homingStrength) + hx * baseSpeed * homingStrength);
        b.vy = (b.vy * (1-homingStrength) + hy * baseSpeed * homingStrength);
      }
      
      // Seeking bullets - curve toward nearest enemy without needing a specific target
      if (b.effectSet.has('seeking')) {
        let closest = null, closestDist = Infinity;
        for (const e of enemies.items) {
          if (!e.alive || e.dying) continue;
          const dist = fastLength(e.x - b.x, e.y - b.y);
          if (dist < closestDist && dist < 200) { // Seeking range
            closest = e; closestDist = dist;
          }
        }
        if (closest) {
          const seekVec = normInPlace(closest.x - b.x, closest.y - b.y, vecPool.temp3);
          const sx = seekVec.x, sy = seekVec.y;
          const baseSpeed = 720 * bulletSpeedMult; // Reuse cached value
          const seekingStrength = 0.2; // Lighter curve than homing
          
          // Gradually curve toward target
          const currentSpeed = fastLength(b.vx, b.vy);
          const currentVec = normInPlace(b.vx, b.vy, vecPool.temp4);
          const newDx = currentVec.x + sx * seekingStrength;
          const newDy = currentVec.y + sy * seekingStrength;
          const finalVec = normInPlace(newDx, newDy, vecPool.temp2);
          const finalDx = finalVec.x, finalDy = finalVec.y;
          
          b.vx = finalDx * currentSpeed;
          b.vy = finalDy * currentSpeed;
        }
      }
      
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life += dt;
      
      // Small trail effects for fast bullets
      const speed = fastLength(b.vx, b.vy);
      if (speed > 500 && shouldSpawnParticle() && Math.random() < 0.3) {
        particles.spawn(p => {
          p.x = b.x - b.vx * dt * 0.5; // Slightly behind bullet
          p.y = b.y - b.vy * dt * 0.5;
          p.vx = b.vx * 0.1; p.vy = b.vy * 0.1; // Slow trailing motion
          p.life = 0; p.maxLife = 0.15; // Short lifespan
          p.size = Math.min(2, b.r * 0.3); // Small size
          // Random trail color variations
          if (b.effects && b.effects.length > 0) {
            // Yellow variations for effect bullets
            const yellowVariation = Math.floor(Math.random() * 40) - 20;
            const green = Math.max(0x88, Math.min(0xff, 0xff + yellowVariation));
            p.color = '#ffff' + green.toString(16).padStart(2, '0');
          } else {
            // White/blue variations for normal bullets
            const blueShift = Math.floor(Math.random() * 60);
            const value = 0xff - blueShift;
            p.color = '#' + value.toString(16).padStart(2, '0') + value.toString(16).padStart(2, '0') + 'ff';
          }
        });
      }
      
      // Ricochet bullets (using cached dimensions)
      if (b.effectSet.has('ricochet') && b.bounces > 0) {
        if (b.x <= 0 || b.x >= gameWidth) { b.vx *= -1; b.bounces--; }
        if (b.y <= 0 || b.y >= gameHeight) { b.vy *= -1; b.bounces--; }
        b.x = clamp(b.x, 0, gameWidth);
        b.y = clamp(b.y, 0, gameHeight);
      } else if (b.life > b.maxLife || b.x< -10 || b.y< -10 || b.x>gameWidthBounds || b.y>gameHeightBounds){
        b.alive = false; continue;
      }
      // collide with enemies via spatial hash - piercing bullets track hit enemies
      const nearby = g.grid.near(b.x,b.y);
      for (const e of nearby){
        if (!e.alive || e.dying) continue;
        if (b.hitEnemies.has(e)) continue; // Skip enemies already hit by this bullet
        const rr = (b.r+e.r);
        if (fastDistanceCheck(b.x, b.y, e.x, e.y, rr)){
          // hit
          const damage = b.critical ? 2 : 1; // Critical hits deal double damage
          
          // Shield system - ONLY for slowpush enemies with shields
          let hitsShield = false;
          if (e.behavior === 'juggernaut' && e.hasShield && e.shieldHP > 0 && e.shieldDirection) {
            // Calculate bullet direction relative to enemy
            const bulletDir = normInPlace(b.x - e.x, b.y - e.y, vecPool.temp2);
            
            // Check if bullet is coming from shield side (dot product > 0 means same direction)
            const dotProduct = bulletDir.x * e.shieldDirection.x + bulletDir.y * e.shieldDirection.y;
            hitsShield = dotProduct > 0.3; // Shield covers ~120° arc in front
          }
          
          if (hitsShield) {
            // Bullet hits shield
            e.shieldHP -= damage;
            if (e.shieldHP <= 0) {
              e.hasShield = false; // Shield broken
              beep(200, 0.06, 'square', 0.08); // Shield break sound
            } else {
              beep(300, 0.03, 'triangle', 0.05); // Shield hit sound
            }
          } else {
            // Bullet hits enemy body directly (from behind/side or no shield)
            e.hp -= damage;
          }
          
          b.hitEnemies.add(e); // Mark this enemy as hit by this bullet

          // Track successful hit for accuracy stat
          g.shotsHit++;

          // Critical hit effects
          if (b.critical) {
            criticalHitSound();
            spawnBurst(e.x, e.y, 8, '#ffff00'); // Golden particles
            e.critFlashTimer = 0.1; // Brief flash effect
          }
          
          // Apply all special bullet effects
          const effects = b.effects || [];
          
          if (b.effectSet.has('explosive')) {
            // Explosive bullets damage nearby enemies
            for (const e2 of enemies.items) {
              if (!e2.alive || e2 === e) continue;
              const dist = fastLength(e2.x - b.x, e2.y - b.y);
              if (dist < 60) {
                e2.hp -= 1; // Increased from 40 to 60
                handleEnemyDeath(e2, g); // Handle death and crystal drops
              }
            }
            // Much more obvious explosion effect
            spawnBurst(b.x, b.y, 25, '#ff8000'); // More particles
            spawnBurst(b.x, b.y, 15, '#ff4000'); // Secondary burst
            spawnBurst(b.x, b.y, 10, '#ffff00'); // Yellow core
          }
          
          if (b.effectSet.has('lightning')) {
            // Lightning chains to nearby enemies (limit to prevent infinite chaining)
            let chainCount = 0;
            const maxChains = 3; // Limit chains per bullet

            // Use spatial grid for efficient nearby enemy lookup
            const nearbyEnemies = g.grid.near(b.x, b.y);
            for (const e2 of nearbyEnemies) {
              if (!e2.alive || e2 === e || e2.dying) continue; // Skip dying enemies
              if (chainCount >= maxChains) break; // Limit total chains

              const dist = fastLength(e2.x - b.x, e2.y - b.y);
              if (dist < 120) { // Chain range
                e2.hp -= 1; // Chain damage
                chainCount++;
                handleEnemyDeath(e2, g); // Handle death and crystal drops
                
                // More obvious lightning effect
                spawnBurst(e2.x, e2.y, 12, '#ffff00');
                spawnBurst(e2.x, e2.y, 8, '#ffffff'); 
                spawnBurst(e2.x, e2.y, 4, '#00ffff');
                
                // Create lightning bolt line effect
                const steps = 5;
                for (let i = 0; i < steps; i++) {
                  const t = i / (steps - 1);
                  const lx = b.x + (e2.x - b.x) * t;
                  const ly = b.y + (e2.y - b.y) * t;
                  spawnBurst(lx, ly, 2, '#ffffff');
                }
              }
            }
          }
          
          if (b.effectSet.has('freeze')) {
            // Freeze shot slows enemies
            if (!e.frozen) e.frozen = 0;
            e.frozen = Math.max(e.frozen, 2.0); // 2 seconds of slowness
            spawnBurst(e.x, e.y, 8, '#00ffff');
          }
          
          if (b.effectSet.has('cluster')) {
            // Cluster shot - bullets split into smaller bullets on impact
            const fragments = 3;
            for (let i = 0; i < fragments; i++) {
              const angle = (TAU * i) / fragments;
              const dx = Math.cos(angle);
              const dy = Math.sin(angle);
              spawnBullet(b.x, b.y, dx, dy, []);
            }
            spawnBurst(b.x, b.y, 12, '#ffa500');
          }
          
          if (b.effectSet.has('seeking')) {
            // Seeking bullets curve toward enemies (enhanced homing)
            // This is implemented in the bullet update loop above, similar to homing
            // but with different behavior - seeking bullets don't need a specific target
          }
          
          // Handle enemy death and effects
          handleEnemyDeath(e, g);
          
          // Blood spray from bullet impact
          spawnBlood(b.x, b.y, b.vx, b.vy, 'impact');
          hitSound();
          
          // Shotgun effect - spawn additional bullets in spread BEFORE bullet is destroyed
          if (b.effectSet.has('shotgun')) {
            const spreadCount = 4;
            const spreadAngle = 0.5;
            for (let i = 0; i < spreadCount; i++) {
              const angle = (i / (spreadCount - 1) - 0.5) * spreadAngle;
              const cos = Math.cos(angle), sin = Math.sin(angle);
              const newDx = b.vx * cos - b.vy * sin;
              const newDy = b.vx * sin + b.vy * cos;
              const speed = fastLength(newDx, newDy);
              spawnBullet(b.x, b.y, newDx/speed, newDy/speed, []);
            }
          }
          
          // Piercing check - reduce pierces and destroy bullet if none left
          if (b.pierces > 0) {
            b.pierces--;
            // Bullet continues moving and can hit more enemies
          } else {
            // No pierces left, bullet is destroyed
            b.alive = false;
            break;
          }
          
          // Don't break - piercing bullets can hit multiple enemies in one frame
          // but each enemy can only be hit once per bullet (tracked by hitEnemies set)
        }
      }
    }

    // enemy bullets
    for (const eb of enemyBullets.items) {
      if (!eb.alive) continue;
      
      eb.x += eb.vx * dt;
      eb.y += eb.vy * dt;
      eb.life += dt;
      
      // Remove bullets that go off screen or expire
      if (eb.life > eb.maxLife || eb.x < -20 || eb.y < -20 || eb.x > g.width() + 20 || eb.y > g.height() + 20) {
        eb.alive = false;
        continue;
      }
      
      // Collision with player only
      const dist = fastLength(eb.x - p.x, eb.y - p.y);
      if (dist < eb.r + p.radius) {
        eb.alive = false; // Destroy bullet
        
        if (g.invulTime <= 0) {
          // Player takes damage from enemy bullet
          const damage = 8 + ((g.wave / 5) | 0); // +1 damage every 5 waves (bit operation)
          const actualDamage = Math.ceil(damage * (1 - p.damageReduction));
          p.hp -= actualDamage;
          g.invulTime = 0.35;
          g.damageFlash = 0.3;
          hurtSound();
          
          // Knockback effect - push player away from bullet (no array allocation)
          const knockVec = normInPlace(eb.vx, eb.vy, vecPool.temp1);
          p.vx += knockVec.x * 300; // Strong knockback
          p.vy += knockVec.y * 300;
          
          // Player blood effect
          spawnBlood(p.x, p.y, 0, 0, 'player');
          
          if (p.hp <= 0) {
            triggerGameOver(g);
          }
        }
      }
    }

    // Bullet-to-bullet collision (player bullets can destroy enemy bullets)
    for (const pb of bullets.items) {
      if (!pb.alive) continue;

      for (const eb of enemyBullets.items) {
        if (!eb.alive) continue;

        // Check collision between bullets
        const dist = fastLength(pb.x - eb.x, pb.y - eb.y);
        if (dist < pb.r + eb.r + 2) { // Small buffer for better collision
          // Destroy both bullets
          pb.alive = false;
          eb.alive = false;

          // Visual effect at collision point
          const midX = (pb.x + eb.x) / 2;
          const midY = (pb.y + eb.y) / 2;
          spawnBurst(midX, midY, 8, '#ffff00'); // Yellow flash
          spawnBurst(midX, midY, 5, '#ffffff'); // White core

          // Sound effect
          beep(500, 0.04, 'square', 0.02); // Quick high pitch

          break; // This player bullet is destroyed, move to next
        }
      }
    }

    // enemy -> player collision
    const nearP = g.grid.near(p.x, p.y);
    for (const e of nearP){
      if (!e.alive || e.dying) continue;
      const rr = (p.radius + e.r);
      if (fastDistanceCheck(p.x, p.y, e.x, e.y, rr)){
        if (g.invulTime <= 0){
          const damage = Math.ceil(e.touchDmg * (1 - p.damageReduction));
          p.hp -= damage;
          g.invulTime = 0.35;
          g.damageFlash = 0.3; // Red vignette flash for 0.3 seconds
          hurtSound();
          
          // Suicide crawlers reset to orbiting after hitting player
          if (e.behavior === 'volatile') {
            e.chargeState = 'orbiting';
            e.chargeTimer = 6 + Math.random() * 6; // 6-12 second orbit after hit
            e.color = e.baseColor || e.originalColor || '#8844ff'; // Back to base with fallbacks
            e.orbitAngle = Math.atan2(e.y - p.y, e.x - p.x) + Math.PI; // Orbit away from player initially
          }
          
          // Slow push enemies apply knockback
          if (e.behavior === 'juggernaut' && e.knockbackStrength) {
            const knockbackVec = normInPlace(p.x - e.x, p.y - e.y, vecPool.temp1);
            const knockbackForce = e.knockbackStrength;
            
            // Apply impulse knockback to player
            p.vx += knockbackVec.x * knockbackForce * dt;
            p.vy += knockbackVec.y * knockbackForce * dt;
            
            // Visual/audio feedback for knockback
            beep(150, 0.08, 'square', 0.06); // Low thud sound
          }
          
          // Adrenaline boost trigger
          if (p.adrenalineBoost) {
            p.adrenalineTimer = 3.0; // 3 seconds of speed boost
          }
          // Player blood effect
          spawnBlood(p.x, p.y, 0, 0, 'player');
          if (p.hp <= 0){
            // game over
            triggerGameOver(g);
          }
        }
        // Knockback (reduced by resistance)
        const knockbackReduction = Math.min(1.0, p.knockbackResistance || 0);
        const knockbackForce = 200 * (1 - knockbackReduction);
        if (knockbackForce > 0) {
          const knockVec = normInPlace(p.x - e.x, p.y - e.y, vecPool.temp1);
          p.vx += knockVec.x * knockbackForce;
          p.vy += knockVec.y * knockbackForce;
        }
      }
    }

    // pickups
    for (const pickup of pickups.items){
      if (!pickup.alive) continue;
      
      // Physics - top-down view
      pickup.x += pickup.vx * dt;
      pickup.y += pickup.vy * dt;
      pickup.vy += 200 * dt; // Reduced gravity for top-down
      pickup.bounceTimer += dt;
      
      // Update rotation with gradual slowdown
      if (pickup.rotation !== undefined && pickup.rotationSpeed) {
        pickup.rotation += pickup.rotationSpeed * dt;
        // Apply friction to rotation speed to make it slow down
        pickup.rotationSpeed *= (1 - 2*dt);
        // Stop rotation when speed is very low
        if (Math.abs(pickup.rotationSpeed) < 0.1) {
          pickup.rotationSpeed = 0;
        }
      }
      
      // Keep crystals on screen - clamp to bounds
      pickup.x = clamp(pickup.x, 10, g.width() - 10);
      pickup.y = clamp(pickup.y, 10, g.height() - 10);
      
      // Ground collision
      if (pickup.y >= g.height() - 20) {
        pickup.y = g.height() - 20;
        pickup.vy = Math.min(pickup.vy, 0); // Stop downward movement
      }
      
      // Add friction to slow horizontal movement
      pickup.vx *= (1 - 3*dt);
      
      // Gentle settle instead of hard ground bounce
      if (pickup.vy > 0 && pickup.bounceTimer > 0.3) {
        pickup.vy *= (1 - 4*dt); // Slow down vertical movement
        if (Math.abs(pickup.vy) < 20) pickup.vy = 0; // Stop when slow enough
      }
      
      // Magnetic crystals effect + player collision (single distance calculation)
      const dist = fastLength(pickup.x - p.x, pickup.y - p.y);
      
      if (p.magneticRange > 0 && dist < p.magneticRange && dist > 20) {
        const magVec = normInPlace(p.x - pickup.x, p.y - pickup.y, vecPool.temp2);
        pickup.vx += magVec.x * 750 * dt;
        pickup.vy += magVec.y * 750 * dt;
      }
      
      // Player collision (reuse distance calculation)
      if (dist < 20) {
        // Handle special pickups first
        if (pickup.type === 'detonator') {
          // Remote Detonator - trigger all enemy mines
          pickup.alive = false;
          
          let minesDetonated = 0;
          
          // Trigger all enemy mines immediately
          for (const mine of mines.items) {
            if (mine.alive && !mine.isTriggered) {
              mine.isTriggered = true;
              mine.fuseTime = mine.maxFuseTime - 0.1; // Set to detonate in 0.1 seconds
              minesDetonated++;
              
              // Visual feedback on each mine
              particles.spawn(part => {
                part.x = mine.x;
                part.y = mine.y;
                part.vx = 0;
                part.vy = -50;
                part.life = 0;
                part.maxLife = 0.5;
                part.size = 15;
                part.color = '#ff0000';
                part.alive = true;
              });
            }
          }
          
          // Visual/audio feedback
          if (minesDetonated > 0) {
            beep(1500, 0.2, 'sawtooth', 0.4); // High pitched activation
            beep(800, 0.15, 'square', 0.3); // Secondary tone
            spawnBurst(p.x, p.y, 30, '#ff0000'); // Red burst effect
            spawnBurst(p.x, p.y, 20, '#ffaa00'); // Orange burst
          } else {
            beep(400, 0.1, 'triangle', 0.2); // Low tone if no mines
          }
          
          // Show notification
          const notification = document.getElementById('powerupNotification');
          if (notification) {
            notification.textContent = minesDetonated > 0 
              ? `DETONATOR: ${minesDetonated} MINE${minesDetonated > 1 ? 'S' : ''} TRIGGERED!`
              : 'DETONATOR: NO MINES FOUND';
            notification.style.display = 'block';
            notification.style.animation = 'none';
            void notification.offsetHeight; // Force reflow
            notification.style.animation = 'powerupPulse 3s ease-out forwards';
          }
        } else {
          // Regular crystal collection
          const powerup = bulletPowerupMap.get(pickup.type);
          const particleColor = powerup ? powerup.color : '#ffffff';
          for (let i = 0; i < 8; i++) {
            particles.spawn(part => {
              part.x = pickup.x;
              part.y = pickup.y;
              const angle = (i / 8) * TAU;
              const speed = 100 + Math.random() * 100;
              part.vx = Math.cos(angle) * speed;
              part.vy = Math.sin(angle) * speed;
              part.life = 0;
              part.maxLife = 0.5;
              part.size = 2 + Math.random() * 2;
              part.color = particleColor;
            });
          }
          
          pickup.alive = false;
          
          // All crystals now use unified bullet powerup system
          if (powerup) {
          if (powerup.type === 'upgrade') {
            // Dual shot upgrade
            p.upgradeShots += powerup.shots;
            beep(800, 0.1, 'triangle', 0.03);
          } else if (powerup.type === 'triple' || powerup.type === 'quad') {
            // Pattern powerup - actually add shots to existing
            const currentShots = p.patternMultipliers.get(powerup.type) || 0;
            p.patternMultipliers.set(powerup.type, currentShots + powerup.shots);
            // Legacy support
            p.bulletPattern = powerup.type;
            p.patternTimer = currentShots + powerup.shots;
            beep(600, 0.15, 'sawtooth', 0.04);
          } else {
            // Effect powerup - actually add shots to existing (not replace)
            const currentShots = p.activeEffects.get(powerup.type) || 0;
            p.activeEffects.set(powerup.type, currentShots + powerup.shots);
            // Legacy support
            p.bulletType = powerup.type;
            p.bulletTimer = currentShots + powerup.shots;
            beep(600, 0.15, 'sawtooth', 0.04);
          }
          showPowerupNotification(powerup.name);
          }
        }
      }
    }

    // mines and grenades - timed explosives
    for (const mine of mines.items) {
      if (!mine.alive) continue;
      
      // Handle grenade projectile movement
      if (mine.isGrenade) {
        // Move grenade horizontally
        mine.x += mine.vx * dt;
        mine.y += mine.vy * dt;
        
        // Handle vertical movement (arc)
        if (mine.z !== undefined && mine.z !== null) {
          mine.z += mine.vz * dt;
          mine.vz -= (mine.gravity || 600) * dt; // Use grenade's gravity or default
          
          // Check if grenade hit the ground
          if (mine.z <= 0 && mine.vz < 0) {
            mine.z = 0;
            // Grenade landed - trigger it if not already triggered
            if (!mine.isTriggered) {
              mine.isTriggered = true;
              mine.fuseTime = mine.maxFuseTime - 0.8; // Start countdown
              beep(600, 0.08, 'square', 0.1); // Grenade land sound
              
              // Stop horizontal movement
              mine.vx = 0;
              mine.vy = 0;
              mine.vz = 0;
            }
          }
        } else {
          // Fallback for grenades without z coordinate
          const distToTarget = fastLength(mine.x - mine.targetX, mine.y - mine.targetY);
          if (distToTarget < 30 && !mine.isTriggered) {
            mine.isTriggered = true;
            mine.fuseTime = mine.maxFuseTime - 0.8;
            beep(600, 0.08, 'square', 0.1);
            mine.vx = 0;
            mine.vy = 0;
          }
        }
        
        // No air resistance for grenades - they need to maintain velocity to hit target
        // Air resistance would make them fall short
      }
      
      // Fuse timer
      mine.fuseTime += dt;
      mine.flashTimer += dt;
      
      // Arm mine after 0.5 seconds (can't be triggered immediately) - not for grenades
      if (!mine.isGrenade && !mine.isArmed && mine.fuseTime >= 0.5) {
        mine.isArmed = true;
      }
      
      // Check player proximity for armed mines (not grenades)
      if (!mine.isGrenade && mine.isArmed && !mine.isTriggered) {
        const distToPlayer = fastLength(mine.x - p.x, mine.y - p.y);
        
        // Trigger mine if player steps into trigger radius
        if (distToPlayer <= mine.triggerRadius) {
          mine.isTriggered = true;
          mine.fuseTime = 0; // Reset fuse for explosion countdown
          mine.maxFuseTime = 1.5; // 1.5 second explosion delay
          beep(400, 0.1, 'triangle', 0.1); // Trigger warning sound
        }
      }
      
      // Handle triggered mines
      if (mine.isTriggered && mine.fuseTime >= mine.maxFuseTime) {
        // Explode mine
        const explosionDist = fastLength(mine.x - p.x, mine.y - p.y);
        if (explosionDist <= mine.explosionRadius) {
          // Damage player
          p.hp -= mine.explosionDamage;
          beep(100, 0.15, 'sawtooth', 0.2); // Deep explosion
          spawnBlood(p.x, p.y, 0, 0, 'player');
          hurtSound();
        }
        
        // Also damage nearby enemies (friendly fire!)
        for (const enemy of enemies.items) {
          if (!enemy.alive || enemy.dying) continue;
          const enemyDist = fastLength(mine.x - enemy.x, mine.y - enemy.y);
          if (enemyDist <= mine.explosionRadius) {
            // Don't damage the mine owner (optional - remove this check for full friendly fire)
            if (enemy !== mine.owner) {
              const damage = Math.ceil(mine.explosionDamage * 0.5); // Half damage to enemies
              enemy.hp -= damage;
              
              // Knockback
              const knockbackForce = 300;
              const dx = enemy.x - mine.x;
              const dy = enemy.y - mine.y;
              const dist = Math.max(1, enemyDist);
              enemy.vx += (dx / dist) * knockbackForce;
              enemy.vy += (dy / dist) * knockbackForce;
              
              // Blood effect
              spawnBlood(enemy.x, enemy.y, 0, 0, 'impact');
              
              // Handle enemy death if killed
              handleEnemyDeath(enemy, g);
            }
          }
        }
        
        // Explosion particles (bigger explosion)
        for (let i = 0; i < 30; i++) {
          particles.spawn(part => {
            const angle = (i / 30) * TAU + Math.random() * 0.3;
            const speed = randRange(150, 350); // Bigger explosion
            part.x = mine.x; part.y = mine.y;
            part.vx = fastCos(angle) * speed;
            part.vy = fastSin(angle) * speed;
            part.life = 0; part.maxLife = randRange(0.6, 1.0); // Longer lasting
            part.size = randRange(3, 7); // Bigger particles
            part.color = '#ff6600'; // Orange explosion
            part.hasGravity = false;
            part.alive = true;
          });
        }
        
        // Reduce mine/grenade count for owner
        if (mine.owner) {
          if (mine.isGrenade) {
            mine.owner.grenadesThrown--;
          } else {
            mine.owner.minesDropped--;
          }
        }
        mine.alive = false;
      }
    }

    // blood stains - realistic droplet physics
    for (const stain of bloodStains.items){
      if (!stain.alive) continue;
      
      if (!stain.settled) {
        // Blood droplets still in motion
        stain.x += stain.vx * dt;
        stain.y += stain.vy * dt;
        stain.vx *= (1 - 8*dt); // Strong friction
        stain.vy *= (1 - 8*dt);
        
        // Settle when slow enough
        if (fastLength(stain.vx, stain.vy) < 10) {
          stain.settled = true;
          stain.vx = 0;
          stain.vy = 0;
        }
      }
      
      stain.life += dt;
      // Fade similar to footsteps but slower (6 seconds total)
      const fadeProgress = stain.life / stain.maxLife;
      if (fadeProgress < 0.6) {
        // First 60% of lifetime (0-3.6 seconds): Stay mostly visible
        stain.alpha = 0.8 * (1.0 - fadeProgress * 0.2);
      } else {
        // Last 40% of lifetime (3.6-6 seconds): Quick fade
        stain.alpha = 0.8 * 0.8 * (1.0 - (fadeProgress - 0.6) / 0.4);
      }
      if (stain.life >= stain.maxLife) stain.alive = false;
    }
    
    // Update footsteps
    for (const footstep of footsteps.items) {
      if (!footstep.alive) continue;
      
      footstep.life += dt;
      // Fade out with easing - stays visible longer, then fades quickly
      const fadeProgress = footstep.life / footstep.maxLife;
      if (fadeProgress < 0.6) {
        // Stay mostly visible for first 60%
        footstep.alpha = 0.35 * (1.0 - fadeProgress * 0.3);
      } else {
        // Quick fade in last 40%
        footstep.alpha = 0.35 * 0.7 * (1.0 - (fadeProgress - 0.6) / 0.4);
      }
      if (footstep.life >= footstep.maxLife) {
        footstep.alive = false;
      }
    }

    // particles
    activeParticleCount = 0; // Reset counter each frame
    for (const p2 of particles.items){
      if (!p2.alive) continue;
      activeParticleCount++; // Count active particles
      p2.x += p2.vx*dt;
      p2.y += p2.vy*dt;
      // Add gravity to blood particles
      if (p2.hasGravity) {
        p2.vy += 150 * dt; // Gravity effect
      }
      p2.life += dt;
      if (p2.life >= p2.maxLife) p2.alive = false;
    }

    // HUD - batch updates to prevent layout thrashing
    // Cache previous values to avoid unnecessary updates
    const newHp = Math.max(0, Math.floor(p.hp));
    const newStamina = Math.floor(p.stamina);
    const newHeat = Math.floor(p.heat);
    const hpPercent = clamp(p.hp/p.maxHp,0,1)*100;
    const staminaPercent = clamp(p.stamina/100,0,1)*100;
    const heatPercent = clamp(p.heat/p.maxHeat,0,1)*100;
    
    queueDOMUpdate(() => {
      // Only update if values changed
      if (hpTxt._lastValue !== newHp) {
        hpTxt._lastValue = newHp;
        hpTxt.textContent = newHp.toString();
      }
      if (hudHpBar._lastPercent !== hpPercent) {
        // Check if HP is increasing for healing effect
        if (hudHpBar._lastPercent !== undefined && hpPercent > hudHpBar._lastPercent) {
          hudHpBar.parentElement.classList.add('healing');
          clearTimeout(hudHpBar._healingTimeout);
          hudHpBar._healingTimeout = setTimeout(() => {
            hudHpBar.parentElement.classList.remove('healing');
          }, 1500);
        }
        // Check if HP is decreasing for damage effect
        else if (hudHpBar._lastPercent !== undefined && hpPercent < hudHpBar._lastPercent) {
          hudHpBar.parentElement.classList.add('taking-damage');
          clearTimeout(hudHpBar._damageTimeout);
          hudHpBar._damageTimeout = setTimeout(() => {
            hudHpBar.parentElement.classList.remove('taking-damage');
          }, 300);
        }
        hudHpBar._lastPercent = hpPercent;
        hudHpBar.style.width = `${hpPercent}%`;
        // Add/remove low class for pulsing effect
        if (hpPercent <= 30) {
          hudHpBar.parentElement.classList.add('low');
        } else {
          hudHpBar.parentElement.classList.remove('low');
        }
      }
      if (staminaTxt._lastValue !== newStamina) {
        staminaTxt._lastValue = newStamina;
        staminaTxt.textContent = newStamina.toString();
      }
      // Always update the bar width directly without transitions
      hudStaminaBar.style.width = `${staminaPercent}%`;
      
      // Handle stamina state classes with proper thresholds
      if (hudStaminaBar._lastPercent !== undefined) {
        const diff = staminaPercent - hudStaminaBar._lastPercent;
        
        // Only trigger effects for significant changes (>1% difference)
        if (Math.abs(diff) > 1) {
          // Clear any existing timeouts
          clearTimeout(hudStaminaBar._healingTimeout);
          clearTimeout(hudStaminaBar._usageTimeout);
          
          if (diff > 0 && !p.isSprinting) {
            // Stamina is regenerating
            hudStaminaBar.parentElement.classList.remove('using-stamina');
            hudStaminaBar.parentElement.classList.add('healing');
            hudStaminaBar._healingTimeout = setTimeout(() => {
              hudStaminaBar.parentElement.classList.remove('healing');
            }, 1500);
          } else if (diff < 0 && p.isSprinting) {
            // Stamina is being used
            hudStaminaBar.parentElement.classList.remove('healing');
            hudStaminaBar.parentElement.classList.add('using-stamina');
            hudStaminaBar._usageTimeout = setTimeout(() => {
              hudStaminaBar.parentElement.classList.remove('using-stamina');
            }, 200);
          }
        }
      }
      
      // Handle low stamina warning
      if (staminaPercent <= 30) {
        hudStaminaBar.parentElement.classList.add('low');
      } else {
        hudStaminaBar.parentElement.classList.remove('low');
      }
      
      hudStaminaBar._lastPercent = staminaPercent;
      
      // Heat bar updates
      if (heatTxt._lastValue !== newHeat) {
        heatTxt._lastValue = newHeat;
        heatTxt.textContent = newHeat.toString();
      }
      if (hudHeatBar._lastPercent !== heatPercent) {
        hudHeatBar._lastPercent = heatPercent;
        hudHeatBar.style.width = `${heatPercent}%`;
        
        // Remove all heat classes first
        hudHeatBar.parentElement.classList.remove('warning', 'danger', 'overheated');
        
        // Add appropriate heat state class
        if (p.overheated) {
          hudHeatBar.parentElement.classList.add('overheated');
        } else if (heatPercent >= 90) {
          hudHeatBar.parentElement.classList.add('danger');
        } else if (heatPercent >= 75) {
          hudHeatBar.parentElement.classList.add('warning');
        }
      }
      
      if (waveTxt._lastValue !== g.wave) {
        waveTxt._lastValue = g.wave;
        waveTxt.textContent = g.wave.toString();
      }
      if (killsTxt._lastValue !== g.kills) {
        killsTxt._lastValue = g.kills;
        killsTxt.textContent = g.kills.toString();
      }
      
      // Update mobile button states
      if (isMobile && leapBtn) {
        if (p.leapReady) {
          leapBtn.classList.add('ready');
          leapBtn.classList.remove('cooldown');
        } else {
          leapBtn.classList.remove('ready');
          leapBtn.classList.add('cooldown');
          // Update cooldown timer visual
          const cooldownPercent = (p.leapCd / 3.0) * 100;
          if (leapBtn._lastCooldown !== cooldownPercent) {
            leapBtn._lastCooldown = cooldownPercent;
            leapBtn.style.setProperty('--cooldown-percent', `${cooldownPercent}%`);
          }
        }
      }
    });
    
    // Clean up expired effects and patterns (no display needed)
    for (const [effect, shots] of p.activeEffects) {
      if (shots <= 0) p.activeEffects.delete(effect);
    }
    for (const [pattern, shots] of p.patternMultipliers) {
      if (shots <= 0) p.patternMultipliers.delete(pattern);
    }
  }

  function draw(g, alpha){
    // Reset render state for new frame
    resetRenderState();
    
    // CRITICAL: Reset canvas transform to prevent accumulation bugs
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    
    // Evict oldest gradient cache entries if it gets too large (simple LRU)
    if (gradientCache.size > MAX_GRADIENT_CACHE_SIZE) {
      // Remove the first 20 entries (oldest in Map insertion order)
      let removed = 0;
      for (const key of gradientCache.keys()) {
        gradientCache.delete(key);
        if (++removed >= 20) break; // Remove 20 oldest entries
      }
    }
    
    // clear
    setFillStyle('#0d1015');
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Draw cached background grid (only when needed)
    if (bgNeedsRedraw) {
      if (!bgCanvas) {
        bgCanvas = document.createElement('canvas');
        bgCtx = bgCanvas.getContext('2d');
      }
      bgCanvas.width = canvas.width;
      bgCanvas.height = canvas.height;
      
      // Draw hexagonal tile floor to offscreen canvas
      bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
      
      // Hexagon parameters
      const hexRadius = 28;
      const hexWidth = hexRadius * 2;
      const hexHeight = Math.sqrt(3) * hexRadius;
      const horizontalSpacing = hexWidth * 0.75;
      const verticalSpacing = hexHeight;
      
      // Helper function to draw a hexagon
      function drawHex(cx, cy, radius, isDamaged) {
        bgCtx.save();
        
        // Create gradient for depth effect
        const gradient = bgCtx.createRadialGradient(cx, cy, 0, cx, cy, radius);
        if (isDamaged) {
          // Darker damaged tiles
          gradient.addColorStop(0, '#0c0e12');
          gradient.addColorStop(1, '#090b0e');
        } else {
          // Normal tiles with subtle gradient
          gradient.addColorStop(0, '#111519');
          gradient.addColorStop(0.7, '#0f1318');
          gradient.addColorStop(1, '#0d1015');
        }
        
        // Fill hexagon
        bgCtx.fillStyle = gradient;
        bgCtx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (Math.PI / 3) * i - Math.PI / 6;
          const x = cx + radius * Math.cos(angle);
          const y = cy + radius * Math.sin(angle);
          if (i === 0) bgCtx.moveTo(x, y);
          else bgCtx.lineTo(x, y);
        }
        bgCtx.closePath();
        bgCtx.fill();
        
        // Subtle border
        bgCtx.strokeStyle = '#151a20';
        bgCtx.lineWidth = 0.5;
        bgCtx.globalAlpha = 0.3;
        bgCtx.stroke();
        
        bgCtx.restore();
      }
      
      // Draw hexagonal grid
      const cols = Math.ceil(canvas.width / horizontalSpacing) + 2;
      const rows = Math.ceil(canvas.height / verticalSpacing) + 2;
      
      for (let row = -1; row < rows; row++) {
        for (let col = -1; col < cols; col++) {
          const x = col * horizontalSpacing;
          const y = row * verticalSpacing + (col % 2) * (hexHeight / 2);
          
          // 5% chance for damaged/darker tile
          const isDamaged = Math.random() < 0.05;
          drawHex(x, y, hexRadius, isDamaged);
        }
      }
      
      bgNeedsRedraw = false;
    }
    // Blit pre-drawn background
    ctx.drawImage(bgCanvas, 0, 0);

    // blood stains - individual rendering for proper alpha fading
    ctx.save();
    
    // Draw settled stains with individual alpha
    for (const stain of bloodStains.items){
      if (!stain.alive || !stain.settled) continue;
      ctx.fillStyle = '#600000';
      ctx.globalAlpha = stain.alpha * 0.8; // Apply individual fade
      ctx.beginPath();
      ctx.arc(stain.x, stain.y, stain.size * 1.5, 0, TAU);
      ctx.fill();
    }
    
    // Draw moving droplets with individual alpha
    for (const stain of bloodStains.items){
      if (!stain.alive || stain.settled) continue;
      ctx.fillStyle = '#cc0000';
      ctx.globalAlpha = stain.alpha * 0.9; // Apply individual fade
      ctx.beginPath();
      ctx.arc(stain.x, stain.y, stain.size, 0, TAU);
      ctx.fill();
    }
    
    // Draw footsteps with sophisticated appearance
    for (const footstep of footsteps.items) {
      if (!footstep.alive || footstep.alpha <= 0) continue;
      
      ctx.save();
      ctx.translate(footstep.x, footstep.y);
      ctx.rotate(footstep.angle);
      
      // Subtle outer glow/shadow for depth
      ctx.fillStyle = '#0a0a0a'; // Very dark shadow
      ctx.globalAlpha = footstep.alpha * 0.3;
      
      // Shadow slightly larger and offset
      ctx.save();
      ctx.scale(1.15, 1.15);
      ctx.translate(1, 1);
      
      // Shadow foot pad
      ctx.beginPath();
      ctx.ellipse(-footstep.size * 0.2, 0, footstep.size * 0.35, footstep.size * 0.7, 0, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(footstep.size * 0.3, 0, footstep.size * 0.25, footstep.size * 0.35, 0, 0, TAU);
      ctx.fill();
      ctx.restore();
      
      // Main footprint with gradient
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, footstep.size);
      gradient.addColorStop(0, '#4a3a28'); // Lighter tan center
      gradient.addColorStop(0.7, '#3d2f1f'); // Dark tan
      gradient.addColorStop(1, '#2a2015'); // Darker edge
      
      ctx.fillStyle = gradient;
      ctx.globalAlpha = footstep.alpha;
      
      // Draw a realistic footprint shape
      // Main foot pad (heel to ball)
      ctx.beginPath();
      ctx.ellipse(-footstep.size * 0.2, 0, footstep.size * 0.35, footstep.size * 0.7, 0, 0, TAU);
      ctx.fill();
      
      // Toe area (smaller circle at front)
      ctx.beginPath();
      ctx.ellipse(footstep.size * 0.3, 0, footstep.size * 0.25, footstep.size * 0.35, 0, 0, TAU);
      ctx.fill();
      
      // Small toe marks with slightly different color
      if (footstep.isPlayer) {
        ctx.fillStyle = '#3a2c1c'; // Slightly different shade for toes
        ctx.globalAlpha = footstep.alpha * 0.9;
        // Player gets slightly more detailed footprints
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          const toeX = footstep.size * 0.5 + i * footstep.size * 0.08;
          const toeY = (i - 1) * footstep.size * 0.12;
          ctx.arc(toeX, toeY, footstep.size * 0.06, 0, TAU);
          ctx.fill();
        }
      }
      
      ctx.restore();
    }
    
    ctx.restore(); // Restore the save from line 6374 (blood stains and footsteps section)

    // draw player with leap glow
    const p = g.player;
    ctx.save();
    
    // Leap ready glow effect
    if (p.leapReady) {
      const glowIntensity = 0.7 + 0.3 * fastSin(g.t * 6); // Pulsing glow
      const glowRadius = p.radius + 8;
      
      // Outer glow (cached)
      const glowKey = `leap_${((glowRadius*100)|0)}_${((glowIntensity*100)|0)}`;
      let outerGradient = gradientCache.get(glowKey);
      if (!outerGradient) {
        outerGradient = ctx.createRadialGradient(p.x, p.y, p.radius, p.x, p.y, glowRadius);
        outerGradient.addColorStop(0, `rgba(0, 255, 255, ${glowIntensity * 0.3})`);
        outerGradient.addColorStop(0.7, `rgba(0, 255, 255, ${glowIntensity * 0.2})`);
        outerGradient.addColorStop(1, `rgba(0, 255, 255, 0)`);
        gradientCache.set(glowKey, outerGradient);
      }
      ctx.fillStyle = outerGradient;
      ctx.beginPath();
      ctx.arc(p.x, p.y, glowRadius, 0, TAU);
      ctx.fill();
      
      // Inner rim glow
      ctx.strokeStyle = `rgba(0, 255, 255, ${glowIntensity * 0.8})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius + 2, 0, TAU);
      ctx.stroke();
    }
    
    // Overheat visual effects
    if (p.overheated) {
      // Pulsing red warning glow
      const overheatPulse = 0.5 + 0.5 * fastSin(g.t * 12);
      const overheatRadius = p.radius + 12;
      
      // Red overheat aura
      const overheatKey = `overheat_${((overheatPulse*100)|0)}`;
      let overheatGradient = gradientCache.get(overheatKey);
      if (!overheatGradient) {
        overheatGradient = ctx.createRadialGradient(p.x, p.y, p.radius, p.x, p.y, overheatRadius);
        overheatGradient.addColorStop(0, `rgba(255, 0, 0, ${overheatPulse * 0.6})`);
        overheatGradient.addColorStop(0.5, `rgba(255, 100, 0, ${overheatPulse * 0.4})`);
        overheatGradient.addColorStop(1, `rgba(255, 0, 0, 0)`);
        gradientCache.set(overheatKey, overheatGradient);
      }
      ctx.fillStyle = overheatGradient;
      ctx.beginPath();
      ctx.arc(p.x, p.y, overheatRadius, 0, TAU);
      ctx.fill();
    } else if (p.heat >= 75) {
      // Warning glow for high heat
      const heatIntensity = (p.heat - 75) / 25; // 0 to 1 as heat goes 75-100
      const heatPulse = 0.7 + 0.3 * fastSin(g.t * 8);
      const heatRadius = p.radius + 6;
      
      ctx.fillStyle = `rgba(255, ${150 - heatIntensity * 100}, 0, ${heatPulse * heatIntensity * 0.4})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, heatRadius, 0, TAU);
      ctx.fill();
    }
    
    // Player invulnerability flash
    if (g.invulTime > 0){
      ctx.globalAlpha = 0.6 + 0.4*fastSin(g.t*40);
    }
    
    // Main player body - color changes based on heat
    if (p.overheated) {
      ctx.fillStyle = '#ff4444'; // Red when overheated
    } else if (p.heat >= 90) {
      ctx.fillStyle = '#ff8800'; // Orange when very hot
    } else if (p.heat >= 75) {
      ctx.fillStyle = '#ffaa00'; // Yellow-orange when hot
    } else if (p.heat >= 50) {
      ctx.fillStyle = '#88ff00'; // Yellow-green when warm
    } else {
      ctx.fillStyle = '#00ff00'; // Normal green
    }
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, TAU);
    ctx.fill();
    ctx.restore();

    // crosshair
    ctx.save();
    ctx.globalAlpha = 0.5;
    ctx.strokeStyle = '#34d1ff';
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 10, 0, TAU);
    ctx.moveTo(mouseX-14, mouseY); ctx.lineTo(mouseX-4, mouseY);
    ctx.moveTo(mouseX+14, mouseY); ctx.lineTo(mouseX+4, mouseY);
    ctx.moveTo(mouseX, mouseY-14); ctx.lineTo(mouseX, mouseY-4);
    ctx.moveTo(mouseX, mouseY+14); ctx.lineTo(mouseX, mouseY+4);
    ctx.stroke();
    ctx.restore();

    // enemies
    for (const e of enemies.items){
      if (!e.alive) continue;
      
      // Super boss phase-based visual effects
      if (e.behavior === 'superboss') {
        ctx.save();
        
        // Phase-based color modulation
        const phase = e.currentPhase || 0;
        const phaseColors = ['#800080', '#ff0080', '#ff8000', '#8000ff'];
        const pulseIntensity = 0.7 + 0.3 * fastSin(g.t * 6);
        
        // Intimidating aura (cached)
        const auraRadius = e.r + 20;
        const auraKey = `boss_${phase}_${((pulseIntensity*100)|0)}`;
        let auraGradient = gradientCache.get(auraKey);
        if (!auraGradient) {
          auraGradient = ctx.createRadialGradient(e.x, e.y, e.r, e.x, e.y, auraRadius);
          auraGradient.addColorStop(0, `${phaseColors[phase]}80`);
          auraGradient.addColorStop(1, `${phaseColors[phase]}00`);
          gradientCache.set(auraKey, auraGradient);
        }
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(e.x, e.y, auraRadius, 0, TAU);
        ctx.fill();
        
        // Main boss body with phase color
        ctx.fillStyle = phaseColors[phase] || '#800080'; // Fallback to purple if undefined
        ctx.globalAlpha = pulseIntensity;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, TAU);
        ctx.fill();
        
        // Phase indicator ring
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r + 8, 0, TAU);
        ctx.stroke();
        
        // Draw overlord symbol
        drawEnemySymbol(ctx, e, e.x, e.y, e.r);
        
        ctx.restore();
      } else {
        // Normal enemy rendering with shadow
        ctx.save();
        
        // Apply spawn animation - ENSURE MINIMUM VISIBILITY
        if (e.spawnTimer && e.spawnTimer > 0) {
          const progress = Math.max(0.3, 1 - (e.spawnTimer / 0.5)); // MINIMUM 30% visibility
          if (e.spawnAnimation === 'fade') {
            ctx.globalAlpha = progress;
          } else if (e.spawnAnimation === 'scale') {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.scale(progress, progress);
            ctx.translate(-e.x, -e.y);
            
            // Draw the enemy while scaled
            // SIMPLE COLOR SYSTEM - ALWAYS HAVE A VALID COLOR
            let renderColor = '#ff4444'; // Default bright red - ALWAYS visible
            
            // Get the color, with multiple fallbacks
            if (e.color && e.color !== '' && e.color !== 'undefined' && e.color !== 'null') {
              renderColor = e.color;
            } else if (e.originalColor && e.originalColor !== '' && e.originalColor !== 'undefined') {
              renderColor = e.originalColor;
            } else if (e.baseColor && e.baseColor !== '' && e.baseColor !== 'undefined') {
              renderColor = e.baseColor;
            }
            
            // Apply crit flash if needed
            if (e.critFlashTimer > 0) {
              renderColor = '#ffff88';
            }
            
            // ALWAYS use a valid color
            ctx.fillStyle = renderColor;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.r, 0, TAU);
            ctx.fill();
            
            ctx.restore(); // ALWAYS restore after scale
            
            // Draw enemy symbol AFTER scale restore to prevent distortion
            drawEnemySymbol(ctx, e, e.x, e.y, e.r);
          } else {
            // No scale animation, draw normally
            let renderColor = '#ff4444';
            if (e.color && e.color !== '' && e.color !== 'undefined' && e.color !== 'null') {
              renderColor = e.color;
            } else if (e.originalColor && e.originalColor !== '' && e.originalColor !== 'undefined') {
              renderColor = e.originalColor;
            } else if (e.baseColor && e.baseColor !== '' && e.baseColor !== 'undefined') {
              renderColor = e.baseColor;
            }
            if (e.critFlashTimer > 0) {
              renderColor = '#ffff88';
            }
            ctx.fillStyle = renderColor;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.r, 0, TAU);
            ctx.fill();
            drawEnemySymbol(ctx, e, e.x, e.y, e.r);
          }
        } else {
          // No spawn animation at all
          let renderColor = '#ff4444';
          if (e.color && e.color !== '' && e.color !== 'undefined' && e.color !== 'null') {
            renderColor = e.color;
          } else if (e.originalColor && e.originalColor !== '' && e.originalColor !== 'undefined') {
            renderColor = e.originalColor;
          } else if (e.baseColor && e.baseColor !== '' && e.baseColor !== 'undefined') {
            renderColor = e.baseColor;
          }
          if (e.critFlashTimer > 0) {
            renderColor = '#ffff88';
          }
          ctx.fillStyle = renderColor;
          ctx.beginPath();
          ctx.arc(e.x, e.y, e.r, 0, TAU);
          ctx.fill();
          drawEnemySymbol(ctx, e, e.x, e.y, e.r);
        }
        
        ctx.restore();
        
        // Shield rendering - ONLY for slowpush enemies
        if (e.behavior === 'juggernaut' && e.hasShield && e.shieldHP > 0) {
          // Use lagged shield direction instead of instant player direction
          const shieldDir = e.shieldDirection || { x: 1, y: 0 };
          const shieldOffset = e.r * 1.3; // Shield positioned just outside enemy body
          const shieldX = e.x + shieldDir.x * shieldOffset;
          const shieldY = e.y + shieldDir.y * shieldOffset;
          
          // Shield dimensions (when properly oriented)
          const shieldLength = e.r * 1.2;  // Length of shield (perpendicular to direction)
          const shieldThickness = e.r * 0.8; // Thickness of shield (along direction)
          
          // Calculate angle to rotate shield perpendicular to enemy-player line
          const shieldAngle = Math.atan2(shieldDir.y, shieldDir.x);
          
          // Shield health-based transparency
          const shieldAlpha = Math.max(0.3, e.shieldHP / e.maxShieldHP);
          
          ctx.save();
          ctx.globalAlpha = shieldAlpha;
          
          // Translate to shield position and rotate perpendicular
          ctx.translate(shieldX, shieldY);
          ctx.rotate(shieldAngle + Math.PI/2); // Rotate 90 degrees to be perpendicular
          
          // Draw shield (now properly oriented as a wall)
          ctx.fillStyle = '#cccccc'; // Light gray shield (very visible)
          ctx.fillRect(-shieldLength/2, -shieldThickness/2, shieldLength, shieldThickness);
          
          // Shield border
          ctx.strokeStyle = '#aaaaaa';
          ctx.lineWidth = 1;
          ctx.strokeRect(-shieldLength/2, -shieldThickness/2, shieldLength, shieldThickness);
          
          ctx.restore();
        }
      }
    }

    // player bullets - batched rendering
    setFillStyle('#e3e7ef');
    ctx.beginPath();
    for (const b of bullets.items){
      if (!b.alive) continue;
      ctx.moveTo(b.x + b.r, b.y);
      ctx.arc(b.x, b.y, b.r, 0, TAU);
    }
    ctx.fill();

    // enemy bullets - batched rendering
    setFillStyle('#ff4444');
    ctx.beginPath();
    for (const eb of enemyBullets.items){
      if (!eb.alive) continue;
      ctx.moveTo(eb.x + eb.r, eb.y);
      ctx.arc(eb.x, eb.y, eb.r, 0, TAU);
    }
    ctx.fill();

    // pickups
    for (const pickup of pickups.items){
      if (!pickup.alive) continue;
      ctx.save();
      
      // Apply rotation if crystal has it
      if (pickup.rotation !== undefined) {
        ctx.translate(pickup.x, pickup.y);
        ctx.rotate(pickup.rotation);
        ctx.translate(-pickup.x, -pickup.y);
      }
      
      // Enhanced animated sparkle effect
      const sparkle = 0.7 + 0.3 * fastSin(g.t * 12 + pickup.bounceTimer * 3);
      ctx.globalAlpha = sparkle;
      
      // Glow effect removed - no shadows
      
      // Color based on pickup type
      const powerup = bulletPowerupMap.get(pickup.type);
      
      // Special glow effects for homing crystals (gold)
      if (pickup.type === 'homing') {
        // Golden glow aura
        const glowIntensity = 0.7 + 0.3 * fastSin(g.t * 15 + pickup.bounceTimer * 5);
        const glowSize = 25 + 10 * fastSin(g.t * 8);
        
        // Cache expensive gradient creation (numeric key is faster)
        const glowKey = ((glowSize*100)|0) * 10000 + ((glowIntensity*100)|0);
        let outerGlow = gradientCache.get(glowKey);
        if (!outerGlow) {
          outerGlow = ctx.createRadialGradient(0, 0, 8, 0, 0, glowSize);
          const alpha08 = (glowIntensity * 0.8).toFixed(2);
          const alpha04 = (glowIntensity * 0.4).toFixed(2);
          outerGlow.addColorStop(0, 'rgba(255,215,0,' + alpha08 + ')');
          outerGlow.addColorStop(0.5, 'rgba(255,215,0,' + alpha04 + ')');
          outerGlow.addColorStop(1, 'rgba(255,215,0,0)');
          gradientCache.set(glowKey, outerGlow);
        }
        ctx.fillStyle = outerGlow;
        ctx.beginPath();
        ctx.arc(pickup.x, pickup.y, glowSize, 0, TAU);
        ctx.fill();
        
        // Inner bright core (cached)
        const coreKey = `core_${((glowIntensity*100)|0)}`;
        let coreGlow = gradientCache.get(coreKey);
        if (!coreGlow) {
          coreGlow = ctx.createRadialGradient(pickup.x, pickup.y, 0, pickup.x, pickup.y, 12);
          coreGlow.addColorStop(0, `rgba(255, 255, 255, ${glowIntensity * 0.9})`);
          coreGlow.addColorStop(0.3, `rgba(255, 235, 59, ${glowIntensity * 0.7})`);
          coreGlow.addColorStop(1, `rgba(255, 215, 0, ${glowIntensity * 0.3})`);
          gradientCache.set(coreKey, coreGlow);
        }
        ctx.fillStyle = coreGlow;
        ctx.beginPath();
        ctx.arc(pickup.x, pickup.y, 12, 0, TAU);
        ctx.fill();
      }
      
      // Draw based on pickup type
      if (pickup.type === 'detonator') {
        // Remote Detonator - Rectangle with red center and black rim
        const width = 20;
        const height = 14;
        
        // Black rim
        ctx.fillStyle = '#000000';
        ctx.fillRect(pickup.x - width/2, pickup.y - height/2, width, height);
        
        // Red center
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(pickup.x - width/2 + 2, pickup.y - height/2 + 2, width - 4, height - 4);
        
        // Small yellow button in center
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(pickup.x - 3, pickup.y - 3, 6, 6);
      } else {
        // Enhanced crystal drawing with multi-layered structure
        const size = pickup.type === 'homing' ? 15 : 12;
        const baseColor = powerup ? powerup.color : '#ffffff';
        
        // 1. Different crystal shapes for different types
        const gradient = ctx.createRadialGradient(pickup.x, pickup.y, 0, pickup.x, pickup.y, size);
        
        // Parse color and create gradient (darker edges to lighter center)
        if (pickup.type === 'homing') {
          // Special gradient for homing
          gradient.addColorStop(0, '#ffffff');
          gradient.addColorStop(0.5, baseColor);
          gradient.addColorStop(1, baseColor + '88');
        } else if (pickup.type === 'lightning') {
          // Yellow/blue gradient for lightning
          gradient.addColorStop(0, '#FFFF00');
          gradient.addColorStop(0.3, '#FFD700');
          gradient.addColorStop(0.6, '#87CEEB');
          gradient.addColorStop(1, '#87CEEB66');
        } else {
          gradient.addColorStop(0, baseColor);
          gradient.addColorStop(0.7, baseColor + 'cc');
          gradient.addColorStop(1, baseColor + '66');
        }
        
        ctx.fillStyle = gradient;
        ctx.strokeStyle = pickup.type === 'homing' ? '#FFFFFF' : '#ffffff88';
        ctx.lineWidth = pickup.type === 'homing' ? 2 : 1;
        
        // Draw different shapes based on crystal type
        ctx.beginPath();
        
        if (pickup.type === 'homing') {
          // Star shape for homing
          for (let i = 0; i < 8; i++) {
            const angle = (i * Math.PI / 4) - Math.PI / 2;
            const radius = i % 2 === 0 ? size : size * 0.5;
            const x = pickup.x + Math.cos(angle) * radius;
            const y = pickup.y + Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
        } else if (pickup.type === 'explosive') {
          // Hexagon for explosive
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI / 3) - Math.PI / 6;
            const x = pickup.x + Math.cos(angle) * size;
            const y = pickup.y + Math.sin(angle) * size;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
        } else if (pickup.type === 'lightning') {
          // Lightning bolt shape - simple zig-zag
          ctx.moveTo(pickup.x - size*0.3, pickup.y - size);
          ctx.lineTo(pickup.x + size*0.2, pickup.y - size*0.3);
          ctx.lineTo(pickup.x - size*0.1, pickup.y);
          ctx.lineTo(pickup.x + size*0.3, pickup.y + size);
          ctx.lineTo(pickup.x - size*0.2, pickup.y + size*0.3);
          ctx.lineTo(pickup.x, pickup.y);
          // Don't manually close - let closePath() handle it
        } else if (pickup.type === 'freeze') {
          // Snowflake shape (6-pointed star)
          for (let i = 0; i < 12; i++) {
            const angle = (i * Math.PI / 6) - Math.PI / 2;
            const radius = i % 2 === 0 ? size : size * 0.4;
            const x = pickup.x + Math.cos(angle) * radius;
            const y = pickup.y + Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
        } else if (pickup.type === 'ricochet') {
          // Triangle for ricochet
          ctx.moveTo(pickup.x, pickup.y - size);
          ctx.lineTo(pickup.x + size * 0.866, pickup.y + size * 0.5);
          ctx.lineTo(pickup.x - size * 0.866, pickup.y + size * 0.5);
        } else if (pickup.type === 'shotgun') {
          // Stylized connected spread crystal for shotgun
          // Main body with flared end
          ctx.moveTo(pickup.x - size * 0.3, pickup.y + size * 0.4);
          ctx.lineTo(pickup.x - size * 0.3, pickup.y - size * 0.4);
          ctx.lineTo(pickup.x + size * 0.2, pickup.y - size * 0.3);
          // Top spread arm
          ctx.lineTo(pickup.x + size * 0.5, pickup.y - size * 0.7);
          ctx.lineTo(pickup.x + size * 0.8, pickup.y - size * 0.6);
          ctx.lineTo(pickup.x + size * 0.6, pickup.y - size * 0.3);
          // Middle spread arm
          ctx.lineTo(pickup.x + size * 0.7, pickup.y);
          ctx.lineTo(pickup.x + size * 0.9, pickup.y);
          ctx.lineTo(pickup.x + size * 0.7, pickup.y);
          // Bottom spread arm
          ctx.lineTo(pickup.x + size * 0.6, pickup.y + size * 0.3);
          ctx.lineTo(pickup.x + size * 0.8, pickup.y + size * 0.6);
          ctx.lineTo(pickup.x + size * 0.5, pickup.y + size * 0.7);
          ctx.lineTo(pickup.x + size * 0.2, pickup.y + size * 0.3);
        } else if (pickup.type === 'cluster') {
          // Three overlapping circles for cluster
          ctx.arc(pickup.x - size*0.4, pickup.y, size*0.6, 0, TAU);
          ctx.moveTo(pickup.x + size*0.4 + size*0.6, pickup.y - size*0.3);
          ctx.arc(pickup.x + size*0.4, pickup.y - size*0.3, size*0.6, 0, TAU);
          ctx.moveTo(pickup.x + size*0.4 + size*0.6, pickup.y + size*0.3);
          ctx.arc(pickup.x + size*0.4, pickup.y + size*0.3, size*0.6, 0, TAU);
        } else if (pickup.type === 'seeking') {
          // Cool stylized arrow with swept-back wings
          // Arrow tip
          ctx.moveTo(pickup.x, pickup.y - size);
          // Right wing
          ctx.lineTo(pickup.x + size*0.8, pickup.y - size*0.2);
          ctx.lineTo(pickup.x + size*0.5, pickup.y);
          // Right shaft indent
          ctx.lineTo(pickup.x + size*0.3, pickup.y - size*0.1);
          // Shaft
          ctx.lineTo(pickup.x + size*0.2, pickup.y + size*0.6);
          // Right tail fin
          ctx.lineTo(pickup.x + size*0.6, pickup.y + size*0.8);
          ctx.lineTo(pickup.x + size*0.2, pickup.y + size);
          // Bottom center
          ctx.lineTo(pickup.x, pickup.y + size*0.7);
          // Left tail fin
          ctx.lineTo(pickup.x - size*0.2, pickup.y + size);
          ctx.lineTo(pickup.x - size*0.6, pickup.y + size*0.8);
          // Left shaft
          ctx.lineTo(pickup.x - size*0.2, pickup.y + size*0.6);
          // Left shaft indent
          ctx.lineTo(pickup.x - size*0.3, pickup.y - size*0.1);
          // Left wing
          ctx.lineTo(pickup.x - size*0.5, pickup.y);
          ctx.lineTo(pickup.x - size*0.8, pickup.y - size*0.2);
        } else {
          // Default diamond shape (for dual, triple, quad)
          ctx.moveTo(pickup.x, pickup.y - size);
          ctx.lineTo(pickup.x + size, pickup.y);
          ctx.lineTo(pickup.x, pickup.y + size);
          ctx.lineTo(pickup.x - size, pickup.y);
        }
        
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // 2. Pulsing inner glow based on crystal type
        let pulseSpeed = 4;
        let pulseIntensity = 0.3;
        
        // Different pulse patterns for different crystal types
        if (pickup.type === 'homing') {
          pulseSpeed = 8; // Fast pulse for homing
          pulseIntensity = 0.5;
        } else if (pickup.type === 'explosive') {
          pulseSpeed = 3; // Slow, intense pulse
          pulseIntensity = 0.4;
        } else if (pickup.type === 'lightning') {
          pulseSpeed = 10; // Very fast flicker
          pulseIntensity = 0.6;
        } else if (pickup.type === 'freeze') {
          pulseSpeed = 2; // Very slow, gentle
          pulseIntensity = 0.2;
        }
        
        const pulse = Math.max(0, Math.sin(game.t * pulseSpeed) * pulseIntensity + (1 - pulseIntensity));
        const coreSize = size * 0.3 * pulse;
        
        ctx.save();
        ctx.globalAlpha = 0.8;
        const coreGradient = ctx.createRadialGradient(pickup.x, pickup.y, 0, pickup.x, pickup.y, coreSize);
        coreGradient.addColorStop(0, '#ffffff');
        coreGradient.addColorStop(0.5, baseColor);
        coreGradient.addColorStop(1, baseColor + '00');
        
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(pickup.x, pickup.y, coreSize, 0, TAU);
        ctx.fill();
        ctx.restore();
        
        // 3. Particle effects (sparkles/energy wisps)
        // Initialize particle timer if not exists
        if (!pickup.particleTimer) pickup.particleTimer = 0;
        pickup.particleTimer += 0.016; // Approximate dt
        
        // Spawn sparkle particles periodically
        const particleInterval = pickup.type === 'lightning' ? 0.15 : 0.3; // Lightning spawns more frequently
        if (pickup.particleTimer > particleInterval) {
          pickup.particleTimer = 0;
          
          // Spawn more particles for lightning
          const particleCount = pickup.type === 'homing' ? 3 : 
                               pickup.type === 'lightning' ? 4 : 2;
          for (let i = 0; i < particleCount; i++) {
            particles.spawn(p => {
              const angle = Math.random() * TAU;
              const distance = size + Math.random() * 10;
              p.x = pickup.x + Math.cos(angle) * distance;
              p.y = pickup.y + Math.sin(angle) * distance;
              
              // Energy wisps float upward
              p.vx = (Math.random() - 0.5) * 20;
              p.vy = -30 - Math.random() * 20; // Upward movement
              
              p.life = 0;
              p.maxLife = 0.8 + Math.random() * 0.4;
              p.size = 1 + Math.random() * 2;
              // Use bright cyan for lightning particles for visibility
              p.color = pickup.type === 'homing' ? '#ffffff' : 
                       pickup.type === 'lightning' ? '#00FFFF' : 
                       baseColor;
              p.hasGravity = false;
              p.alive = true;
            });
          }
        }
        
      }
      
      ctx.restore();
    }

    // mines and grenades - explosive devices
    for (const mine of mines.items) {
      if (!mine.alive) continue;
      
      // Different rendering for grenades vs mines
      if (mine.isGrenade) {
        // Calculate grenade position with height offset
        const drawY = mine.y - (mine.z || 0) * 0.5; // Visual height offset
        const size = mine.r || 6;
        
        // Shadow on ground (shows where grenade will land)
        if (mine.z > 0) {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.beginPath();
          ctx.ellipse(mine.x, mine.y, size * 0.8, size * 0.4, 0, 0, TAU);
          ctx.fill();
        }
        
        // Grenade body - red color
        ctx.fillStyle = mine.isTriggered ? '#ff0000' : '#cc0000'; // Bright red when triggered
        ctx.strokeStyle = mine.isTriggered ? '#ffaa00' : '#660000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(mine.x, drawY, size, 0, TAU);
        ctx.fill();
        ctx.stroke();
        
        // Add spinning effect
        ctx.strokeStyle = '#990000';
        ctx.lineWidth = 1;
        const spin = mine.fuseTime * 10;
        ctx.beginPath();
        ctx.moveTo(mine.x + Math.cos(spin) * size, drawY + Math.sin(spin) * size);
        ctx.lineTo(mine.x - Math.cos(spin) * size, drawY - Math.sin(spin) * size);
        ctx.stroke();
        
        // Motion trail for flying grenades
        if ((mine.vx !== 0 || mine.vy !== 0) && mine.z > 0) {
          // Normalize trail length to prevent huge lines
          const trailLength = 15; // Fixed trail length in pixels
          const speed = Math.sqrt(mine.vx * mine.vx + mine.vy * mine.vy);
          if (speed > 0) {
            const trailX = (mine.vx / speed) * trailLength;
            const trailY = (mine.vy / speed) * trailLength;
            
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)';
            ctx.lineWidth = size * 0.6;
            ctx.beginPath();
            ctx.moveTo(mine.x, drawY);
            ctx.lineTo(mine.x - trailX, drawY - trailY);
            ctx.stroke();
          }
        }
      } else {
        // Regular mine
        ctx.fillStyle = mine.isArmed ? '#ff4400' : '#994400'; // Orange when armed, dark orange when not
        ctx.beginPath();
        ctx.arc(mine.x, mine.y, mine.r, 0, TAU);
        ctx.fill();
        
        // Show trigger radius for armed mines (static circle)
        if (mine.isArmed && !mine.isTriggered) {
          ctx.strokeStyle = 'rgba(255, 100, 0, 0.3)'; // Faint orange circle
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]); // Small dashed circle
          ctx.beginPath();
          ctx.arc(mine.x, mine.y, mine.triggerRadius, 0, TAU);
          ctx.stroke();
          ctx.setLineDash([]); // Reset line dash
        }
      }
      
      // Flashing effect when triggered and about to explode
      if (mine.isTriggered) {
        const flashRate = Math.min(20, mine.fuseTime * 15); // Accelerating flash
        if (Math.sin(mine.flashTimer * flashRate) > 0) {
          ctx.fillStyle = '#ffff00'; // Bright yellow flash
          ctx.beginPath();
          ctx.arc(mine.x, mine.y, mine.r, 0, TAU);
          ctx.fill();
        }
        
        // Pulsing explosion radius warning circle (doubled size)
        const pulseIntensity = 0.4 + 0.5 * Math.sin(mine.flashTimer * flashRate * 0.8);
        ctx.strokeStyle = `rgba(255, 255, 0, ${pulseIntensity})`;
        ctx.lineWidth = 3;
        ctx.setLineDash([8, 4]); // Bigger dashed circle
        ctx.beginPath();
        ctx.arc(mine.x, mine.y, mine.explosionRadius, 0, TAU);
        ctx.stroke();
        ctx.setLineDash([]); // Reset line dash
      }
      
      // Mine spikes/details
      ctx.strokeStyle = '#663300';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * TAU;
        const spike = mine.r + 2;
        ctx.moveTo(mine.x, mine.y);
        ctx.lineTo(mine.x + fastCos(angle) * spike, mine.y + fastSin(angle) * spike);
      }
      ctx.stroke();
    }

    // particles
    for (const p2 of particles.items){
      if (!p2.alive) continue;
      const a = 1 - p2.life/p2.maxLife;
      ctx.globalAlpha = a*0.9;
      ctx.fillStyle = p2.color;
      ctx.fillRect(p2.x, p2.y, p2.size, p2.size);
      ctx.globalAlpha = 1;
    }

    // Red damage vignette (cached)
    if (g.damageFlash > 0) {
      const intensity = g.damageFlash / 0.3; // Fade from 1 to 0
      const vignetteKey = `vignette_${((intensity*100)|0)}`;
      let gradient = gradientCache.get(vignetteKey);
      if (!gradient) {
        gradient = ctx.createRadialGradient(
          canvas.width/2, canvas.height/2, 0,
          canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)
        );
        gradient.addColorStop(0, `rgba(255, 0, 0, 0)`);
        gradient.addColorStop(0.7, `rgba(255, 0, 0, ${intensity * 0.1})`);
        gradient.addColorStop(1, `rgba(255, 0, 0, ${intensity * 0.4})`);
        gradientCache.set(vignetteKey, gradient);
      }
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Crystal inventory display under HUD
    const crystalInventoryY = 280; // Moved further down to avoid Wave/Kills text overlap
    const crystalSize = 60; // 50% larger than 40 = 60
    const crystalSpacing = 75; // Adjust spacing for larger crystals
    let inventoryIndex = 0;
    
    // Show dual shot if active
    if (g.player.upgradeShots > 0) {
      const x = 50; // Moved right to prevent clipping (crystal extends 30px left from center)
      const y = crystalInventoryY + (inventoryIndex * crystalSpacing);
      
      // Don't draw if it would go off screen
      if (y + crystalSize/2 < canvas.height - 20) {
        ctx.save();
        
        // Enhanced sparkle effect for inventory
        const sparkle = 0.6 + 0.4 * fastSin(g.t * 10 + inventoryIndex * 0.5);
        ctx.globalAlpha = sparkle;
        
        // Add pulsing glow
        // No shadow effects
        
        // Create gradient for dual shot
        const dualGradient = ctx.createRadialGradient(x, y, 0, x, y, crystalSize/2);
        dualGradient.addColorStop(0, '#00BFFF');
        dualGradient.addColorStop(0.7, '#00BFFFcc');
        dualGradient.addColorStop(1, '#00BFFF66');
        
        ctx.fillStyle = dualGradient;
        ctx.strokeStyle = '#ffffff88';
        ctx.lineWidth = 1.5;
        
        // Draw diamond shape for dual shot
        ctx.beginPath();
        ctx.moveTo(x, y - crystalSize/2);
        ctx.lineTo(x + crystalSize/2, y);
        ctx.lineTo(x, y + crystalSize/2);
        ctx.lineTo(x - crystalSize/2, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Draw crystal name
        ctx.fillStyle = '#e3e7ef';
        ctx.font = '18px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('Dual Shot', x + crystalSize/2 + 8, y + 4);
        
        ctx.restore();
        
        inventoryIndex++;
      }
    }
    
    // Show pattern multipliers
    for (const [pattern, shots] of g.player.patternMultipliers) {
      if (shots > 0) {
        const x = 50;
        const y = crystalInventoryY + (inventoryIndex * crystalSpacing);
        
        // Don't draw if it would go off screen
        if (y + crystalSize/2 < canvas.height - 20) {
          ctx.save();
          
          // Enhanced sparkle effect for inventory
          const sparkle = 0.6 + 0.4 * fastSin(g.t * 10 + inventoryIndex * 0.5);
          ctx.globalAlpha = sparkle;
          
          const powerup = bulletPowerupMap.get(pattern);
          
          // Add pulsing glow
          // No shadow effects
          
          // Create gradient for pattern crystals
          const patternGradient = ctx.createRadialGradient(x, y, 0, x, y, crystalSize/2);
          const baseColor = powerup ? powerup.color : '#ffffff';
          
          if (pattern === 'triple') {
            // Use swapped color for triple (green)
            patternGradient.addColorStop(0, '#32CD32');
            patternGradient.addColorStop(0.7, '#32CD32cc');
            patternGradient.addColorStop(1, '#32CD3266');
          } else if (pattern === 'quad') {
            patternGradient.addColorStop(0, baseColor);
            patternGradient.addColorStop(0.7, baseColor + 'cc');
            patternGradient.addColorStop(1, baseColor + '66');
          } else {
            patternGradient.addColorStop(0, baseColor);
            patternGradient.addColorStop(0.7, baseColor + 'cc');
            patternGradient.addColorStop(1, baseColor + '66');
          }
          
          ctx.fillStyle = patternGradient;
          ctx.strokeStyle = '#ffffff88';
          ctx.lineWidth = 1.5;
          
          // Draw diamond shape for patterns
          ctx.beginPath();
          ctx.moveTo(x, y - crystalSize/2);
          ctx.lineTo(x + crystalSize/2, y);
          ctx.lineTo(x, y + crystalSize/2);
          ctx.lineTo(x - crystalSize/2, y);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          // Draw crystal name
          ctx.fillStyle = '#e3e7ef';
          ctx.font = '18px system-ui';
          ctx.textAlign = 'left';
          const crystalName = powerup ? powerup.name : pattern;
          ctx.fillText(crystalName, x + crystalSize/2 + 8, y + 4);
          
          ctx.restore();
          
          inventoryIndex++;
        }
      }
    }
    
    // Show active effects
    for (const [effect, shots] of g.player.activeEffects) {
      if (shots > 0) {
        const x = 50;
        const y = crystalInventoryY + (inventoryIndex * crystalSpacing);
        
        // Don't draw if it would go off screen
        if (y + crystalSize/2 < canvas.height - 20) {
          ctx.save();
          
          // Enhanced sparkle effect for inventory
          const sparkle = 0.6 + 0.4 * fastSin(g.t * 10 + inventoryIndex * 0.5);
          ctx.globalAlpha = sparkle;
          
          const powerup = bulletPowerupMap.get(effect);
          
          // Special glow effects for homing crystals in inventory
          if (effect === 'homing') {
            const glowIntensity = 0.7 + 0.3 * fastSin(g.t * 12);
            const glowSize = crystalSize/2 + 20;
            
            // Add extra shadow glow for homing
            // No shadow effects
            
            // Golden glow aura for inventory homing crystal (cached)
            const invGlowKey = `inv_homing_${((glowIntensity*100)|0)}_${((glowSize*10)|0)}`;
            let inventoryGlow = gradientCache.get(invGlowKey);
            if (!inventoryGlow) {
              inventoryGlow = ctx.createRadialGradient(x, y, crystalSize/2, x, y, glowSize);
              inventoryGlow.addColorStop(0, `rgba(255, 215, 0, ${glowIntensity * 0.6})`);
              inventoryGlow.addColorStop(0.7, `rgba(255, 215, 0, ${glowIntensity * 0.3})`);
              inventoryGlow.addColorStop(1, `rgba(255, 215, 0, 0)`);
              gradientCache.set(invGlowKey, inventoryGlow);
            }
            ctx.fillStyle = inventoryGlow;
            ctx.beginPath();
            ctx.arc(x, y, glowSize, 0, TAU);
            ctx.fill();
          }
          
          // Create gradient based on crystal type
          const effectGradient = ctx.createRadialGradient(x, y, 0, x, y, crystalSize/2);
          const baseColor = powerup ? powerup.color : '#ffffff';
          
          if (effect === 'homing') {
            // Golden gradient for homing
            effectGradient.addColorStop(0, '#ffffff');
            effectGradient.addColorStop(0.5, '#FFD700');
            effectGradient.addColorStop(1, '#FFD70088');
          } else if (effect === 'lightning') {
            // Yellow/blue gradient for lightning
            effectGradient.addColorStop(0, '#FFFF00');
            effectGradient.addColorStop(0.3, '#FFD700');
            effectGradient.addColorStop(0.6, '#87CEEB');
            effectGradient.addColorStop(1, '#87CEEB66');
          } else {
            effectGradient.addColorStop(0, baseColor);
            effectGradient.addColorStop(0.7, baseColor + 'cc');
            effectGradient.addColorStop(1, baseColor + '66');
          }
          
          ctx.fillStyle = effectGradient;
          ctx.strokeStyle = effect === 'homing' ? '#FFFFFF' : '#ffffff88';
          ctx.lineWidth = effect === 'homing' ? 2 : 1.5;
          
          // Draw different shapes based on crystal type
          ctx.beginPath();
          
          if (effect === 'homing') {
            // Star shape for homing
            for (let i = 0; i < 8; i++) {
              const angle = (i * Math.PI / 4) - Math.PI / 2;
              const radius = i % 2 === 0 ? crystalSize/2 : crystalSize/2 * 0.5;
              const px = x + Math.cos(angle) * radius;
              const py = y + Math.sin(angle) * radius;
              if (i === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
          } else if (effect === 'explosive') {
            // Hexagon for explosive
            for (let i = 0; i < 6; i++) {
              const angle = (i * Math.PI / 3) - Math.PI / 6;
              const px = x + Math.cos(angle) * crystalSize/2;
              const py = y + Math.sin(angle) * crystalSize/2;
              if (i === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
          } else if (effect === 'lightning') {
            // Lightning bolt shape
            ctx.moveTo(x - crystalSize/2*0.3, y - crystalSize/2);
            ctx.lineTo(x + crystalSize/2*0.2, y - crystalSize/2*0.3);
            ctx.lineTo(x - crystalSize/2*0.1, y);
            ctx.lineTo(x + crystalSize/2*0.3, y + crystalSize/2);
            ctx.lineTo(x - crystalSize/2*0.2, y + crystalSize/2*0.3);
            ctx.lineTo(x, y);
          } else if (effect === 'freeze') {
            // Snowflake shape (6-pointed star)
            for (let i = 0; i < 12; i++) {
              const angle = (i * Math.PI / 6) - Math.PI / 2;
              const radius = i % 2 === 0 ? crystalSize/2 : crystalSize/2 * 0.4;
              const px = x + Math.cos(angle) * radius;
              const py = y + Math.sin(angle) * radius;
              if (i === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
          } else if (effect === 'ricochet') {
            // Triangle for ricochet
            ctx.moveTo(x, y - crystalSize/2);
            ctx.lineTo(x + crystalSize/2 * 0.866, y + crystalSize/2 * 0.5);
            ctx.lineTo(x - crystalSize/2 * 0.866, y + crystalSize/2 * 0.5);
          } else if (effect === 'seeking') {
            // Cool stylized arrow with swept-back wings (matching ground pickup)
            const s = crystalSize/2;
            // Arrow tip
            ctx.moveTo(x, y - s);
            // Right wing
            ctx.lineTo(x + s*0.8, y - s*0.2);
            ctx.lineTo(x + s*0.5, y);
            // Right shaft indent
            ctx.lineTo(x + s*0.3, y - s*0.1);
            // Shaft
            ctx.lineTo(x + s*0.2, y + s*0.6);
            // Right tail fin
            ctx.lineTo(x + s*0.6, y + s*0.8);
            ctx.lineTo(x + s*0.2, y + s);
            // Bottom center
            ctx.lineTo(x, y + s*0.7);
            // Left tail fin
            ctx.lineTo(x - s*0.2, y + s);
            ctx.lineTo(x - s*0.6, y + s*0.8);
            ctx.lineTo(x - s*0.2, y + s*0.6);
            // Left shaft
            ctx.lineTo(x - s*0.3, y - s*0.1);
            ctx.lineTo(x - s*0.5, y);
            // Left wing
            ctx.lineTo(x - s*0.8, y - s*0.2);
          } else if (effect === 'shotgun') {
            // Stylized connected spread crystal for shotgun
            const s = crystalSize/2;
            // Main body with flared end
            ctx.moveTo(x - s * 0.3, y + s * 0.4);
            ctx.lineTo(x - s * 0.3, y - s * 0.4);
            ctx.lineTo(x + s * 0.2, y - s * 0.3);
            // Top spread arm
            ctx.lineTo(x + s * 0.5, y - s * 0.7);
            ctx.lineTo(x + s * 0.8, y - s * 0.6);
            ctx.lineTo(x + s * 0.6, y - s * 0.3);
            // Middle spread arm
            ctx.lineTo(x + s * 0.7, y);
            ctx.lineTo(x + s * 0.9, y);
            ctx.lineTo(x + s * 0.7, y);
            // Bottom spread arm
            ctx.lineTo(x + s * 0.6, y + s * 0.3);
            ctx.lineTo(x + s * 0.8, y + s * 0.6);
            ctx.lineTo(x + s * 0.5, y + s * 0.7);
            ctx.lineTo(x + s * 0.2, y + s * 0.3);
          } else if (effect === 'cluster') {
            // Three overlapping circles for cluster (matching ground pickup)
            const s = crystalSize/2;
            ctx.arc(x - s*0.4, y, s*0.6, 0, Math.PI * 2);
            ctx.moveTo(x + s*0.4 + s*0.6, y - s*0.3);
            ctx.arc(x + s*0.4, y - s*0.3, s*0.6, 0, Math.PI * 2);
            ctx.moveTo(x + s*0.4 + s*0.6, y + s*0.3);
            ctx.arc(x + s*0.4, y + s*0.3, s*0.6, 0, Math.PI * 2);
          } else {
            // Default diamond for unknown types
            ctx.moveTo(x, y - crystalSize/2);
            ctx.lineTo(x + crystalSize/2, y);
            ctx.lineTo(x, y + crystalSize/2);
            ctx.lineTo(x - crystalSize/2, y);
          }
          
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          // Draw crystal name
          ctx.fillStyle = '#e3e7ef';
          ctx.font = '18px system-ui';
          ctx.textAlign = 'left';
          const crystalName = powerup ? powerup.name : effect;
          ctx.fillText(crystalName, x + crystalSize/2 + 8, y + 4);
          
          ctx.restore();
          
          inventoryIndex++;
        }
      }
    }
  }

  // ===== Enemy Symbol Drawing =====
  function drawEnemySymbol(ctx, e, x, y, r) {
    ctx.save();
    ctx.strokeStyle = '#000000';
    ctx.fillStyle = '#000000';
    ctx.lineWidth = Math.max(1, r * 0.15);
    ctx.globalAlpha = 0.9; // More opaque for better visibility
    
    const symbolSize = r * 0.6; // Symbol is 60% of enemy radius
    
    // First check if it's a shooter - shooters get priority for crosshair
    if (e.isShooter) {
      // Crosshair for shooters - always draw this for shooters
      ctx.lineWidth = Math.max(2, r * 0.15);
      ctx.beginPath();
      ctx.arc(x, y, symbolSize * 0.4, 0, TAU);
      ctx.moveTo(x - symbolSize * 0.6, y);
      ctx.lineTo(x + symbolSize * 0.6, y);
      ctx.moveTo(x, y - symbolSize * 0.6);
      ctx.lineTo(x, y + symbolSize * 0.6);
      ctx.stroke();
      ctx.restore();
      return;
    }
    
    // Draw based on behavior type
    switch(e.behavior) {
      case 'stalker':
        // Single dot - basic enemy
        ctx.beginPath();
        ctx.arc(x, y, symbolSize * 0.25, 0, TAU);
        ctx.fill();
        break;
        
      case 'volatile':
        // Radiation/danger symbol - exclamation mark !
        ctx.fillStyle = '#000000';
        ctx.lineWidth = Math.max(2, r * 0.15);
        // Main stroke
        ctx.beginPath();
        ctx.moveTo(x, y - symbolSize * 0.5);
        ctx.lineTo(x, y + symbolSize * 0.1);
        ctx.stroke();
        // Dot
        ctx.beginPath();
        ctx.arc(x, y + symbolSize * 0.35, symbolSize * 0.12, 0, TAU);
        ctx.fill();
        break;
        
      case 'berserker':
        // Forward arrows >>>
        ctx.lineWidth = Math.max(2, r * 0.15);
        for(let i = 0; i < 3; i++) {
          const offset = (i - 1) * symbolSize * 0.3;
          ctx.beginPath();
          ctx.moveTo(x + offset - symbolSize * 0.2, y - symbolSize * 0.3);
          ctx.lineTo(x + offset + symbolSize * 0.2, y);
          ctx.lineTo(x + offset - symbolSize * 0.2, y + symbolSize * 0.3);
          ctx.stroke();
        }
        break;
        
      case 'vortex':
        // Spiral pattern
        ctx.lineWidth = Math.max(1.5, r * 0.12);
        for(let i = 0; i < 3; i++) {
          const angle = (i / 3) * TAU;
          ctx.beginPath();
          ctx.arc(x, y, symbolSize * 0.6, angle, angle + Math.PI * 0.6);
          ctx.stroke();
        }
        break;
        
      case 'bomber':
        // Bomb with fuse
        ctx.beginPath();
        ctx.arc(x, y, symbolSize * 0.4, 0, TAU);
        ctx.fill();
        // Fuse
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = Math.max(1, r * 0.1);
        ctx.beginPath();
        ctx.moveTo(x + symbolSize * 0.3, y - symbolSize * 0.3);
        ctx.lineTo(x + symbolSize * 0.6, y - symbolSize * 0.6);
        ctx.stroke();
        // Spark
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(x + symbolSize * 0.6, y - symbolSize * 0.6, symbolSize * 0.15, 0, TAU);
        ctx.fill();
        break;
        
      case 'juggernaut':
        // Shield shape
        ctx.lineWidth = Math.max(2, r * 0.2);
        ctx.beginPath();
        ctx.moveTo(x, y - symbolSize * 0.6);
        ctx.lineTo(x - symbolSize * 0.5, y - symbolSize * 0.3);
        ctx.lineTo(x - symbolSize * 0.5, y + symbolSize * 0.3);
        ctx.lineTo(x, y + symbolSize * 0.6);
        ctx.lineTo(x + symbolSize * 0.5, y + symbolSize * 0.3);
        ctx.lineTo(x + symbolSize * 0.5, y - symbolSize * 0.3);
        ctx.closePath();
        ctx.stroke();
        break;
        
      case 'divider':
        // Y shape with dots
        ctx.lineWidth = Math.max(2, r * 0.15);
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - symbolSize * 0.4, y - symbolSize * 0.5);
        ctx.moveTo(x, y);
        ctx.lineTo(x + symbolSize * 0.4, y - symbolSize * 0.5);
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + symbolSize * 0.5);
        ctx.stroke();
        // Dots at ends
        ctx.beginPath();
        ctx.arc(x - symbolSize * 0.4, y - symbolSize * 0.5, symbolSize * 0.12, 0, TAU);
        ctx.arc(x + symbolSize * 0.4, y - symbolSize * 0.5, symbolSize * 0.12, 0, TAU);
        ctx.arc(x, y + symbolSize * 0.5, symbolSize * 0.12, 0, TAU);
        ctx.fill();
        break;
        
      case 'trapper':
        // Hexagon mine shape
        ctx.lineWidth = Math.max(1.5, r * 0.15);
        ctx.beginPath();
        for(let i = 0; i < 6; i++) {
          const angle = (i / 6) * TAU;
          const px = x + Math.cos(angle) * symbolSize * 0.5;
          const py = y + Math.sin(angle) * symbolSize * 0.5;
          if(i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
        // Center spike
        ctx.beginPath();
        ctx.arc(x, y, symbolSize * 0.15, 0, TAU);
        ctx.fill();
        break;
        
      case 'serpent':
        // Wavy line
        ctx.lineWidth = Math.max(2, r * 0.15);
        ctx.beginPath();
        ctx.moveTo(x - symbolSize * 0.6, y);
        ctx.quadraticCurveTo(x - symbolSize * 0.3, y - symbolSize * 0.4, x, y);
        ctx.quadraticCurveTo(x + symbolSize * 0.3, y + symbolSize * 0.4, x + symbolSize * 0.6, y);
        ctx.stroke();
        break;
        
      case 'prowler':
        // Parentheses ( ) for flanking
        ctx.lineWidth = Math.max(2, r * 0.15);
        ctx.beginPath();
        ctx.arc(x - symbolSize * 0.25, y, symbolSize * 0.4, -Math.PI * 0.4, Math.PI * 0.4);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x + symbolSize * 0.25, y, symbolSize * 0.4, Math.PI * 0.6, Math.PI * 1.4);
        ctx.stroke();
        break;
        
      case 'leaper':
        // Up arrow for jumping
        ctx.lineWidth = Math.max(2, r * 0.15);
        ctx.beginPath();
        ctx.moveTo(x, y - symbolSize * 0.5);
        ctx.lineTo(x - symbolSize * 0.3, y);
        ctx.moveTo(x, y - symbolSize * 0.5);
        ctx.lineTo(x + symbolSize * 0.3, y);
        ctx.moveTo(x, y - symbolSize * 0.5);
        ctx.lineTo(x, y + symbolSize * 0.5);
        ctx.stroke();
        break;
        
      case 'maniac':
        // Chaotic X marks
        ctx.lineWidth = Math.max(2, r * 0.15);
        ctx.strokeStyle = '#000000';
        ctx.beginPath();
        ctx.moveTo(x - symbolSize * 0.4, y - symbolSize * 0.4);
        ctx.lineTo(x + symbolSize * 0.4, y + symbolSize * 0.4);
        ctx.moveTo(x + symbolSize * 0.4, y - symbolSize * 0.4);
        ctx.lineTo(x - symbolSize * 0.4, y + symbolSize * 0.4);
        ctx.stroke();
        // Question mark dot
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(x, y + symbolSize * 0.6, symbolSize * 0.1, 0, TAU);
        ctx.fill();
        break;
        
      case 'boss':
        // Diamond (two-pointed triangle) for mini-boss
        ctx.lineWidth = Math.max(2, r * 0.15);
        ctx.strokeStyle = '#000000';
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        // Diamond shape
        ctx.moveTo(x, y - symbolSize * 0.6); // Top
        ctx.lineTo(x + symbolSize * 0.5, y); // Right
        ctx.lineTo(x, y + symbolSize * 0.6); // Bottom
        ctx.lineTo(x - symbolSize * 0.5, y); // Left
        ctx.closePath();
        ctx.stroke();
        break;
        
      case 'superboss':
        // Three-pointed triangle for super boss
        ctx.lineWidth = Math.max(2, r * 0.15);
        ctx.strokeStyle = '#000000';
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        // Equilateral triangle
        const triRadius = symbolSize * 0.6;
        for(let i = 0; i < 3; i++) {
          const angle = (i / 3) * TAU - Math.PI/2; // Start from top
          const px = x + Math.cos(angle) * triRadius;
          const py = y + Math.sin(angle) * triRadius;
          if(i === 0) {
            ctx.moveTo(px, py);
          } else {
            ctx.lineTo(px, py);
          }
        }
        ctx.closePath();
        ctx.stroke();
        break;
        
      default:
        // Simple dot for unknown behaviors (should never happen)
        ctx.beginPath();
        ctx.arc(x, y, symbolSize * 0.3, 0, TAU);
        ctx.fill();
    }
    
    ctx.restore();
  }

  // ===== Loop (fixed-timestep with interpolation) =====
  let last = performance.now();
  const dtFixed = 1/60;
  let acc = 0;
  function frame(now){
    try {
      const rawDt = Math.min(0.05, (now - last)*0.001);
      updatePerformanceLevel(rawDt * 1000); // Convert to milliseconds
      last = now;
      if (game && game.state === STATE.RUN){
        acc += rawDt;
        acc = Math.min(acc, dtFixed * 3); // Cap at 3 frames max to prevent spiral of death
        while (acc >= dtFixed){
          try {
            update(game, dtFixed);
          } catch (updateError) {
            // Game update error
            // Pause game on critical error to prevent infinite errors
            if (game) setState(game, STATE.PAUSE);
            // Notify user of error
            if (banner) {
              banner.textContent = 'Game Error - Please Refresh';
              banner.style.display = 'block';
            }
            break;
          }
          acc -= dtFixed;
        }
        const alpha = acc / dtFixed;
        try {
          draw(game, alpha);
        } catch (drawError) {
          // Game draw error
        }
      }

      // FPS
      if (game){
        try {
          const fps = 1/rawDt;
          game.fpsSamples.push(fps);
          game.fpsSum += fps;
          if (game.fpsSamples.length > 20){
            game.fpsSum -= game.fpsSamples.shift(); // Subtract removed value
            const avg = game.fpsSum / game.fpsSamples.length;
            fpsTxt.textContent = 'FPS: ' + Math.round(avg);
          }
        } catch (fpsError) {
          // FPS calculation error
        }
      }
    } catch (frameError) {
      // Critical frame error
    }

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ===== Animated enemy preview system =====
  let enemyPreviewAnimations = [];
  
  function initEnemyPreviews() {
    // Clear any existing animations
    enemyPreviewAnimations.forEach(anim => cancelAnimationFrame(anim.id));
    enemyPreviewAnimations = [];
    
    // Get all canvas elements for enemy previews
    const canvases = document.querySelectorAll('.enemy-preview-canvas');
    
    canvases.forEach(canvas => {
      const ctx = canvas.getContext('2d');
      const color = canvas.dataset.enemyColor;
      const behavior = canvas.dataset.enemyBehavior;
      const isShooter = canvas.dataset.enemyShooter === 'true';
      const shootPattern = canvas.dataset.shootPattern || 'single';
      
      // Set proper scaling for high DPI displays
      const scale = 2; // 2x resolution for clarity
      canvas.style.width = '80px';
      canvas.style.height = '80px';
      
      // Animation state for this enemy (coordinates in logical space, not scaled)
      const animState = {
        x: 40,
        y: 40,
        targetX: 60,
        targetY: 40,
        time: 0,
        radius: behavior === 'superboss' || behavior === 'boss' ? 24 : 16,
        projectiles: [],
        lastShot: 0
      };
      
      // Create a mock enemy object for drawing
      const mockEnemy = {
        behavior: behavior,
        isShooter: isShooter,
        color: color,
        x: animState.x,
        y: animState.y,
        r: animState.radius,
        hasShield: behavior === 'juggernaut',
        shieldHP: behavior === 'juggernaut' ? 3 : 0,
        maxShieldHP: behavior === 'juggernaut' ? 3 : 0,
        shieldDirection: behavior === 'juggernaut' ? { x: 1, y: 0 } : null
      };
      
      function animate() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Update position with smooth movement
        animState.time += 0.02;
        
        // Behavior-specific movement patterns
        if (behavior === 'prowler') {
          // Flanking movement - circles around
          const angle = animState.time * 2;
          mockEnemy.x = (40 + Math.cos(angle) * 15) * scale;
          mockEnemy.y = (40 + Math.sin(angle) * 8) * scale;
        } else if (behavior === 'serpent') {
          // Serpent - smooth zigzag
          const progress = (Math.sin(animState.time) + 1) / 2;
          mockEnemy.x = (24 + progress * 32) * scale;
          mockEnemy.y = (40 + Math.sin(animState.time * 3) * 8) * scale;
        } else if (behavior === 'maniac') {
          // Maniac - erratic random-ish movement
          const erraticX = Math.sin(animState.time * 2.7) + Math.sin(animState.time * 4.3) * 0.5;
          const erraticY = Math.cos(animState.time * 3.1) + Math.sin(animState.time * 5.7) * 0.3;
          mockEnemy.x = (40 + erraticX * 12) * scale;
          mockEnemy.y = (40 + erraticY * 8) * scale;
        } else if (behavior === 'leaper') {
          // Jumping motion
          const jumpCycle = animState.time % 2;
          const progress = (Math.sin(animState.time) + 1) / 2;
          mockEnemy.x = (24 + progress * 32) * scale;
          if (jumpCycle < 0.3) {
            mockEnemy.y = (40 - Math.sin((jumpCycle / 0.3) * Math.PI) * 10) * scale;
          } else {
            mockEnemy.y = 40 * scale;
          }
        } else {
          // Default back and forth movement
          const progress = (Math.sin(animState.time) + 1) / 2;
          const moveRange = behavior === 'superboss' || behavior === 'boss' ? 16 : 24;
          mockEnemy.x = (40 - moveRange/2 + progress * moveRange) * scale;
          mockEnemy.y = 40 * scale;
        }
        
        // Scale the radius for drawing
        mockEnemy.r = animState.radius * scale;
        
        // Handle shooting enemies
        if (isShooter || behavior === 'vortex') {
          // Spawn projectiles periodically
          if (animState.time - animState.lastShot > 1.5) {
            animState.lastShot = animState.time;
            
            if (shootPattern === 'spread') {
              // Triple spread shot
              for (let i = -1; i <= 1; i++) {
                const angle = i * 0.3; // Spread angle
                animState.projectiles.push({
                  x: mockEnemy.x / scale,
                  y: mockEnemy.y / scale,
                  vx: Math.cos(angle) * 2,
                  vy: Math.sin(angle) * 2,
                  life: 1
                });
              }
            } else if (shootPattern === 'burst') {
              // Burst fire (3 rapid shots)
              for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                  animState.projectiles.push({
                    x: mockEnemy.x / scale,
                    y: mockEnemy.y / scale,
                    vx: 2,
                    vy: 0,
                    life: 1
                  });
                }, i * 100); // 100ms between burst shots
              }
            } else {
              // Single shot (default)
              animState.projectiles.push({
                x: mockEnemy.x / scale,
                y: mockEnemy.y / scale,
                vx: behavior === 'vortex' ? Math.cos(animState.time * 3) * 2 : 2,
                vy: behavior === 'vortex' ? Math.sin(animState.time * 3) * 2 : 0,
                life: 1
              });
            }
          }
        }
        
        // Update and draw projectiles
        animState.projectiles = animState.projectiles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.life -= 0.02;
          
          if (p.life > 0) {
            ctx.save();
            ctx.fillStyle = '#ff0000';
            ctx.globalAlpha = p.life;
            ctx.beginPath();
            ctx.arc(p.x * scale, p.y * scale, 3 * scale, 0, TAU);
            ctx.fill();
            ctx.restore();
            return true;
          }
          return false;
        });
        
        // Update juggernaut shield direction to face "player"
        if (behavior === 'juggernaut' && mockEnemy.hasShield) {
          // Simulate player at center-left of the preview area
          const playerX = 20 * scale;
          const playerY = 40 * scale;
          
          // Calculate direction from juggernaut to "player"
          const dx = playerX - mockEnemy.x;
          const dy = playerY - mockEnemy.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          mockEnemy.shieldDirection = { 
            x: dx / dist, 
            y: dy / dist 
          };
        }
        
        // Draw juggernaut shield using the same rendering as in-game
        if (mockEnemy.behavior === 'juggernaut' && mockEnemy.hasShield && mockEnemy.shieldHP > 0) {
          const shieldDir = mockEnemy.shieldDirection || { x: 1, y: 0 };
          const shieldOffset = mockEnemy.r + 5; // 5 pixels in front of enemy
          const shieldX = mockEnemy.x + shieldDir.x * shieldOffset;
          const shieldY = mockEnemy.y + shieldDir.y * shieldOffset;
          
          // Shield dimensions
          const shieldWidth = mockEnemy.r * 1.2;
          const shieldHeight = mockEnemy.r * 0.8;
          
          // Shield health-based transparency
          const shieldAlpha = Math.max(0.3, mockEnemy.shieldHP / mockEnemy.maxShieldHP);
          
          ctx.save();
          ctx.globalAlpha = shieldAlpha;
          ctx.fillStyle = '#cccccc'; // Light gray shield (very visible)
          ctx.fillRect(shieldX - shieldWidth/2, shieldY - shieldHeight/2, shieldWidth, shieldHeight);
          
          // Shield border
          ctx.strokeStyle = '#aaaaaa';
          ctx.lineWidth = 1;
          ctx.strokeRect(shieldX - shieldWidth/2, shieldY - shieldHeight/2, shieldWidth, shieldHeight);
          ctx.restore();
        }
        
        // Draw the enemy
        ctx.save();
        
        // Draw enemy body
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(mockEnemy.x, mockEnemy.y, mockEnemy.r, 0, TAU);
        ctx.fill();
        
        // Draw enemy symbol
        drawEnemySymbol(ctx, mockEnemy, mockEnemy.x, mockEnemy.y, mockEnemy.r);
        
        ctx.restore();
        
        // Continue animation
        const animId = requestAnimationFrame(animate);
        
        // Store animation reference
        const animRef = { id: animId, canvas: canvas };
        const existingIndex = enemyPreviewAnimations.findIndex(a => a.canvas === canvas);
        if (existingIndex >= 0) {
          enemyPreviewAnimations[existingIndex] = animRef;
        } else {
          enemyPreviewAnimations.push(animRef);
        }
      }
      
      // Start animation for this canvas
      animate();
    });
  }
  
  // Track crystal preview animations
  let crystalPreviewAnimations = [];
  let crystalAnimationsRunning = false;
  
  // Initialize crystal preview animations
  function initCrystalPreviews() {
    // Don't reinitialize if already running
    if (crystalAnimationsRunning) {
      return;
    }
    
    // Clear any existing animations first
    crystalPreviewAnimations.forEach(anim => anim.stop());
    crystalPreviewAnimations = [];
    crystalAnimationsRunning = true;
    
    // Get all canvas elements for crystal previews
    const canvases = document.querySelectorAll('.crystal-preview-canvas');
    
    canvases.forEach(canvas => {
      const ctx = canvas.getContext('2d');
      const type = canvas.dataset.crystalType;
      const color = canvas.dataset.crystalColor;
      
      // Center point for crystal (2x bigger)
      const centerX = 50;  // Updated for 100x100 canvas
      const centerY = 50;  // Updated for 100x100 canvas
      const size = type === 'homing' ? 30 : 24;  // Doubled from 15:12
      
      // Animation state
      let rotation = 0;
      let time = 0;
      let particleTimer = 0.29; // Start near spawn time to trigger particles quickly
      const particles = [];
      
      let animId = null;
      let animationActive = true;
      
      function drawCrystal() {
        // Validate canvas is still in DOM
        if (!document.body.contains(canvas)) {
          animationActive = false;
          if (animId) cancelAnimationFrame(animId);
          return;
        }
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Update particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx * 0.016;
          p.y += p.vy * 0.016;
          p.life += 0.016;
          if (p.life > p.maxLife) {
            particles.splice(i, 1);
          }
        }
        
        // Save context state
        ctx.save();
        
        // Apply slow rotation
        ctx.translate(centerX, centerY);
        ctx.rotate(rotation);
        ctx.translate(-centerX, -centerY);
        
        // Special golden glow for homing crystals (before main crystal)
        if (type === 'homing') {
          const glowIntensity = 0.7 + 0.3 * Math.sin(time * 15);
          const glowSize = 35 + 10 * Math.sin(time * 8);
          
          const outerGlow = ctx.createRadialGradient(centerX, centerY, 8, centerX, centerY, glowSize);
          outerGlow.addColorStop(0, `rgba(255,215,0,${glowIntensity * 0.8})`);
          outerGlow.addColorStop(0.5, `rgba(255,215,0,${glowIntensity * 0.4})`);
          outerGlow.addColorStop(1, 'rgba(255,215,0,0)');
          
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.fillStyle = outerGlow;
          ctx.beginPath();
          ctx.arc(centerX, centerY, glowSize, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        
        // Create gradient for crystal
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size);
        
        if (type === 'homing') {
          // Golden gradient for homing (matching in-game)
          gradient.addColorStop(0, '#ffffff');
          gradient.addColorStop(0.5, '#FFD700');
          gradient.addColorStop(1, '#FFD70088');
        } else if (type === 'lightning') {
          // Yellow/blue gradient for lightning
          gradient.addColorStop(0, '#FFFF00');
          gradient.addColorStop(0.3, '#FFD700');
          gradient.addColorStop(0.6, '#87CEEB');
          gradient.addColorStop(1, '#87CEEB66');
        } else {
          // Convert hex to proper alpha format
          gradient.addColorStop(0, color);
          gradient.addColorStop(0.7, color + (color.length === 7 ? 'cc' : ''));
          gradient.addColorStop(1, color + (color.length === 7 ? '66' : ''));
        }
        
        ctx.fillStyle = gradient;
        ctx.strokeStyle = type === 'homing' ? '#FFFFFF' : '#ffffff88';
        ctx.lineWidth = type === 'homing' ? 2 : 1;
        
        // Draw different shapes based on crystal type
        ctx.beginPath();
        
        if (type === 'homing') {
          // Star shape for homing
          for (let i = 0; i < 8; i++) {
            const angle = (i * Math.PI / 4) - Math.PI / 2;
            const radius = i % 2 === 0 ? size : size * 0.5;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
        } else if (type === 'explosive') {
          // Hexagon for explosive
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI / 3) - Math.PI / 6;
            const x = centerX + Math.cos(angle) * size;
            const y = centerY + Math.sin(angle) * size;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
        } else if (type === 'lightning') {
          // Lightning bolt shape - simple zig-zag
          ctx.moveTo(centerX - size*0.3, centerY - size);
          ctx.lineTo(centerX + size*0.2, centerY - size*0.3);
          ctx.lineTo(centerX - size*0.1, centerY);
          ctx.lineTo(centerX + size*0.3, centerY + size);
          ctx.lineTo(centerX - size*0.2, centerY + size*0.3);
          ctx.lineTo(centerX, centerY);
          // Don't manually close - let closePath() handle it
        } else if (type === 'freeze') {
          // Snowflake shape (6-pointed star)
          for (let i = 0; i < 12; i++) {
            const angle = (i * Math.PI / 6) - Math.PI / 2;
            const radius = i % 2 === 0 ? size : size * 0.4;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
        } else if (type === 'ricochet') {
          // Triangle for ricochet
          ctx.moveTo(centerX, centerY - size);
          ctx.lineTo(centerX + size * 0.866, centerY + size * 0.5);
          ctx.lineTo(centerX - size * 0.866, centerY + size * 0.5);
        } else if (type === 'shotgun') {
          // Stylized connected spread crystal for shotgun
          // Main body with flared end
          ctx.moveTo(centerX - size * 0.3, centerY + size * 0.4);
          ctx.lineTo(centerX - size * 0.3, centerY - size * 0.4);
          ctx.lineTo(centerX + size * 0.2, centerY - size * 0.3);
          // Top spread arm
          ctx.lineTo(centerX + size * 0.5, centerY - size * 0.7);
          ctx.lineTo(centerX + size * 0.8, centerY - size * 0.6);
          ctx.lineTo(centerX + size * 0.6, centerY - size * 0.3);
          // Middle spread arm
          ctx.lineTo(centerX + size * 0.7, centerY);
          ctx.lineTo(centerX + size * 0.9, centerY);
          ctx.lineTo(centerX + size * 0.7, centerY);
          // Bottom spread arm
          ctx.lineTo(centerX + size * 0.6, centerY + size * 0.3);
          ctx.lineTo(centerX + size * 0.8, centerY + size * 0.6);
          ctx.lineTo(centerX + size * 0.5, centerY + size * 0.7);
          ctx.lineTo(centerX + size * 0.2, centerY + size * 0.3);
        } else if (type === 'cluster') {
          // Three overlapping circles for cluster
          ctx.arc(centerX - size*0.4, centerY, size*0.6, 0, Math.PI * 2);
          ctx.moveTo(centerX + size*0.4 + size*0.6, centerY - size*0.3);
          ctx.arc(centerX + size*0.4, centerY - size*0.3, size*0.6, 0, Math.PI * 2);
          ctx.moveTo(centerX + size*0.4 + size*0.6, centerY + size*0.3);
          ctx.arc(centerX + size*0.4, centerY + size*0.3, size*0.6, 0, Math.PI * 2);
        } else if (type === 'seeking') {
          // Cool stylized arrow with swept-back wings
          // Arrow tip
          ctx.moveTo(centerX, centerY - size);
          // Right wing
          ctx.lineTo(centerX + size*0.8, centerY - size*0.2);
          ctx.lineTo(centerX + size*0.5, centerY);
          // Right shaft indent
          ctx.lineTo(centerX + size*0.3, centerY - size*0.1);
          // Shaft
          ctx.lineTo(centerX + size*0.2, centerY + size*0.6);
          // Right tail fin
          ctx.lineTo(centerX + size*0.6, centerY + size*0.8);
          ctx.lineTo(centerX + size*0.2, centerY + size);
          // Bottom center
          ctx.lineTo(centerX, centerY + size*0.7);
          // Left tail fin
          ctx.lineTo(centerX - size*0.2, centerY + size);
          ctx.lineTo(centerX - size*0.6, centerY + size*0.8);
          // Left shaft
          ctx.lineTo(centerX - size*0.2, centerY + size*0.6);
          // Left shaft indent
          ctx.lineTo(centerX - size*0.3, centerY - size*0.1);
          // Left wing
          ctx.lineTo(centerX - size*0.5, centerY);
          ctx.lineTo(centerX - size*0.8, centerY - size*0.2);
        } else {
          // Default diamond shape (for upgrade/dual, triple, quad)
          ctx.moveTo(centerX, centerY - size);
          ctx.lineTo(centerX + size, centerY);
          ctx.lineTo(centerX, centerY + size);
          ctx.lineTo(centerX - size, centerY);
        }
        
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Restore context state for non-rotated effects
        ctx.restore();
        
        // 2. Pulsing inner glow based on crystal type (EXACTLY like the game)
        let pulseSpeed = 4;
        let pulseIntensity = 0.3;
        
        // Different pulse patterns for different crystal types
        if (type === 'homing') {
          pulseSpeed = 8; // Fast pulse for homing
          pulseIntensity = 0.5;
        } else if (type === 'explosive') {
          pulseSpeed = 3; // Slow, intense pulse
          pulseIntensity = 0.4;
        } else if (type === 'lightning') {
          pulseSpeed = 10; // Very fast flicker
          pulseIntensity = 0.6;
        } else if (type === 'freeze') {
          pulseSpeed = 2; // Very slow, gentle
          pulseIntensity = 0.2;
        }
        
        const pulse = Math.sin(time * pulseSpeed) * pulseIntensity + (1 - pulseIntensity);
        const coreSize = Math.max(1, size * 0.3 * pulse); // Ensure coreSize is never negative or zero
        
        ctx.save();
        ctx.globalAlpha = 0.8;
        const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSize);
        coreGradient.addColorStop(0, '#ffffff');
        coreGradient.addColorStop(0.5, color);
        coreGradient.addColorStop(1, color + '00');
        
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, coreSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // 3. Particle effects (sparkles/energy wisps) - EXACTLY like the game
        particleTimer += 0.016;
        
        // Spawn sparkle particles periodically (more frequent for lightning)
        const spawnInterval = type === 'lightning' ? 0.15 : 0.3;  // Lightning spawns twice as often
        if (particleTimer > spawnInterval) {
          particleTimer = 0;
          
          // Spawn more particles for lightning
          const particleCount = type === 'homing' ? 3 : 
                               type === 'lightning' ? 4 : 2;  // Lightning gets 4 particles
          for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = size * 0.8 + Math.random() * 5; // Spawn closer to crystal
            
            particles.push({
              x: centerX + Math.cos(angle) * distance,
              y: centerY + Math.sin(angle) * distance,
              vx: (Math.random() - 0.5) * 10, // Slower movement
              vy: -15 - Math.random() * 10, // Slower upward movement
              life: 0,
              maxLife: 1.0 + Math.random() * 0.5, // Longer life
              size: 2 + Math.random() * 3, // Bigger particles
              // Use brighter colors for dark crystals
              color: type === 'homing' ? '#ffffff' : 
                     type === 'lightning' ? '#00FFFF' :  // Bright cyan for lightning
                     type === 'shotgun' ? '#FFB347' :    // Brighter orange for shotgun
                     color
            });
          }
        }
        
        // Draw particles
        particles.forEach(p => {
          const alpha = 1 - (p.life / p.maxLife);
          ctx.save();
          ctx.globalAlpha = alpha * 0.8;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
        
        // Update animation state for next frame
        rotation += 0.005; // VERY slow spinning
        time += 0.016; // Time for pulsing effects
        
        // Continue animation only if still active
        if (animationActive) {
          animId = requestAnimationFrame(drawCrystal);
        }
      }
      
      // Store animation reference BEFORE starting
      const animRef = { 
        canvas, 
        getId: () => animId,  // Function to get current ID
        stop: () => { 
          animationActive = false;
          if (animId) cancelAnimationFrame(animId); 
        },
        isActive: () => animationActive
      };
      crystalPreviewAnimations.push(animRef);
      
      // Start animation
      drawCrystal();
    });
  }
  
  // ===== Helper function to create enemy legend HTML =====
  function createEnemyLegendHTML() {
    return `
      <div class="enemy-legend" style="padding: 12px; font-size: 13px;">
        <div style="margin-bottom: 12px;">
          <strong style="color: var(--accent); font-size: 14px;">Enemy Types & Behaviors</strong>
        </div>
        <div class="enemy-category">
          <h4>⚙️ HOW ENEMIES WORK</h4>
          <div style="font-size: 12px; color: var(--muted); line-height: 1.6; margin-bottom: 10px;">
            <div><strong>COLOR = SPEED</strong> (Red=Fast, Purple=Slow)</div>
            <div><strong>SYMBOL = BEHAVIOR</strong> (Special ability)</div>
            <div>Each enemy = 1 base type + 1 behavior</div>
          </div>
        </div>
        
        <div class="enemy-category">
          <h4>🏃 SPEED COLORS</h4>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#FF0000" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Red</div>
              <div class="enemy-desc">Fastest - Run away!</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#FF4400" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Orange-Red</div>
              <div class="enemy-desc">Very fast</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#FF8800" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Orange</div>
              <div class="enemy-desc">Fast</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#FFAA00" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Yellow</div>
              <div class="enemy-desc">Above average</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#AAFF00" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Yellow-Green</div>
              <div class="enemy-desc">Average speed</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#00FF88" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Cyan</div>
              <div class="enemy-desc">Below average</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#00CCFF" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Blue</div>
              <div class="enemy-desc">Slow</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#CC44FF" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Purple</div>
              <div class="enemy-desc">Very slow</div>
            </div>
          </div>
        </div>
        
        <div class="enemy-category">
          <h4>🎯 BEHAVIOR SYMBOLS</h4>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">• Stalker</div>
              <div class="enemy-desc">Basic - Direct pursuit</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="volatile" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">! Volatile</div>
              <div class="enemy-desc">Explodes on death</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="berserker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">»»» Berserker</div>
              <div class="enemy-desc">Charges at player</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="maniac" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">✗ Maniac</div>
              <div class="enemy-desc">Erratic movement</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="serpent" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">~ Serpent</div>
              <div class="enemy-desc">Zigzag pattern</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="prowler" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">() Prowler</div>
              <div class="enemy-desc">Flanking attacks</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="leaper" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">↑ Leaper</div>
              <div class="enemy-desc">Jump attacks</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="vortex" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">◔ Vortex</div>
              <div class="enemy-desc">Shoots in spiral pattern</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="divider" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Y Divider</div>
              <div class="enemy-desc">Splits into 2-3</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="trapper" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">⬢ Trapper</div>
              <div class="enemy-desc">Lays mines</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="bomber" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">●‾ Bomber</div>
              <div class="enemy-desc">Throws grenades</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="juggernaut" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">⬡ Juggernaut</div>
              <div class="enemy-desc">Shield + knockback</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="stalker" data-enemy-shooter="true" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">+ Shooter</div>
              <div class="enemy-desc">Single projectile</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="stalker" data-enemy-shooter="true" data-shoot-pattern="spread" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">+× Spread Shooter</div>
              <div class="enemy-desc">Triple spread shot</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="stalker" data-enemy-shooter="true" data-shoot-pattern="burst" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">+• Burst Shooter</div>
              <div class="enemy-desc">Rapid 3-shot burst</div>
            </div>
          </div>
        </div>
        
        <div class="enemy-category">
          <h4>👑 SPECIAL TYPES</h4>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#800080" data-enemy-behavior="superboss" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Super Boss</div>
              <div class="enemy-desc">Wave 10/20/30 • 9x HP</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#FFCC00" data-enemy-behavior="boss" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Mini Boss</div>
              <div class="enemy-desc">Wave 5/15/25 • 2x HP</div>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  // ===== Options Menu Functions =====
  let optionsMenuOpen = false;
  let optionsMenuInitialized = false;
  
  function showOptionsMenu() {
    if (optionsMenuOpen) return;
    optionsMenuOpen = true;
    
    // Hide start menu
    banner.style.display = 'none';
    
    // Show and setup options panel
    optionsPanel.style.display = 'block';
    optionsPanel.style.animation = 'optionsFadeIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
    
    // Only create content once
    if (!optionsMenuInitialized) {
      optionsMenuInitialized = true;
      // Clear options panel content ONLY on first creation
      optionsPanel.innerHTML = '';
    
    // Create options screen elements with tabs (exact copy of pause menu)
    
    // Tab container
    const tabContainer = document.createElement('div');
    tabContainer.className = 'tab-container';
    
    const controlsTab = document.createElement('button');
    controlsTab.className = 'tab-button active';
    controlsTab.textContent = 'Controls';
    controlsTab.onclick = (e) => switchOptionsTab('controls', e);
    
    const enemiesTab = document.createElement('button');
    enemiesTab.className = 'tab-button';
    enemiesTab.textContent = 'Enemies';
    enemiesTab.onclick = (e) => switchOptionsTab('enemies', e);
    
    const crystalsTab = document.createElement('button');
    crystalsTab.className = 'tab-button';
    crystalsTab.textContent = 'Crystals';
    crystalsTab.onclick = (e) => switchOptionsTab('crystals', e);
    
    tabContainer.appendChild(controlsTab);
    tabContainer.appendChild(enemiesTab);
    tabContainer.appendChild(crystalsTab);
    
    // Controls panel (default active)
    const controlsDiv = document.createElement('div');
    controlsDiv.id = 'options-controls-content';
    controlsDiv.className = 'controls-panel tab-content active';
    controlsDiv.innerHTML = createControlsHTML();
    
    // Enemy legend panel
    const enemiesDiv = document.createElement('div');
    enemiesDiv.id = 'options-enemies-content';
    enemiesDiv.className = 'controls-panel tab-content';
    enemiesDiv.innerHTML = createEnemyLegendHTML();
    
    // Initialize enemy preview animations when panel is created
    setTimeout(() => {
      if (document.querySelector('.enemy-preview-canvas')) {
        initEnemyPreviews();
      }
    }, 100);
    
    // Crystals panel
    const crystalsDiv = document.createElement('div');
    crystalsDiv.id = 'options-crystals-content';
    crystalsDiv.className = 'controls-panel tab-content';
    crystalsDiv.innerHTML = createCrystalLegendHTML();
    
    const backBtn = document.createElement('button');
    backBtn.id = 'optionsBackBtn';
    backBtn.textContent = 'Back';
    backBtn.onclick = hideOptionsMenu;
    
    // Add tab switching function for options
    window.switchOptionsTab = function(tabName, evt) {
      // Update tab buttons
      optionsPanel.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
      });
      if (evt && evt.target) {
        evt.target.classList.add('active');
      }
      
      // Update content panels
      optionsPanel.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      const targetContent = optionsPanel.querySelector('#options-' + tabName + '-content');
      if (targetContent) {
        targetContent.classList.add('active');
      }
      
      // Initialize preview animations when switching tabs
      if (tabName === 'enemies') {
        setTimeout(() => {
          initEnemyPreviews();
        }, 50);
      } else if (tabName === 'crystals') {
        setTimeout(() => {
          initCrystalPreviews();
        }, 50);
      }
    };
    
    optionsPanel.appendChild(tabContainer);
    optionsPanel.appendChild(controlsDiv);
    optionsPanel.appendChild(enemiesDiv);
    optionsPanel.appendChild(crystalsDiv);
    optionsPanel.appendChild(backBtn);
    } // End of if (!optionsMenuInitialized)
    
    // Re-initialize crystal animations if crystals tab is visible
    const crystalsContent = document.getElementById('options-crystals-content');
    if (crystalsContent && crystalsContent.classList.contains('active')) {
      setTimeout(() => {
        initCrystalPreviews();
      }, 50);
    }
  }
  
  function hideOptionsMenu() {
    optionsMenuOpen = false;
    // Reset animation flags when closing options menu
    crystalAnimationsRunning = false;
    crystalPreviewAnimations.forEach(anim => anim.stop());
    crystalPreviewAnimations = [];
    optionsPanel.style.animation = 'optionsFadeOut 0.3s ease-out forwards';
    setTimeout(() => {
      optionsPanel.style.display = 'none';
      // Don't clear innerHTML here - keep content for next open
    }, 300);
    banner.style.display = 'block';
  }
  
  
  // ===== Helper function to create crystal legend HTML =====
  function createCrystalLegendHTML() {
    // Create unique crystal data for rendering (colors from bulletPowerups array)
    const crystals = [
      { type: 'homing', color: '#FFD700', name: 'Homing', desc: 'Bullets auto-track enemies', category: 'ultra' },
      { type: 'explosive', color: '#FF4500', name: 'Explosive', desc: 'Area damage on impact', category: 'effect' },
      { type: 'lightning', color: '#00BFFF', name: 'Lightning', desc: 'Chain damage to nearby foes', category: 'effect' },
      { type: 'freeze', color: '#00CED1', name: 'Freeze', desc: 'Slows enemies on hit', category: 'effect' },
      { type: 'ricochet', color: '#FF69B4', name: 'Ricochet', desc: 'Bullets bounce off enemies', category: 'effect' },
      { type: 'seeking', color: '#DC143C', name: 'Seeking', desc: 'Mild homing effect', category: 'effect' },
      { type: 'shotgun', color: '#8B4513', name: 'Shotgun', desc: 'Wide spread pattern', category: 'effect' },
      { type: 'cluster', color: '#FFA500', name: 'Cluster', desc: 'Splits into mini bullets', category: 'effect' },
      { type: 'upgrade', color: '#32CD32', name: 'Dual Shot', desc: 'Front & back bullets', category: 'pattern' },
      { type: 'triple', color: '#00BFFF', name: 'Triple Shot', desc: '3-way spread', category: 'pattern' },
      { type: 'quad', color: '#FF1493', name: 'Quad Shot', desc: '4 directions', category: 'pattern' }
    ];
    
    let html = `
      <div class="crystal-legend" style="padding: 12px; font-size: 13px;">
        <div style="margin-bottom: 12px;">
          <strong style="color: var(--accent); font-size: 14px;">Crystal Types & Effects</strong>
        </div>`;
    
    // Ultra rare section
    html += `
        <div class="crystal-category" style="margin-bottom: 8px;">
          <h4 style="color: #FFD700; margin: 8px 0 4px 0; font-size: 13px;">⭐ ULTRA RARE (0.5%)</h4>`;
    
    crystals.filter(c => c.category === 'ultra').forEach(crystal => {
      html += `
          <div class="crystal-item" style="margin: 4px 0; display: flex; align-items: center;">
            <canvas class="crystal-preview-canvas" 
                    data-crystal-type="${crystal.type}" 
                    data-crystal-color="${crystal.color}"
                    width="100" height="100"
                    style="width: 50px; height: 50px; margin-right: 8px;">
            </canvas>
            <div><span style="color: ${crystal.color};">${crystal.name}</span> - ${crystal.desc}</div>
          </div>`;
    });
    
    html += `</div>`;
    
    // Effect crystals section
    html += `
        <div class="crystal-category" style="margin-bottom: 8px;">
          <h4 style="color: #5af2c7; margin: 8px 0 4px 0; font-size: 13px;">💎 EFFECT CRYSTALS</h4>`;
    
    crystals.filter(c => c.category === 'effect').forEach(crystal => {
      html += `
          <div class="crystal-item" style="margin: 4px 0; display: flex; align-items: center;">
            <canvas class="crystal-preview-canvas" 
                    data-crystal-type="${crystal.type}" 
                    data-crystal-color="${crystal.color}"
                    width="100" height="100"
                    style="width: 50px; height: 50px; margin-right: 8px;">
            </canvas>
            <div><span style="color: ${crystal.color};">${crystal.name}</span> - ${crystal.desc}</div>
          </div>`;
    });
    
    html += `</div>`;
    
    // Pattern crystals section
    html += `
        <div class="crystal-category">
          <h4 style="color: #5af2c7; margin: 8px 0 4px 0; font-size: 13px;">🔫 PATTERN CRYSTALS</h4>`;
    
    crystals.filter(c => c.category === 'pattern').forEach(crystal => {
      html += `
          <div class="crystal-item" style="margin: 4px 0; display: flex; align-items: center;">
            <canvas class="crystal-preview-canvas" 
                    data-crystal-type="${crystal.type}" 
                    data-crystal-color="${crystal.color}"
                    width="100" height="100"
                    style="width: 50px; height: 50px; margin-right: 8px;">
            </canvas>
            <div><span style="color: ${crystal.color};">${crystal.name}</span> - ${crystal.desc}</div>
          </div>`;
    });
    
    html += `</div>`;
    
    // Footer tips
    html += `
        <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid var(--muted); font-size: 11px; color: var(--muted);">
          <div>💡 Crystals have limited shots (25-50)</div>
          <div>💡 Effects can stack for powerful combos</div>
          <div>💡 Pattern upgrades double your bullets</div>
        </div>
      </div>
    `;
    
    // Don't initialize here - it's done when switching tabs
    
    return html;
  }

  // ===== Helper function to create controls HTML =====
  function createControlsHTML() {
    return `
      <div class="controls-title"><strong>Controls</strong></div>
      <div class="control-row">
        <div class="control-keys"><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd></div>
        <div class="control-desc">Move around the arena</div>
      </div>
      <div class="control-row">
        <div class="control-keys"><kbd>Mouse</kbd></div>
        <div class="control-desc">Aim and shoot</div>
      </div>
      <div class="control-row">
        <div class="control-keys"><kbd>Shift</kbd></div>
        <div class="control-desc">Dash through enemies</div>
      </div>
      <div class="control-row">
        <div class="control-keys"><kbd>Space</kbd></div>
        <div class="control-desc">Emergency leap</div>
      </div>
      <div class="control-row">
        <div class="control-keys"><kbd>P</kbd> or <kbd>ESC</kbd></div>
        <div class="control-desc">Pause / Resume game</div>
      </div>
      <div class="control-row">
        <div class="control-keys"><kbd>F11</kbd></div>
        <div class="control-desc">Toggle fullscreen</div>
      </div>
      <div class="mobile-note">Mobile: Touch left side to move, right side to aim/shoot<br>
      💨 Sprint (bottom left) | ⚡ Leap (bottom right) | ⏸️ Pause (top right)</div>
    `;
  }
  
  // ===== Pause / Resume =====
  function togglePause(){
    if (!game || (game.state!==STATE.RUN && game.state!==STATE.PAUSE)) return;
    if (game.state === STATE.RUN) {
      setState(game, STATE.PAUSE);
      banner.style.display = 'block';
      banner.style.animation = 'pauseSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
      // Clear banner content efficiently
      banner.innerHTML = '';
      
      // Create pause screen elements with tabs
      
      // Tab container
      const tabContainer = document.createElement('div');
      tabContainer.className = 'tab-container';
      
      const controlsTab = document.createElement('button');
      controlsTab.className = 'tab-button active';
      controlsTab.textContent = 'Controls';
      controlsTab.onclick = (e) => switchTab('controls', e);
      
      const enemiesTab = document.createElement('button');
      enemiesTab.className = 'tab-button';
      enemiesTab.textContent = 'Enemies';
      enemiesTab.onclick = (e) => switchTab('enemies', e);
      
      const upgradesTab = document.createElement('button');
      upgradesTab.className = 'tab-button';
      upgradesTab.textContent = 'Upgrades';
      upgradesTab.onclick = (e) => switchTab('upgrades', e);
      
      const crystalsTab = document.createElement('button');
      crystalsTab.className = 'tab-button';
      crystalsTab.textContent = 'Crystals';
      crystalsTab.onclick = (e) => switchTab('crystals', e);
      
      tabContainer.appendChild(controlsTab);
      tabContainer.appendChild(enemiesTab);
      tabContainer.appendChild(upgradesTab);
      tabContainer.appendChild(crystalsTab);
      
      // Controls panel (default active)
      const controlsDiv = document.createElement('div');
      controlsDiv.id = 'controls-content';
      controlsDiv.className = 'controls-panel tab-content active';
      controlsDiv.innerHTML = createControlsHTML();
      
      // Enemy legend panel
      const enemiesDiv = document.createElement('div');
      enemiesDiv.id = 'enemies-content';
      enemiesDiv.className = 'controls-panel tab-content';
      enemiesDiv.innerHTML = createEnemyLegendHTML();
      
      // Initialize enemy preview animations when panel is created
      setTimeout(() => {
        if (document.querySelector('.enemy-preview-canvas')) {
          initEnemyPreviews();
        }
      }, 100);
      
      // Upgrades panel
      const upgradesDiv = document.createElement('div');
      upgradesDiv.id = 'upgrades-content';
      upgradesDiv.className = 'controls-panel tab-content';
      upgradesDiv.style.cssText = 'padding: 12px; font-size: 13px;';
      
      const upgradesTitle = document.createElement('div');
      upgradesTitle.style.marginBottom = '8px';
      const upgradesStrong = document.createElement('strong');
      upgradesStrong.textContent = 'Active Upgrades';
      upgradesTitle.appendChild(upgradesStrong);
      
      const upgradesList = document.createElement('div');
      upgradesList.style.cssText = 'max-height: 120px; overflow-y: auto; line-height: 1.4;';
      
      const upgrades = createUpgradesDisplay();
      upgrades.forEach(upgrade => {
        const upgradeItem = document.createElement('div');
        upgradeItem.style.cssText = 'margin: 2px 0; color: #5af2c7;';
        upgradeItem.textContent = '• ' + upgrade;
        upgradesList.appendChild(upgradeItem);
      });
      
      upgradesDiv.appendChild(upgradesTitle);
      upgradesDiv.appendChild(upgradesList);
      
      // Crystals panel
      const crystalsDiv = document.createElement('div');
      crystalsDiv.id = 'crystals-content';
      crystalsDiv.className = 'controls-panel tab-content';
      crystalsDiv.innerHTML = createCrystalLegendHTML();
      
      const startBtn = document.createElement('button');
      startBtn.id = 'startBtn';
      startBtn.textContent = 'Resume';

      const mainMenuBtn = document.createElement('button');
      mainMenuBtn.id = 'mainMenuBtn';
      mainMenuBtn.textContent = 'Main Menu';
      mainMenuBtn.style.cssText = 'margin-top: 8px; background: #ff5b6e; border-color: #ff5b6e;';

      // Add tab switching function
      window.switchTab = function(tabName, evt) {
        // Update tab buttons - scope to pause banner only
        banner.querySelectorAll('.tab-button').forEach(btn => {
          btn.classList.remove('active');
        });
        if (evt && evt.target) {
          evt.target.classList.add('active');
        }
        
        // Update content panels - scope to pause banner only
        banner.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        const targetContent = banner.querySelector('#' + tabName + '-content');
        if (targetContent) {
          targetContent.classList.add('active');
        }
        
        // Initialize preview animations when switching tabs
        if (tabName === 'enemies') {
          setTimeout(() => {
            initEnemyPreviews();
          }, 50);
        } else if (tabName === 'crystals') {
          setTimeout(() => {
            initCrystalPreviews();
          }, 50);
        }
      };
      
      banner.appendChild(tabContainer);
      banner.appendChild(controlsDiv);
      banner.appendChild(enemiesDiv);
      banner.appendChild(upgradesDiv);
      banner.appendChild(crystalsDiv);
      banner.appendChild(startBtn);
      banner.appendChild(mainMenuBtn);

      // Re-attach event listener to the new Resume button
      document.getElementById('startBtn').addEventListener('click', () => {
        initAudio();
        if (game && game.state === STATE.PAUSE) {
          // Resume from pause
          togglePause();
        } else {
          // Start new game
          start();
        }
      });

      // Main Menu button returns to initial state by reloading the page
      document.getElementById('mainMenuBtn').addEventListener('click', () => {
        window.location.reload();
      });
    } else {
      banner.style.animation = 'pauseSlideOut 0.3s ease-out forwards';
      setTimeout(() => {
        banner.style.display = 'none';
      }, 300);
      // Reset animation flags when closing pause menu
      crystalAnimationsRunning = false;
      crystalPreviewAnimations.forEach(anim => anim.stop());
      crystalPreviewAnimations = [];
      game.state = STATE.RUN;
      // Restore original banner content efficiently
      banner.innerHTML = '';
      
      // Create start screen elements with enhanced styling
      
      const controlsDiv = document.createElement('div');
      controlsDiv.className = 'controls-panel';
      controlsDiv.innerHTML = createControlsHTML();
      
      const startBtn = document.createElement('button');
      startBtn.id = 'startBtn';
      startBtn.textContent = 'Start';
      
      banner.appendChild(controlsDiv);
      banner.appendChild(startBtn);
      // Re-attach event listener to the new Start button
      document.getElementById('startBtn').addEventListener('click', () => { 
        initAudio(); 
        if (game && game.state === STATE.PAUSE) {
          // Resume from pause
          togglePause();
        } else {
          // Start new game
          start(); 
        }
      });
    }
  }

  // ===== Start / Restart =====
  function start(){
    // Clear all existing game entities before creating new game
    enemies.items.forEach(e => e.alive = false);
    bullets.items.forEach(b => b.alive = false);
    particles.items.forEach(p => p.alive = false);
    
    // Clear any pools that might have grown
    enemies.items.length = 0;
    bullets.items.length = 0;
    particles.items.length = 0;
    
    game = newGame();
    // Animate out existing screens
    if (banner.style.display !== 'none') {
      banner.style.animation = 'pauseSlideOut 0.3s ease-out forwards';
      setTimeout(() => { banner.style.display = 'none'; }, 300);
    }
    if (gameOverPanel.style.display !== 'none') {
      gameOverPanel.style.animation = 'gameOverSlideOut 0.4s ease-out forwards';
      setTimeout(() => { gameOverPanel.style.display = 'none'; }, 400);
    } else {
      banner.style.display = 'none';
      gameOverPanel.style.display = 'none';
    }
    
    // Animate HUD fade in
    const hud = document.getElementById('hud');
    hud.style.animation = 'hudFadeIn 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards';
    hud.style.opacity = '1';
    hud.style.visibility = 'visible';
    game.state = STATE.RUN;
    
    // Show mobile controls during gameplay
    if (isMobile) {
      if (mobileControls) mobileControls.style.display = 'block';
      if (touchZonesElement) touchZonesElement.style.display = 'block';
    }
    // Center player
    game.player.x = canvas.width/2;
    game.player.y = canvas.height/2;
    
    // Trippy psychedelic game start effect
    gameStartOverlay.style.opacity = '1';
    gameStartOverlay.style.display = 'block';
    
    // Trigger all the ripple animations by re-adding the elements
    const rippleContainer = gameStartOverlay.querySelector('.ripple-container');
    const warpGrid = gameStartOverlay.querySelector('.warp-grid');
    const realityTear = gameStartOverlay.querySelector('.reality-tear');
    
    // Reset animations by removing and re-adding classes
    const ripples = rippleContainer.innerHTML;
    rippleContainer.innerHTML = '';
    warpGrid.style.animation = 'none';
    realityTear.style.animation = 'none';
    
    setTimeout(() => {
      rippleContainer.innerHTML = ripples;
      warpGrid.style.animation = 'warpGrid 1.8s ease-out';
      realityTear.style.animation = 'realityTear 1.8s ease-in-out';
    }, 10);
    
    // Add screen shake for extra impact
    canvas.style.animation = 'screenShake 0.5s ease-out';
    setTimeout(() => {
      canvas.style.animation = '';
    }, 500);
    
    // Hide overlay after animation completes
    setTimeout(() => {
      gameStartOverlay.style.transition = 'opacity 0.5s ease-out';
      gameStartOverlay.style.opacity = '0';
      setTimeout(() => {
        gameStartOverlay.style.display = 'none';
        gameStartOverlay.style.transition = '';
      }, 500);
    }, 1800);
    // Clear pools
    for (const it of bullets.items) it.alive = false;
    for (const it of enemies.items) it.alive = false;
    for (const it of particles.items) it.alive = false;
    for (const it of pickups.items) it.alive = false;
    for (const it of mines.items) it.alive = false;
    for (const it of bloodStains.items) it.alive = false;
    for (const it of enemyBullets.items) it.alive = false;
    
    // Start first wave
    game.waveActive = true;
    
    // Reset wave announcement state properly
    if (waveAnnouncement) {
      waveAnnouncement.style.animation = '';
      waveAnnouncement.style.display = 'none';
      waveAnnouncement.style.opacity = '';
      waveAnnouncement.dataset.active = 'false';
      // Clear any existing timeouts to prevent flash
      waveAnnouncementTimeouts.forEach(timeout => clearTimeout(timeout));
      waveAnnouncementTimeouts = [];
    }
    
    // Reset wave transition state
    waveTransitionInProgress = false;
    if (nextWaveTimeoutId) {
      clearTimeout(nextWaveTimeoutId);
      nextWaveTimeoutId = null;
    }
    
    // Spawn first wave enemies within 2-4 seconds
    const spawnDuration = 2000 + Math.random() * 2000; // 2-4 seconds
    const spawnInterval = spawnDuration / game.waveEnemiesTarget;
    
    for (let i = 0; i < game.waveEnemiesTarget; i++) {
      setTimeout(() => {
        if (game.waveActive) {
          spawnEnemy(game);
          game.waveEnemiesSpawned++;
        }
      }, i * spawnInterval);
    }
  }

  startBtn.addEventListener('click', () => { 
    initAudio(); 
    
    // Check orientation before starting on mobile
    if (isMobile && window.innerHeight > window.innerWidth) {
      if (orientationWarning) {
        orientationWarning.classList.add('show');
      }
      return; // Don't start if in portrait
    }
    
    if (game && game.state === STATE.PAUSE) {
      // Resume from pause
      togglePause();
    } else {
      // Start new game
      start(); 
    }
  });
  restartBtn.addEventListener('click', () => { start(); });
  
  // Options button listener
  optionsBtn.addEventListener('click', () => {
    showOptionsMenu();
  });

  // Start in menu
  game = newGame();

  // Improve crispness on some displays
  ctx.imageSmoothingEnabled = false;

  // Visibility pause
  document.addEventListener('visibilitychange', () => {
    if (document.hidden && game && game.state === STATE.RUN){
      togglePause();
    }
  });
  </script>
</body>
</html>
